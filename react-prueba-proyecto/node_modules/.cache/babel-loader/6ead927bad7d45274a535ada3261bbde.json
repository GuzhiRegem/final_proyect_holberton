{"ast":null,"code":"/* MapLibre GL JS is licensed under the 3-Clause BSD License. Full text of license: https://github.com/maplibre/maplibre-gl-js/blob/v2.1.6/LICENSE.txt */\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.maplibregl = factory());\n})(this, function () {\n  'use strict';\n  /* eslint-disable */\n\n  var shared, worker, maplibregl; // define gets called three times: one for each chunk. we rely on the order\n  // they're imported to know which is which\n\n  function define(_, chunk) {\n    if (!shared) {\n      shared = chunk;\n    } else if (!worker) {\n      worker = chunk;\n    } else {\n      var workerBundleString = 'var sharedChunk = {}; (' + shared + ')(sharedChunk); (' + worker + ')(sharedChunk);';\n      var sharedChunk = {};\n      shared(sharedChunk);\n      maplibregl = chunk(sharedChunk);\n\n      if (typeof window !== 'undefined') {\n        maplibregl.workerUrl = window.URL.createObjectURL(new Blob([workerBundleString], {\n          type: 'text/javascript'\n        }));\n      }\n    }\n  }\n\n  define([\"exports\"], function (t) {\n    \"use strict\";\n\n    var e = r;\n\n    function r(t, e, r, n) {\n      this.cx = 3 * t, this.bx = 3 * (r - t) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e, this.by = 3 * (n - e) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t, this.p1y = e, this.p2x = r, this.p2y = n;\n    }\n\n    function n(t, r, n, i) {\n      const s = new e(t, r, n, i);\n      return function (t) {\n        return s.solve(t);\n      };\n    }\n\n    r.prototype = {\n      sampleCurveX: function (t) {\n        return ((this.ax * t + this.bx) * t + this.cx) * t;\n      },\n      sampleCurveY: function (t) {\n        return ((this.ay * t + this.by) * t + this.cy) * t;\n      },\n      sampleCurveDerivativeX: function (t) {\n        return (3 * this.ax * t + 2 * this.bx) * t + this.cx;\n      },\n      solveCurveX: function (t, e) {\n        if (void 0 === e && (e = 1e-6), t < 0) return 0;\n        if (t > 1) return 1;\n\n        for (var r = t, n = 0; n < 8; n++) {\n          var i = this.sampleCurveX(r) - t;\n          if (Math.abs(i) < e) return r;\n          var s = this.sampleCurveDerivativeX(r);\n          if (Math.abs(s) < 1e-6) break;\n          r -= i / s;\n        }\n\n        var a = 0,\n            o = 1;\n\n        for (r = t, n = 0; n < 20 && (i = this.sampleCurveX(r), !(Math.abs(i - t) < e)); n++) t > i ? a = r : o = r, r = .5 * (o - a) + a;\n\n        return r;\n      },\n      solve: function (t, e) {\n        return this.sampleCurveY(this.solveCurveX(t, e));\n      }\n    };\n    const i = n(.25, .1, .25, 1);\n\n    function s(t, e, r) {\n      return Math.min(r, Math.max(e, t));\n    }\n\n    function a(t, e, r) {\n      const n = r - e,\n            i = ((t - e) % n + n) % n + e;\n      return i === e ? r : i;\n    }\n\n    function o(t) {\n      for (var _len = arguments.length, e = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        e[_key - 1] = arguments[_key];\n      }\n\n      for (const r of e) for (const e in r) t[e] = r[e];\n\n      return t;\n    }\n\n    let l = 1;\n\n    function u(t, e) {\n      t.forEach(t => {\n        e[t] && (e[t] = e[t].bind(e));\n      });\n    }\n\n    function c(t, e, r) {\n      const n = {};\n\n      for (const i in t) n[i] = e.call(r || this, t[i], i, t);\n\n      return n;\n    }\n\n    function h(t, e, r) {\n      const n = {};\n\n      for (const i in t) e.call(r || this, t[i], i, t) && (n[i] = t[i]);\n\n      return n;\n    }\n\n    function p(t) {\n      return Array.isArray(t) ? t.map(p) : \"object\" == typeof t && t ? c(t, p) : t;\n    }\n\n    const f = {};\n\n    function d(t) {\n      f[t] || (\"undefined\" != typeof console && console.warn(t), f[t] = !0);\n    }\n\n    function y(t, e, r) {\n      return (r.y - t.y) * (e.x - t.x) > (e.y - t.y) * (r.x - t.x);\n    }\n\n    function m(t) {\n      let e = 0;\n\n      for (let r, n, i = 0, s = t.length, a = s - 1; i < s; a = i++) r = t[i], n = t[a], e += (n.x - r.x) * (r.y + n.y);\n\n      return e;\n    }\n\n    function g() {\n      return \"undefined\" != typeof WorkerGlobalScope && \"undefined\" != typeof self && self instanceof WorkerGlobalScope;\n    }\n\n    function x(t) {\n      const e = {};\n\n      if (t.replace(/(?:^|(?:\\s*\\,\\s*))([^\\x00-\\x20\\(\\)<>@\\,;\\:\\\\\"\\/\\[\\]\\?\\=\\{\\}\\x7F]+)(?:\\=(?:([^\\x00-\\x20\\(\\)<>@\\,;\\:\\\\\"\\/\\[\\]\\?\\=\\{\\}\\x7F]+)|(?:\\\"((?:[^\"\\\\]|\\\\.)*)\\\")))?/g, (t, r, n, i) => {\n        const s = n || i;\n        return e[r] = !s || s.toLowerCase(), \"\";\n      }), e[\"max-age\"]) {\n        const t = parseInt(e[\"max-age\"], 10);\n        isNaN(t) ? delete e[\"max-age\"] : e[\"max-age\"] = t;\n      }\n\n      return e;\n    }\n\n    let v,\n        b,\n        w = null;\n\n    function _(t) {\n      if (null == w) {\n        const e = t.navigator ? t.navigator.userAgent : null;\n        w = !!t.safari || !(!e || !(/\\b(iPad|iPhone|iPod)\\b/.test(e) || e.match(\"Safari\") && !e.match(\"Chrome\")));\n      }\n\n      return w;\n    }\n\n    function A(t) {\n      return \"undefined\" != typeof ImageBitmap && t instanceof ImageBitmap;\n    }\n\n    const k = {\n      now: \"undefined\" != typeof performance && performance && performance.now ? performance.now.bind(performance) : Date.now.bind(Date),\n\n      frame(t) {\n        const e = requestAnimationFrame(t);\n        return {\n          cancel: () => cancelAnimationFrame(e)\n        };\n      },\n\n      getImageData(t) {\n        let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n        const r = window.document.createElement(\"canvas\"),\n              n = r.getContext(\"2d\");\n        if (!n) throw new Error(\"failed to create canvas 2d context\");\n        return r.width = t.width, r.height = t.height, n.drawImage(t, 0, 0, t.width, t.height), n.getImageData(-e, -e, t.width + 2 * e, t.height + 2 * e);\n      },\n\n      resolveURL: t => (v || (v = document.createElement(\"a\")), v.href = t, v.href),\n      hardwareConcurrency: \"undefined\" != typeof navigator && navigator.hardwareConcurrency || 4,\n\n      get prefersReducedMotion() {\n        return !!matchMedia && (null == b && (b = matchMedia(\"(prefers-reduced-motion: reduce)\")), b.matches);\n      }\n\n    };\n    var S = z;\n\n    function z(t, e) {\n      this.x = t, this.y = e;\n    }\n\n    z.prototype = {\n      clone: function () {\n        return new z(this.x, this.y);\n      },\n      add: function (t) {\n        return this.clone()._add(t);\n      },\n      sub: function (t) {\n        return this.clone()._sub(t);\n      },\n      multByPoint: function (t) {\n        return this.clone()._multByPoint(t);\n      },\n      divByPoint: function (t) {\n        return this.clone()._divByPoint(t);\n      },\n      mult: function (t) {\n        return this.clone()._mult(t);\n      },\n      div: function (t) {\n        return this.clone()._div(t);\n      },\n      rotate: function (t) {\n        return this.clone()._rotate(t);\n      },\n      rotateAround: function (t, e) {\n        return this.clone()._rotateAround(t, e);\n      },\n      matMult: function (t) {\n        return this.clone()._matMult(t);\n      },\n      unit: function () {\n        return this.clone()._unit();\n      },\n      perp: function () {\n        return this.clone()._perp();\n      },\n      round: function () {\n        return this.clone()._round();\n      },\n      mag: function () {\n        return Math.sqrt(this.x * this.x + this.y * this.y);\n      },\n      equals: function (t) {\n        return this.x === t.x && this.y === t.y;\n      },\n      dist: function (t) {\n        return Math.sqrt(this.distSqr(t));\n      },\n      distSqr: function (t) {\n        var e = t.x - this.x,\n            r = t.y - this.y;\n        return e * e + r * r;\n      },\n      angle: function () {\n        return Math.atan2(this.y, this.x);\n      },\n      angleTo: function (t) {\n        return Math.atan2(this.y - t.y, this.x - t.x);\n      },\n      angleWith: function (t) {\n        return this.angleWithSep(t.x, t.y);\n      },\n      angleWithSep: function (t, e) {\n        return Math.atan2(this.x * e - this.y * t, this.x * t + this.y * e);\n      },\n      _matMult: function (t) {\n        var e = t[2] * this.x + t[3] * this.y;\n        return this.x = t[0] * this.x + t[1] * this.y, this.y = e, this;\n      },\n      _add: function (t) {\n        return this.x += t.x, this.y += t.y, this;\n      },\n      _sub: function (t) {\n        return this.x -= t.x, this.y -= t.y, this;\n      },\n      _mult: function (t) {\n        return this.x *= t, this.y *= t, this;\n      },\n      _div: function (t) {\n        return this.x /= t, this.y /= t, this;\n      },\n      _multByPoint: function (t) {\n        return this.x *= t.x, this.y *= t.y, this;\n      },\n      _divByPoint: function (t) {\n        return this.x /= t.x, this.y /= t.y, this;\n      },\n      _unit: function () {\n        return this._div(this.mag()), this;\n      },\n      _perp: function () {\n        var t = this.y;\n        return this.y = this.x, this.x = -t, this;\n      },\n      _rotate: function (t) {\n        var e = Math.cos(t),\n            r = Math.sin(t),\n            n = r * this.x + e * this.y;\n        return this.x = e * this.x - r * this.y, this.y = n, this;\n      },\n      _rotateAround: function (t, e) {\n        var r = Math.cos(t),\n            n = Math.sin(t),\n            i = e.y + n * (this.x - e.x) + r * (this.y - e.y);\n        return this.x = e.x + r * (this.x - e.x) - n * (this.y - e.y), this.y = i, this;\n      },\n      _round: function () {\n        return this.x = Math.round(this.x), this.y = Math.round(this.y), this;\n      }\n    }, z.convert = function (t) {\n      return t instanceof z ? t : Array.isArray(t) ? new z(t[0], t[1]) : t;\n    };\n    const I = {\n      MAX_PARALLEL_IMAGE_REQUESTS: 16,\n      REGISTERED_PROTOCOLS: {}\n    },\n          M = \"mapbox-tiles\";\n    let B,\n        C,\n        P = 500,\n        V = 50;\n\n    function E() {\n      \"undefined\" == typeof caches || B || (B = caches.open(M));\n    }\n\n    let F = 1 / 0;\n    const T = {\n      supported: !1,\n      testSupport: function (t) {\n        !$ && D && (O ? R(t) : L = t);\n      }\n    };\n    let L,\n        D,\n        $ = !1,\n        O = !1;\n\n    function R(t) {\n      const e = t.createTexture();\n      t.bindTexture(t.TEXTURE_2D, e);\n\n      try {\n        if (t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, t.RGBA, t.UNSIGNED_BYTE, D), t.isContextLost()) return;\n        T.supported = !0;\n      } catch (t) {}\n\n      t.deleteTexture(e), $ = !0;\n    }\n\n    \"undefined\" != typeof document && (D = document.createElement(\"img\"), D.onload = function () {\n      L && R(L), L = null, O = !0;\n    }, D.onerror = function () {\n      $ = !0, L = null;\n    }, D.src = \"data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=\");\n    const U = {\n      Unknown: \"Unknown\",\n      Style: \"Style\",\n      Source: \"Source\",\n      Tile: \"Tile\",\n      Glyphs: \"Glyphs\",\n      SpriteImage: \"SpriteImage\",\n      SpriteJSON: \"SpriteJSON\",\n      Image: \"Image\"\n    };\n    \"function\" == typeof Object.freeze && Object.freeze(U);\n\n    class q extends Error {\n      constructor(t, e, r, n) {\n        super(`AJAXError: ${e} (${t}): ${r}`), this.status = t, this.statusText = e, this.url = r, this.body = n;\n      }\n\n    }\n\n    const j = g() ? () => self.worker && self.worker.referrer : () => (\"blob:\" === window.location.protocol ? window.parent : window).location.href;\n\n    function N(t, e) {\n      const r = new AbortController(),\n            n = new Request(t.url, {\n        method: t.method || \"GET\",\n        body: t.body,\n        credentials: t.credentials,\n        headers: t.headers,\n        referrer: j(),\n        signal: r.signal\n      });\n      let i = !1,\n          s = !1;\n      \"json\" === t.type && n.headers.set(\"Accept\", \"application/json\");\n      return ((r, a, o) => {\n        if (s) return;\n        const l = Date.now();\n        fetch(n).then(r => r.ok ? ((r, a, o) => {\n          (\"arrayBuffer\" === t.type ? r.arrayBuffer() : \"json\" === t.type ? r.json() : r.text()).then(t => {\n            s || (a && o && function (t, e, r) {\n              if (E(), !B) return;\n              const n = {\n                status: e.status,\n                statusText: e.statusText,\n                headers: new Headers()\n              };\n              e.headers.forEach((t, e) => n.headers.set(e, t));\n              const i = x(e.headers.get(\"Cache-Control\") || \"\");\n              i[\"no-store\"] || (i[\"max-age\"] && n.headers.set(\"Expires\", new Date(r + 1e3 * i[\"max-age\"]).toUTCString()), new Date(n.headers.get(\"Expires\")).getTime() - r < 42e4 || function (t, e) {\n                if (void 0 === C) try {\n                  new Response(new ReadableStream()), C = !0;\n                } catch (t) {\n                  C = !1;\n                }\n                C ? e(t.body) : t.blob().then(e);\n              }(e, e => {\n                const r = new Response(e, n);\n                E(), B && B.then(e => e.put(function (t) {\n                  const e = t.indexOf(\"?\");\n                  return e < 0 ? t : t.slice(0, e);\n                }(t.url), r)).catch(t => d(t.message));\n              }));\n            }(n, a, o), i = !0, e(null, t, r.headers.get(\"Cache-Control\"), r.headers.get(\"Expires\")));\n          }).catch(t => {\n            s || e(new Error(t.message));\n          });\n        })(r, null, l) : r.blob().then(n => e(new q(r.status, r.statusText, t.url, n)))).catch(t => {\n          20 !== t.code && e(new Error(t.message));\n        });\n      })(), {\n        cancel: () => {\n          s = !0, i || r.abort();\n        }\n      };\n    }\n\n    const K = function (t, e) {\n      if (/:\\/\\//.test(t.url) && !/^https?:|^file:/.test(t.url)) {\n        if (g() && self.worker && self.worker.actor) return self.worker.actor.send(\"getResource\", t, e);\n\n        if (!g()) {\n          const r = t.url.substring(0, t.url.indexOf(\"://\"));\n          return (I.REGISTERED_PROTOCOLS[r] || N)(t, e);\n        }\n      }\n\n      if (!(/^file:/.test(r = t.url) || /^file:/.test(j()) && !/^\\w+:/.test(r))) {\n        if (fetch && Request && AbortController && Object.prototype.hasOwnProperty.call(Request.prototype, \"signal\")) return N(t, e);\n        if (g() && self.worker && self.worker.actor) return self.worker.actor.send(\"getResource\", t, e, void 0, !0);\n      }\n\n      var r;\n      return function (t, e) {\n        const r = new XMLHttpRequest();\n        r.open(t.method || \"GET\", t.url, !0), \"arrayBuffer\" === t.type && (r.responseType = \"arraybuffer\");\n\n        for (const e in t.headers) r.setRequestHeader(e, t.headers[e]);\n\n        return \"json\" === t.type && (r.responseType = \"text\", r.setRequestHeader(\"Accept\", \"application/json\")), r.withCredentials = \"include\" === t.credentials, r.onerror = () => {\n          e(new Error(r.statusText));\n        }, r.onload = () => {\n          if ((r.status >= 200 && r.status < 300 || 0 === r.status) && null !== r.response) {\n            let n = r.response;\n            if (\"json\" === t.type) try {\n              n = JSON.parse(r.response);\n            } catch (t) {\n              return e(t);\n            }\n            e(null, n, r.getResponseHeader(\"Cache-Control\"), r.getResponseHeader(\"Expires\"));\n          } else {\n            const n = new Blob([r.response], {\n              type: r.getResponseHeader(\"Content-Type\")\n            });\n            e(new q(r.status, r.statusText, t.url, n));\n          }\n        }, r.send(t.body), {\n          cancel: () => r.abort()\n        };\n      }(t, e);\n    },\n          Z = function (t, e) {\n      return K(o(t, {\n        type: \"arrayBuffer\"\n      }), e);\n    };\n\n    function G(t) {\n      const e = window.document.createElement(\"a\");\n      return e.href = t, e.protocol === window.document.location.protocol && e.host === window.document.location.host;\n    }\n\n    const J = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=\";\n    let X, Y;\n    X = [], Y = 0;\n\n    const H = function (t, e) {\n      if (T.supported && (t.headers || (t.headers = {}), t.headers.accept = \"image/webp,*/*\"), Y >= I.MAX_PARALLEL_IMAGE_REQUESTS) {\n        const r = {\n          requestParameters: t,\n          callback: e,\n          cancelled: !1,\n\n          cancel() {\n            this.cancelled = !0;\n          }\n\n        };\n        return X.push(r), r;\n      }\n\n      Y++;\n      let r = !1;\n\n      const n = () => {\n        if (!r) for (r = !0, Y--; X.length && Y < I.MAX_PARALLEL_IMAGE_REQUESTS;) {\n          const t = X.shift(),\n                {\n            requestParameters: e,\n            callback: r,\n            cancelled: n\n          } = t;\n          n || (t.cancel = H(e, r).cancel);\n        }\n      },\n            i = Z(t, (t, r, i, s) => {\n        n(), t ? e(t) : r && function (t, e, r, n) {\n          \"function\" == typeof createImageBitmap ? function (t, e) {\n            const r = new Blob([new Uint8Array(t)], {\n              type: \"image/png\"\n            });\n            createImageBitmap(r).then(t => {\n              e(null, t);\n            }).catch(t => {\n              e(new Error(`Could not load image because of ${t.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`));\n            });\n          }(t, e) : function (t, e, r, n) {\n            const i = new Image();\n            i.onload = () => {\n              e(null, i), URL.revokeObjectURL(i.src), i.onload = null, window.requestAnimationFrame(() => {\n                i.src = J;\n              });\n            }, i.onerror = () => e(new Error(\"Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.\"));\n            const s = new Blob([new Uint8Array(t)], {\n              type: \"image/png\"\n            });\n            i.cacheControl = r, i.expires = n, i.src = t.byteLength ? URL.createObjectURL(s) : J;\n          }(t, e, r, n);\n        }(r, e, i, s);\n      });\n\n      return {\n        cancel: () => {\n          i.cancel(), n();\n        }\n      };\n    };\n\n    function W(t, e, r) {\n      r[t] && -1 !== r[t].indexOf(e) || (r[t] = r[t] || [], r[t].push(e));\n    }\n\n    function Q(t, e, r) {\n      if (r && r[t]) {\n        const n = r[t].indexOf(e);\n        -1 !== n && r[t].splice(n, 1);\n      }\n    }\n\n    class tt {\n      constructor(t) {\n        let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        o(this, e), this.type = t;\n      }\n\n    }\n\n    class et extends tt {\n      constructor(t) {\n        let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        super(\"error\", o({\n          error: t\n        }, e));\n      }\n\n    }\n\n    class rt {\n      on(t, e) {\n        return this._listeners = this._listeners || {}, W(t, e, this._listeners), this;\n      }\n\n      off(t, e) {\n        return Q(t, e, this._listeners), Q(t, e, this._oneTimeListeners), this;\n      }\n\n      once(t, e) {\n        return this._oneTimeListeners = this._oneTimeListeners || {}, W(t, e, this._oneTimeListeners), this;\n      }\n\n      fire(t, e) {\n        \"string\" == typeof t && (t = new tt(t, e || {}));\n        const r = t.type;\n\n        if (this.listens(r)) {\n          t.target = this;\n          const e = this._listeners && this._listeners[r] ? this._listeners[r].slice() : [];\n\n          for (const r of e) r.call(this, t);\n\n          const n = this._oneTimeListeners && this._oneTimeListeners[r] ? this._oneTimeListeners[r].slice() : [];\n\n          for (const e of n) Q(r, e, this._oneTimeListeners), e.call(this, t);\n\n          const i = this._eventedParent;\n          i && (o(t, \"function\" == typeof this._eventedParentData ? this._eventedParentData() : this._eventedParentData), i.fire(t));\n        } else t instanceof et && console.error(t.error);\n\n        return this;\n      }\n\n      listens(t) {\n        return this._listeners && this._listeners[t] && this._listeners[t].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t] && this._oneTimeListeners[t].length > 0 || this._eventedParent && this._eventedParent.listens(t);\n      }\n\n      setEventedParent(t, e) {\n        return this._eventedParent = t, this._eventedParentData = e, this;\n      }\n\n    }\n\n    var nt = {\n      $version: 8,\n      $root: {\n        version: {\n          required: !0,\n          type: \"enum\",\n          values: [8]\n        },\n        name: {\n          type: \"string\"\n        },\n        metadata: {\n          type: \"*\"\n        },\n        center: {\n          type: \"array\",\n          value: \"number\"\n        },\n        zoom: {\n          type: \"number\"\n        },\n        bearing: {\n          type: \"number\",\n          default: 0,\n          period: 360,\n          units: \"degrees\"\n        },\n        pitch: {\n          type: \"number\",\n          default: 0,\n          units: \"degrees\"\n        },\n        light: {\n          type: \"light\"\n        },\n        sources: {\n          required: !0,\n          type: \"sources\"\n        },\n        sprite: {\n          type: \"string\"\n        },\n        glyphs: {\n          type: \"string\"\n        },\n        transition: {\n          type: \"transition\"\n        },\n        layers: {\n          required: !0,\n          type: \"array\",\n          value: \"layer\"\n        }\n      },\n      sources: {\n        \"*\": {\n          type: \"source\"\n        }\n      },\n      source: [\"source_vector\", \"source_raster\", \"source_raster_dem\", \"source_geojson\", \"source_video\", \"source_image\"],\n      source_vector: {\n        type: {\n          required: !0,\n          type: \"enum\",\n          values: {\n            vector: {}\n          }\n        },\n        url: {\n          type: \"string\"\n        },\n        tiles: {\n          type: \"array\",\n          value: \"string\"\n        },\n        bounds: {\n          type: \"array\",\n          value: \"number\",\n          length: 4,\n          default: [-180, -85.051129, 180, 85.051129]\n        },\n        scheme: {\n          type: \"enum\",\n          values: {\n            xyz: {},\n            tms: {}\n          },\n          default: \"xyz\"\n        },\n        minzoom: {\n          type: \"number\",\n          default: 0\n        },\n        maxzoom: {\n          type: \"number\",\n          default: 22\n        },\n        attribution: {\n          type: \"string\"\n        },\n        promoteId: {\n          type: \"promoteId\"\n        },\n        volatile: {\n          type: \"boolean\",\n          default: !1\n        },\n        \"*\": {\n          type: \"*\"\n        }\n      },\n      source_raster: {\n        type: {\n          required: !0,\n          type: \"enum\",\n          values: {\n            raster: {}\n          }\n        },\n        url: {\n          type: \"string\"\n        },\n        tiles: {\n          type: \"array\",\n          value: \"string\"\n        },\n        bounds: {\n          type: \"array\",\n          value: \"number\",\n          length: 4,\n          default: [-180, -85.051129, 180, 85.051129]\n        },\n        minzoom: {\n          type: \"number\",\n          default: 0\n        },\n        maxzoom: {\n          type: \"number\",\n          default: 22\n        },\n        tileSize: {\n          type: \"number\",\n          default: 512,\n          units: \"pixels\"\n        },\n        scheme: {\n          type: \"enum\",\n          values: {\n            xyz: {},\n            tms: {}\n          },\n          default: \"xyz\"\n        },\n        attribution: {\n          type: \"string\"\n        },\n        volatile: {\n          type: \"boolean\",\n          default: !1\n        },\n        \"*\": {\n          type: \"*\"\n        }\n      },\n      source_raster_dem: {\n        type: {\n          required: !0,\n          type: \"enum\",\n          values: {\n            \"raster-dem\": {}\n          }\n        },\n        url: {\n          type: \"string\"\n        },\n        tiles: {\n          type: \"array\",\n          value: \"string\"\n        },\n        bounds: {\n          type: \"array\",\n          value: \"number\",\n          length: 4,\n          default: [-180, -85.051129, 180, 85.051129]\n        },\n        minzoom: {\n          type: \"number\",\n          default: 0\n        },\n        maxzoom: {\n          type: \"number\",\n          default: 22\n        },\n        tileSize: {\n          type: \"number\",\n          default: 512,\n          units: \"pixels\"\n        },\n        attribution: {\n          type: \"string\"\n        },\n        encoding: {\n          type: \"enum\",\n          values: {\n            terrarium: {},\n            mapbox: {}\n          },\n          default: \"mapbox\"\n        },\n        volatile: {\n          type: \"boolean\",\n          default: !1\n        },\n        \"*\": {\n          type: \"*\"\n        }\n      },\n      source_geojson: {\n        type: {\n          required: !0,\n          type: \"enum\",\n          values: {\n            geojson: {}\n          }\n        },\n        data: {\n          type: \"*\"\n        },\n        maxzoom: {\n          type: \"number\",\n          default: 18\n        },\n        attribution: {\n          type: \"string\"\n        },\n        buffer: {\n          type: \"number\",\n          default: 128,\n          maximum: 512,\n          minimum: 0\n        },\n        filter: {\n          type: \"*\"\n        },\n        tolerance: {\n          type: \"number\",\n          default: .375\n        },\n        cluster: {\n          type: \"boolean\",\n          default: !1\n        },\n        clusterRadius: {\n          type: \"number\",\n          default: 50,\n          minimum: 0\n        },\n        clusterMaxZoom: {\n          type: \"number\"\n        },\n        clusterMinPoints: {\n          type: \"number\"\n        },\n        clusterProperties: {\n          type: \"*\"\n        },\n        lineMetrics: {\n          type: \"boolean\",\n          default: !1\n        },\n        generateId: {\n          type: \"boolean\",\n          default: !1\n        },\n        promoteId: {\n          type: \"promoteId\"\n        }\n      },\n      source_video: {\n        type: {\n          required: !0,\n          type: \"enum\",\n          values: {\n            video: {}\n          }\n        },\n        urls: {\n          required: !0,\n          type: \"array\",\n          value: \"string\"\n        },\n        coordinates: {\n          required: !0,\n          type: \"array\",\n          length: 4,\n          value: {\n            type: \"array\",\n            length: 2,\n            value: \"number\"\n          }\n        }\n      },\n      source_image: {\n        type: {\n          required: !0,\n          type: \"enum\",\n          values: {\n            image: {}\n          }\n        },\n        url: {\n          required: !0,\n          type: \"string\"\n        },\n        coordinates: {\n          required: !0,\n          type: \"array\",\n          length: 4,\n          value: {\n            type: \"array\",\n            length: 2,\n            value: \"number\"\n          }\n        }\n      },\n      layer: {\n        id: {\n          type: \"string\",\n          required: !0\n        },\n        type: {\n          type: \"enum\",\n          values: {\n            fill: {},\n            line: {},\n            symbol: {},\n            circle: {},\n            heatmap: {},\n            \"fill-extrusion\": {},\n            raster: {},\n            hillshade: {},\n            background: {}\n          },\n          required: !0\n        },\n        metadata: {\n          type: \"*\"\n        },\n        source: {\n          type: \"string\"\n        },\n        \"source-layer\": {\n          type: \"string\"\n        },\n        minzoom: {\n          type: \"number\",\n          minimum: 0,\n          maximum: 24\n        },\n        maxzoom: {\n          type: \"number\",\n          minimum: 0,\n          maximum: 24\n        },\n        filter: {\n          type: \"filter\"\n        },\n        layout: {\n          type: \"layout\"\n        },\n        paint: {\n          type: \"paint\"\n        }\n      },\n      layout: [\"layout_fill\", \"layout_line\", \"layout_circle\", \"layout_heatmap\", \"layout_fill-extrusion\", \"layout_symbol\", \"layout_raster\", \"layout_hillshade\", \"layout_background\"],\n      layout_background: {\n        visibility: {\n          type: \"enum\",\n          values: {\n            visible: {},\n            none: {}\n          },\n          default: \"visible\",\n          \"property-type\": \"constant\"\n        }\n      },\n      layout_fill: {\n        \"fill-sort-key\": {\n          type: \"number\",\n          expression: {\n            interpolated: !1,\n            parameters: [\"zoom\", \"feature\"]\n          },\n          \"property-type\": \"data-driven\"\n        },\n        visibility: {\n          type: \"enum\",\n          values: {\n            visible: {},\n            none: {}\n          },\n          default: \"visible\",\n          \"property-type\": \"constant\"\n        }\n      },\n      layout_circle: {\n        \"circle-sort-key\": {\n          type: \"number\",\n          expression: {\n            interpolated: !1,\n            parameters: [\"zoom\", \"feature\"]\n          },\n          \"property-type\": \"data-driven\"\n        },\n        visibility: {\n          type: \"enum\",\n          values: {\n            visible: {},\n            none: {}\n          },\n          default: \"visible\",\n          \"property-type\": \"constant\"\n        }\n      },\n      layout_heatmap: {\n        visibility: {\n          type: \"enum\",\n          values: {\n            visible: {},\n            none: {}\n          },\n          default: \"visible\",\n          \"property-type\": \"constant\"\n        }\n      },\n      \"layout_fill-extrusion\": {\n        visibility: {\n          type: \"enum\",\n          values: {\n            visible: {},\n            none: {}\n          },\n          default: \"visible\",\n          \"property-type\": \"constant\"\n        }\n      },\n      layout_line: {\n        \"line-cap\": {\n          type: \"enum\",\n          values: {\n            butt: {},\n            round: {},\n            square: {}\n          },\n          default: \"butt\",\n          expression: {\n            interpolated: !1,\n            parameters: [\"zoom\"]\n          },\n          \"property-type\": \"data-constant\"\n        },\n        \"line-join\": {\n          type: \"enum\",\n          values: {\n            bevel: {},\n            round: {},\n            miter: {}\n          },\n          default: \"miter\",\n          expression: {\n            interpolated: !1,\n            parameters: [\"zoom\", \"feature\"]\n          },\n          \"property-type\": \"data-driven\"\n        },\n        \"line-miter-limit\": {\n          type: \"number\",\n          default: 2,\n          requires: [{\n            \"line-join\": \"miter\"\n          }],\n          expression: {\n            interpolated: !0,\n            parameters: [\"zoom\"]\n          },\n          \"property-type\": \"data-constant\"\n        },\n        \"line-round-limit\": {\n          type: \"number\",\n          default: 1.05,\n          requires: [{\n            \"line-join\": \"round\"\n          }],\n          expression: {\n            interpolated: !0,\n            parameters: [\"zoom\"]\n          },\n          \"property-type\": \"data-constant\"\n        },\n        \"line-sort-key\": {\n          type: \"number\",\n          expression: {\n            interpolated: !1,\n            parameters: [\"zoom\", \"feature\"]\n          },\n          \"property-type\": \"data-driven\"\n        },\n        visibility: {\n          type: \"enum\",\n          values: {\n            visible: {},\n            none: {}\n          },\n          default: \"visible\",\n          \"property-type\": \"constant\"\n        }\n      },\n      layout_symbol: {\n        \"symbol-placement\": {\n          type: \"enum\",\n          values: {\n            point: {},\n            line: {},\n            \"line-center\": {}\n          },\n          default: \"point\",\n          expression: {\n            interpolated: !1,\n            parameters: [\"zoom\"]\n          },\n          \"property-type\": \"data-constant\"\n        },\n        \"symbol-spacing\": {\n          type: \"number\",\n          default: 250,\n          minimum: 1,\n          units: \"pixels\",\n          requires: [{\n            \"symbol-placement\": \"line\"\n          }],\n          expression: {\n            interpolated: !0,\n            parameters: [\"zoom\"]\n          },\n          \"property-type\": \"data-constant\"\n        },\n        \"symbol-avoid-edges\": {\n          type: \"boolean\",\n          default: !1,\n          expression: {\n            interpolated: !1,\n            parameters: [\"zoom\"]\n          },\n          \"property-type\": \"data-constant\"\n        },\n        \"symbol-sort-key\": {\n          type: \"number\",\n          expression: {\n            interpolated: !1,\n            parameters: [\"zoom\", \"feature\"]\n          },\n          \"property-type\": \"data-driven\"\n        },\n        \"symbol-z-order\": {\n          type: \"enum\",\n          values: {\n            auto: {},\n            \"viewport-y\": {},\n            source: {}\n          },\n          default: \"auto\",\n          expression: {\n            interpolated: !1,\n            parameters: [\"zoom\"]\n          },\n          \"property-type\": \"data-constant\"\n        },\n        \"icon-allow-overlap\": {\n          type: \"boolean\",\n          default: !1,\n          requires: [\"icon-image\", {\n            \"!\": \"icon-overlap\"\n          }],\n          expression: {\n            interpolated: !1,\n            parameters: [\"zoom\"]\n          },\n          \"property-type\": \"data-constant\"\n        },\n        \"icon-overlap\": {\n          type: \"enum\",\n          values: {\n            never: {},\n            always: {},\n            cooperative: {}\n          },\n          requires: [\"icon-image\"],\n          expression: {\n            interpolated: !1,\n            parameters: [\"zoom\"]\n          },\n          \"property-type\": \"data-constant\"\n        },\n        \"icon-ignore-placement\": {\n          type: \"boolean\",\n          default: !1,\n          requires: [\"icon-image\"],\n          expression: {\n            interpolated: !1,\n            parameters: [\"zoom\"]\n          },\n          \"property-type\": \"data-constant\"\n        },\n        \"icon-optional\": {\n          type: \"boolean\",\n          default: !1,\n          requires: [\"icon-image\", \"text-field\"],\n          expression: {\n            interpolated: !1,\n            parameters: [\"zoom\"]\n          },\n          \"property-type\": \"data-constant\"\n        },\n        \"icon-rotation-alignment\": {\n          type: \"enum\",\n          values: {\n            map: {},\n            viewport: {},\n            auto: {}\n          },\n          default: \"auto\",\n          requires: [\"icon-image\"],\n          expression: {\n            interpolated: !1,\n            parameters: [\"zoom\"]\n          },\n          \"property-type\": \"data-constant\"\n        },\n        \"icon-size\": {\n          type: \"number\",\n          default: 1,\n          minimum: 0,\n          units: \"factor of the original icon size\",\n          requires: [\"icon-image\"],\n          expression: {\n            interpolated: !0,\n            parameters: [\"zoom\", \"feature\"]\n          },\n          \"property-type\": \"data-driven\"\n        },\n        \"icon-text-fit\": {\n          type: \"enum\",\n          values: {\n            none: {},\n            width: {},\n            height: {},\n            both: {}\n          },\n          default: \"none\",\n          requires: [\"icon-image\", \"text-field\"],\n          expression: {\n            interpolated: !1,\n            parameters: [\"zoom\"]\n          },\n          \"property-type\": \"data-constant\"\n        },\n        \"icon-text-fit-padding\": {\n          type: \"array\",\n          value: \"number\",\n          length: 4,\n          default: [0, 0, 0, 0],\n          units: \"pixels\",\n          requires: [\"icon-image\", \"text-field\", {\n            \"icon-text-fit\": [\"both\", \"width\", \"height\"]\n          }],\n          expression: {\n            interpolated: !0,\n            parameters: [\"zoom\"]\n          },\n          \"property-type\": \"data-constant\"\n        },\n        \"icon-image\": {\n          type: \"resolvedImage\",\n          tokens: !0,\n          expression: {\n            interpolated: !1,\n            parameters: [\"zoom\", \"feature\"]\n          },\n          \"property-type\": \"data-driven\"\n        },\n        \"icon-rotate\": {\n          type: \"number\",\n          default: 0,\n          period: 360,\n          units: \"degrees\",\n          requires: [\"icon-image\"],\n          expression: {\n            interpolated: !0,\n            parameters: [\"zoom\", \"feature\"]\n          },\n          \"property-type\": \"data-driven\"\n        },\n        \"icon-padding\": {\n          type: \"number\",\n          default: 2,\n          minimum: 0,\n          units: \"pixels\",\n          requires: [\"icon-image\"],\n          expression: {\n            interpolated: !0,\n            parameters: [\"zoom\"]\n          },\n          \"property-type\": \"data-constant\"\n        },\n        \"icon-keep-upright\": {\n          type: \"boolean\",\n          default: !1,\n          requires: [\"icon-image\", {\n            \"icon-rotation-alignment\": \"map\"\n          }, {\n            \"symbol-placement\": [\"line\", \"line-center\"]\n          }],\n          expression: {\n            interpolated: !1,\n            parameters: [\"zoom\"]\n          },\n          \"property-type\": \"data-constant\"\n        },\n        \"icon-offset\": {\n          type: \"array\",\n          value: \"number\",\n          length: 2,\n          default: [0, 0],\n          requires: [\"icon-image\"],\n          expression: {\n            interpolated: !0,\n            parameters: [\"zoom\", \"feature\"]\n          },\n          \"property-type\": \"data-driven\"\n        },\n        \"icon-anchor\": {\n          type: \"enum\",\n          values: {\n            center: {},\n            left: {},\n            right: {},\n            top: {},\n            bottom: {},\n            \"top-left\": {},\n            \"top-right\": {},\n            \"bottom-left\": {},\n            \"bottom-right\": {}\n          },\n          default: \"center\",\n          requires: [\"icon-image\"],\n          expression: {\n            interpolated: !1,\n            parameters: [\"zoom\", \"feature\"]\n          },\n          \"property-type\": \"data-driven\"\n        },\n        \"icon-pitch-alignment\": {\n          type: \"enum\",\n          values: {\n            map: {},\n            viewport: {},\n            auto: {}\n          },\n          default: \"auto\",\n          requires: [\"icon-image\"],\n          expression: {\n            interpolated: !1,\n            parameters: [\"zoom\"]\n          },\n          \"property-type\": \"data-constant\"\n        },\n        \"text-pitch-alignment\": {\n          type: \"enum\",\n          values: {\n            map: {},\n            viewport: {},\n            auto: {}\n          },\n          default: \"auto\",\n          requires: [\"text-field\"],\n          expression: {\n            interpolated: !1,\n            parameters: [\"zoom\"]\n          },\n          \"property-type\": \"data-constant\"\n        },\n        \"text-rotation-alignment\": {\n          type: \"enum\",\n          values: {\n            map: {},\n            viewport: {},\n            auto: {}\n          },\n          default: \"auto\",\n          requires: [\"text-field\"],\n          expression: {\n            interpolated: !1,\n            parameters: [\"zoom\"]\n          },\n          \"property-type\": \"data-constant\"\n        },\n        \"text-field\": {\n          type: \"formatted\",\n          default: \"\",\n          tokens: !0,\n          expression: {\n            interpolated: !1,\n            parameters: [\"zoom\", \"feature\"]\n          },\n          \"property-type\": \"data-driven\"\n        },\n        \"text-font\": {\n          type: \"array\",\n          value: \"string\",\n          default: [\"Open Sans Regular\", \"Arial Unicode MS Regular\"],\n          requires: [\"text-field\"],\n          expression: {\n            interpolated: !1,\n            parameters: [\"zoom\", \"feature\"]\n          },\n          \"property-type\": \"data-driven\"\n        },\n        \"text-size\": {\n          type: \"number\",\n          default: 16,\n          minimum: 0,\n          units: \"pixels\",\n          requires: [\"text-field\"],\n          expression: {\n            interpolated: !0,\n            parameters: [\"zoom\", \"feature\"]\n          },\n          \"property-type\": \"data-driven\"\n        },\n        \"text-max-width\": {\n          type: \"number\",\n          default: 10,\n          minimum: 0,\n          units: \"ems\",\n          requires: [\"text-field\"],\n          expression: {\n            interpolated: !0,\n            parameters: [\"zoom\", \"feature\"]\n          },\n          \"property-type\": \"data-driven\"\n        },\n        \"text-line-height\": {\n          type: \"number\",\n          default: 1.2,\n          units: \"ems\",\n          requires: [\"text-field\"],\n          expression: {\n            interpolated: !0,\n            parameters: [\"zoom\"]\n          },\n          \"property-type\": \"data-constant\"\n        },\n        \"text-letter-spacing\": {\n          type: \"number\",\n          default: 0,\n          units: \"ems\",\n          requires: [\"text-field\"],\n          expression: {\n            interpolated: !0,\n            parameters: [\"zoom\", \"feature\"]\n          },\n          \"property-type\": \"data-driven\"\n        },\n        \"text-justify\": {\n          type: \"enum\",\n          values: {\n            auto: {},\n            left: {},\n            center: {},\n            right: {}\n          },\n          default: \"center\",\n          requires: [\"text-field\"],\n          expression: {\n            interpolated: !1,\n            parameters: [\"zoom\", \"feature\"]\n          },\n          \"property-type\": \"data-driven\"\n        },\n        \"text-radial-offset\": {\n          type: \"number\",\n          units: \"ems\",\n          default: 0,\n          requires: [\"text-field\"],\n          \"property-type\": \"data-driven\",\n          expression: {\n            interpolated: !0,\n            parameters: [\"zoom\", \"feature\"]\n          }\n        },\n        \"text-variable-anchor\": {\n          type: \"array\",\n          value: \"enum\",\n          values: {\n            center: {},\n            left: {},\n            right: {},\n            top: {},\n            bottom: {},\n            \"top-left\": {},\n            \"top-right\": {},\n            \"bottom-left\": {},\n            \"bottom-right\": {}\n          },\n          requires: [\"text-field\", {\n            \"symbol-placement\": [\"point\"]\n          }],\n          expression: {\n            interpolated: !1,\n            parameters: [\"zoom\"]\n          },\n          \"property-type\": \"data-constant\"\n        },\n        \"text-anchor\": {\n          type: \"enum\",\n          values: {\n            center: {},\n            left: {},\n            right: {},\n            top: {},\n            bottom: {},\n            \"top-left\": {},\n            \"top-right\": {},\n            \"bottom-left\": {},\n            \"bottom-right\": {}\n          },\n          default: \"center\",\n          requires: [\"text-field\", {\n            \"!\": \"text-variable-anchor\"\n          }],\n          expression: {\n            interpolated: !1,\n            parameters: [\"zoom\", \"feature\"]\n          },\n          \"property-type\": \"data-driven\"\n        },\n        \"text-max-angle\": {\n          type: \"number\",\n          default: 45,\n          units: \"degrees\",\n          requires: [\"text-field\", {\n            \"symbol-placement\": [\"line\", \"line-center\"]\n          }],\n          expression: {\n            interpolated: !0,\n            parameters: [\"zoom\"]\n          },\n          \"property-type\": \"data-constant\"\n        },\n        \"text-writing-mode\": {\n          type: \"array\",\n          value: \"enum\",\n          values: {\n            horizontal: {},\n            vertical: {}\n          },\n          requires: [\"text-field\", {\n            \"symbol-placement\": [\"point\"]\n          }],\n          expression: {\n            interpolated: !1,\n            parameters: [\"zoom\"]\n          },\n          \"property-type\": \"data-constant\"\n        },\n        \"text-rotate\": {\n          type: \"number\",\n          default: 0,\n          period: 360,\n          units: \"degrees\",\n          requires: [\"text-field\"],\n          expression: {\n            interpolated: !0,\n            parameters: [\"zoom\", \"feature\"]\n          },\n          \"property-type\": \"data-driven\"\n        },\n        \"text-padding\": {\n          type: \"number\",\n          default: 2,\n          minimum: 0,\n          units: \"pixels\",\n          requires: [\"text-field\"],\n          expression: {\n            interpolated: !0,\n            parameters: [\"zoom\"]\n          },\n          \"property-type\": \"data-constant\"\n        },\n        \"text-keep-upright\": {\n          type: \"boolean\",\n          default: !0,\n          requires: [\"text-field\", {\n            \"text-rotation-alignment\": \"map\"\n          }, {\n            \"symbol-placement\": [\"line\", \"line-center\"]\n          }],\n          expression: {\n            interpolated: !1,\n            parameters: [\"zoom\"]\n          },\n          \"property-type\": \"data-constant\"\n        },\n        \"text-transform\": {\n          type: \"enum\",\n          values: {\n            none: {},\n            uppercase: {},\n            lowercase: {}\n          },\n          default: \"none\",\n          requires: [\"text-field\"],\n          expression: {\n            interpolated: !1,\n            parameters: [\"zoom\", \"feature\"]\n          },\n          \"property-type\": \"data-driven\"\n        },\n        \"text-offset\": {\n          type: \"array\",\n          value: \"number\",\n          units: \"ems\",\n          length: 2,\n          default: [0, 0],\n          requires: [\"text-field\", {\n            \"!\": \"text-radial-offset\"\n          }],\n          expression: {\n            interpolated: !0,\n            parameters: [\"zoom\", \"feature\"]\n          },\n          \"property-type\": \"data-driven\"\n        },\n        \"text-allow-overlap\": {\n          type: \"boolean\",\n          default: !1,\n          requires: [\"text-field\", {\n            \"!\": \"text-overlap\"\n          }],\n          expression: {\n            interpolated: !1,\n            parameters: [\"zoom\"]\n          },\n          \"property-type\": \"data-constant\"\n        },\n        \"text-overlap\": {\n          type: \"enum\",\n          values: {\n            never: {},\n            always: {},\n            cooperative: {}\n          },\n          requires: [\"text-field\"],\n          expression: {\n            interpolated: !1,\n            parameters: [\"zoom\"]\n          },\n          \"property-type\": \"data-constant\"\n        },\n        \"text-ignore-placement\": {\n          type: \"boolean\",\n          default: !1,\n          requires: [\"text-field\"],\n          expression: {\n            interpolated: !1,\n            parameters: [\"zoom\"]\n          },\n          \"property-type\": \"data-constant\"\n        },\n        \"text-optional\": {\n          type: \"boolean\",\n          default: !1,\n          requires: [\"text-field\", \"icon-image\"],\n          expression: {\n            interpolated: !1,\n            parameters: [\"zoom\"]\n          },\n          \"property-type\": \"data-constant\"\n        },\n        visibility: {\n          type: \"enum\",\n          values: {\n            visible: {},\n            none: {}\n          },\n          default: \"visible\",\n          \"property-type\": \"constant\"\n        }\n      },\n      layout_raster: {\n        visibility: {\n          type: \"enum\",\n          values: {\n            visible: {},\n            none: {}\n          },\n          default: \"visible\",\n          \"property-type\": \"constant\"\n        }\n      },\n      layout_hillshade: {\n        visibility: {\n          type: \"enum\",\n          values: {\n            visible: {},\n            none: {}\n          },\n          default: \"visible\",\n          \"property-type\": \"constant\"\n        }\n      },\n      filter: {\n        type: \"array\",\n        value: \"*\"\n      },\n      filter_operator: {\n        type: \"enum\",\n        values: {\n          \"==\": {},\n          \"!=\": {},\n          \">\": {},\n          \">=\": {},\n          \"<\": {},\n          \"<=\": {},\n          in: {},\n          \"!in\": {},\n          all: {},\n          any: {},\n          none: {},\n          has: {},\n          \"!has\": {},\n          within: {}\n        }\n      },\n      geometry_type: {\n        type: \"enum\",\n        values: {\n          Point: {},\n          LineString: {},\n          Polygon: {}\n        }\n      },\n      function: {\n        expression: {\n          type: \"expression\"\n        },\n        stops: {\n          type: \"array\",\n          value: \"function_stop\"\n        },\n        base: {\n          type: \"number\",\n          default: 1,\n          minimum: 0\n        },\n        property: {\n          type: \"string\",\n          default: \"$zoom\"\n        },\n        type: {\n          type: \"enum\",\n          values: {\n            identity: {},\n            exponential: {},\n            interval: {},\n            categorical: {}\n          },\n          default: \"exponential\"\n        },\n        colorSpace: {\n          type: \"enum\",\n          values: {\n            rgb: {},\n            lab: {},\n            hcl: {}\n          },\n          default: \"rgb\"\n        },\n        default: {\n          type: \"*\",\n          required: !1\n        }\n      },\n      function_stop: {\n        type: \"array\",\n        minimum: 0,\n        maximum: 24,\n        value: [\"number\", \"color\"],\n        length: 2\n      },\n      expression: {\n        type: \"array\",\n        value: \"*\",\n        minimum: 1\n      },\n      light: {\n        anchor: {\n          type: \"enum\",\n          default: \"viewport\",\n          values: {\n            map: {},\n            viewport: {}\n          },\n          \"property-type\": \"data-constant\",\n          transition: !1,\n          expression: {\n            interpolated: !1,\n            parameters: [\"zoom\"]\n          }\n        },\n        position: {\n          type: \"array\",\n          default: [1.15, 210, 30],\n          length: 3,\n          value: \"number\",\n          \"property-type\": \"data-constant\",\n          transition: !0,\n          expression: {\n            interpolated: !0,\n            parameters: [\"zoom\"]\n          }\n        },\n        color: {\n          type: \"color\",\n          \"property-type\": \"data-constant\",\n          default: \"#ffffff\",\n          expression: {\n            interpolated: !0,\n            parameters: [\"zoom\"]\n          },\n          transition: !0\n        },\n        intensity: {\n          type: \"number\",\n          \"property-type\": \"data-constant\",\n          default: .5,\n          minimum: 0,\n          maximum: 1,\n          expression: {\n            interpolated: !0,\n            parameters: [\"zoom\"]\n          },\n          transition: !0\n        }\n      },\n      paint: [\"paint_fill\", \"paint_line\", \"paint_circle\", \"paint_heatmap\", \"paint_fill-extrusion\", \"paint_symbol\", \"paint_raster\", \"paint_hillshade\", \"paint_background\"],\n      paint_fill: {\n        \"fill-antialias\": {\n          type: \"boolean\",\n          default: !0,\n          expression: {\n            interpolated: !1,\n            parameters: [\"zoom\"]\n          },\n          \"property-type\": \"data-constant\"\n        },\n        \"fill-opacity\": {\n          type: \"number\",\n          default: 1,\n          minimum: 0,\n          maximum: 1,\n          transition: !0,\n          expression: {\n            interpolated: !0,\n            parameters: [\"zoom\", \"feature\", \"feature-state\"]\n          },\n          \"property-type\": \"data-driven\"\n        },\n        \"fill-color\": {\n          type: \"color\",\n          default: \"#000000\",\n          transition: !0,\n          requires: [{\n            \"!\": \"fill-pattern\"\n          }],\n          expression: {\n            interpolated: !0,\n            parameters: [\"zoom\", \"feature\", \"feature-state\"]\n          },\n          \"property-type\": \"data-driven\"\n        },\n        \"fill-outline-color\": {\n          type: \"color\",\n          transition: !0,\n          requires: [{\n            \"!\": \"fill-pattern\"\n          }, {\n            \"fill-antialias\": !0\n          }],\n          expression: {\n            interpolated: !0,\n            parameters: [\"zoom\", \"feature\", \"feature-state\"]\n          },\n          \"property-type\": \"data-driven\"\n        },\n        \"fill-translate\": {\n          type: \"array\",\n          value: \"number\",\n          length: 2,\n          default: [0, 0],\n          transition: !0,\n          units: \"pixels\",\n          expression: {\n            interpolated: !0,\n            parameters: [\"zoom\"]\n          },\n          \"property-type\": \"data-constant\"\n        },\n        \"fill-translate-anchor\": {\n          type: \"enum\",\n          values: {\n            map: {},\n            viewport: {}\n          },\n          default: \"map\",\n          requires: [\"fill-translate\"],\n          expression: {\n            interpolated: !1,\n            parameters: [\"zoom\"]\n          },\n          \"property-type\": \"data-constant\"\n        },\n        \"fill-pattern\": {\n          type: \"resolvedImage\",\n          transition: !0,\n          expression: {\n            interpolated: !1,\n            parameters: [\"zoom\", \"feature\"]\n          },\n          \"property-type\": \"cross-faded-data-driven\"\n        }\n      },\n      \"paint_fill-extrusion\": {\n        \"fill-extrusion-opacity\": {\n          type: \"number\",\n          default: 1,\n          minimum: 0,\n          maximum: 1,\n          transition: !0,\n          expression: {\n            interpolated: !0,\n            parameters: [\"zoom\"]\n          },\n          \"property-type\": \"data-constant\"\n        },\n        \"fill-extrusion-color\": {\n          type: \"color\",\n          default: \"#000000\",\n          transition: !0,\n          requires: [{\n            \"!\": \"fill-extrusion-pattern\"\n          }],\n          expression: {\n            interpolated: !0,\n            parameters: [\"zoom\", \"feature\", \"feature-state\"]\n          },\n          \"property-type\": \"data-driven\"\n        },\n        \"fill-extrusion-translate\": {\n          type: \"array\",\n          value: \"number\",\n          length: 2,\n          default: [0, 0],\n          transition: !0,\n          units: \"pixels\",\n          expression: {\n            interpolated: !0,\n            parameters: [\"zoom\"]\n          },\n          \"property-type\": \"data-constant\"\n        },\n        \"fill-extrusion-translate-anchor\": {\n          type: \"enum\",\n          values: {\n            map: {},\n            viewport: {}\n          },\n          default: \"map\",\n          requires: [\"fill-extrusion-translate\"],\n          expression: {\n            interpolated: !1,\n            parameters: [\"zoom\"]\n          },\n          \"property-type\": \"data-constant\"\n        },\n        \"fill-extrusion-pattern\": {\n          type: \"resolvedImage\",\n          transition: !0,\n          expression: {\n            interpolated: !1,\n            parameters: [\"zoom\", \"feature\"]\n          },\n          \"property-type\": \"cross-faded-data-driven\"\n        },\n        \"fill-extrusion-height\": {\n          type: \"number\",\n          default: 0,\n          minimum: 0,\n          units: \"meters\",\n          transition: !0,\n          expression: {\n            interpolated: !0,\n            parameters: [\"zoom\", \"feature\", \"feature-state\"]\n          },\n          \"property-type\": \"data-driven\"\n        },\n        \"fill-extrusion-base\": {\n          type: \"number\",\n          default: 0,\n          minimum: 0,\n          units: \"meters\",\n          transition: !0,\n          requires: [\"fill-extrusion-height\"],\n          expression: {\n            interpolated: !0,\n            parameters: [\"zoom\", \"feature\", \"feature-state\"]\n          },\n          \"property-type\": \"data-driven\"\n        },\n        \"fill-extrusion-vertical-gradient\": {\n          type: \"boolean\",\n          default: !0,\n          transition: !1,\n          expression: {\n            interpolated: !1,\n            parameters: [\"zoom\"]\n          },\n          \"property-type\": \"data-constant\"\n        }\n      },\n      paint_line: {\n        \"line-opacity\": {\n          type: \"number\",\n          default: 1,\n          minimum: 0,\n          maximum: 1,\n          transition: !0,\n          expression: {\n            interpolated: !0,\n            parameters: [\"zoom\", \"feature\", \"feature-state\"]\n          },\n          \"property-type\": \"data-driven\"\n        },\n        \"line-color\": {\n          type: \"color\",\n          default: \"#000000\",\n          transition: !0,\n          requires: [{\n            \"!\": \"line-pattern\"\n          }],\n          expression: {\n            interpolated: !0,\n            parameters: [\"zoom\", \"feature\", \"feature-state\"]\n          },\n          \"property-type\": \"data-driven\"\n        },\n        \"line-translate\": {\n          type: \"array\",\n          value: \"number\",\n          length: 2,\n          default: [0, 0],\n          transition: !0,\n          units: \"pixels\",\n          expression: {\n            interpolated: !0,\n            parameters: [\"zoom\"]\n          },\n          \"property-type\": \"data-constant\"\n        },\n        \"line-translate-anchor\": {\n          type: \"enum\",\n          values: {\n            map: {},\n            viewport: {}\n          },\n          default: \"map\",\n          requires: [\"line-translate\"],\n          expression: {\n            interpolated: !1,\n            parameters: [\"zoom\"]\n          },\n          \"property-type\": \"data-constant\"\n        },\n        \"line-width\": {\n          type: \"number\",\n          default: 1,\n          minimum: 0,\n          transition: !0,\n          units: \"pixels\",\n          expression: {\n            interpolated: !0,\n            parameters: [\"zoom\", \"feature\", \"feature-state\"]\n          },\n          \"property-type\": \"data-driven\"\n        },\n        \"line-gap-width\": {\n          type: \"number\",\n          default: 0,\n          minimum: 0,\n          transition: !0,\n          units: \"pixels\",\n          expression: {\n            interpolated: !0,\n            parameters: [\"zoom\", \"feature\", \"feature-state\"]\n          },\n          \"property-type\": \"data-driven\"\n        },\n        \"line-offset\": {\n          type: \"number\",\n          default: 0,\n          transition: !0,\n          units: \"pixels\",\n          expression: {\n            interpolated: !0,\n            parameters: [\"zoom\", \"feature\", \"feature-state\"]\n          },\n          \"property-type\": \"data-driven\"\n        },\n        \"line-blur\": {\n          type: \"number\",\n          default: 0,\n          minimum: 0,\n          transition: !0,\n          units: \"pixels\",\n          expression: {\n            interpolated: !0,\n            parameters: [\"zoom\", \"feature\", \"feature-state\"]\n          },\n          \"property-type\": \"data-driven\"\n        },\n        \"line-dasharray\": {\n          type: \"array\",\n          value: \"number\",\n          minimum: 0,\n          transition: !0,\n          units: \"line widths\",\n          requires: [{\n            \"!\": \"line-pattern\"\n          }],\n          expression: {\n            interpolated: !1,\n            parameters: [\"zoom\"]\n          },\n          \"property-type\": \"cross-faded\"\n        },\n        \"line-pattern\": {\n          type: \"resolvedImage\",\n          transition: !0,\n          expression: {\n            interpolated: !1,\n            parameters: [\"zoom\", \"feature\"]\n          },\n          \"property-type\": \"cross-faded-data-driven\"\n        },\n        \"line-gradient\": {\n          type: \"color\",\n          transition: !1,\n          requires: [{\n            \"!\": \"line-dasharray\"\n          }, {\n            \"!\": \"line-pattern\"\n          }, {\n            source: \"geojson\",\n            has: {\n              lineMetrics: !0\n            }\n          }],\n          expression: {\n            interpolated: !0,\n            parameters: [\"line-progress\"]\n          },\n          \"property-type\": \"color-ramp\"\n        }\n      },\n      paint_circle: {\n        \"circle-radius\": {\n          type: \"number\",\n          default: 5,\n          minimum: 0,\n          transition: !0,\n          units: \"pixels\",\n          expression: {\n            interpolated: !0,\n            parameters: [\"zoom\", \"feature\", \"feature-state\"]\n          },\n          \"property-type\": \"data-driven\"\n        },\n        \"circle-color\": {\n          type: \"color\",\n          default: \"#000000\",\n          transition: !0,\n          expression: {\n            interpolated: !0,\n            parameters: [\"zoom\", \"feature\", \"feature-state\"]\n          },\n          \"property-type\": \"data-driven\"\n        },\n        \"circle-blur\": {\n          type: \"number\",\n          default: 0,\n          transition: !0,\n          expression: {\n            interpolated: !0,\n            parameters: [\"zoom\", \"feature\", \"feature-state\"]\n          },\n          \"property-type\": \"data-driven\"\n        },\n        \"circle-opacity\": {\n          type: \"number\",\n          default: 1,\n          minimum: 0,\n          maximum: 1,\n          transition: !0,\n          expression: {\n            interpolated: !0,\n            parameters: [\"zoom\", \"feature\", \"feature-state\"]\n          },\n          \"property-type\": \"data-driven\"\n        },\n        \"circle-translate\": {\n          type: \"array\",\n          value: \"number\",\n          length: 2,\n          default: [0, 0],\n          transition: !0,\n          units: \"pixels\",\n          expression: {\n            interpolated: !0,\n            parameters: [\"zoom\"]\n          },\n          \"property-type\": \"data-constant\"\n        },\n        \"circle-translate-anchor\": {\n          type: \"enum\",\n          values: {\n            map: {},\n            viewport: {}\n          },\n          default: \"map\",\n          requires: [\"circle-translate\"],\n          expression: {\n            interpolated: !1,\n            parameters: [\"zoom\"]\n          },\n          \"property-type\": \"data-constant\"\n        },\n        \"circle-pitch-scale\": {\n          type: \"enum\",\n          values: {\n            map: {},\n            viewport: {}\n          },\n          default: \"map\",\n          expression: {\n            interpolated: !1,\n            parameters: [\"zoom\"]\n          },\n          \"property-type\": \"data-constant\"\n        },\n        \"circle-pitch-alignment\": {\n          type: \"enum\",\n          values: {\n            map: {},\n            viewport: {}\n          },\n          default: \"viewport\",\n          expression: {\n            interpolated: !1,\n            parameters: [\"zoom\"]\n          },\n          \"property-type\": \"data-constant\"\n        },\n        \"circle-stroke-width\": {\n          type: \"number\",\n          default: 0,\n          minimum: 0,\n          transition: !0,\n          units: \"pixels\",\n          expression: {\n            interpolated: !0,\n            parameters: [\"zoom\", \"feature\", \"feature-state\"]\n          },\n          \"property-type\": \"data-driven\"\n        },\n        \"circle-stroke-color\": {\n          type: \"color\",\n          default: \"#000000\",\n          transition: !0,\n          expression: {\n            interpolated: !0,\n            parameters: [\"zoom\", \"feature\", \"feature-state\"]\n          },\n          \"property-type\": \"data-driven\"\n        },\n        \"circle-stroke-opacity\": {\n          type: \"number\",\n          default: 1,\n          minimum: 0,\n          maximum: 1,\n          transition: !0,\n          expression: {\n            interpolated: !0,\n            parameters: [\"zoom\", \"feature\", \"feature-state\"]\n          },\n          \"property-type\": \"data-driven\"\n        }\n      },\n      paint_heatmap: {\n        \"heatmap-radius\": {\n          type: \"number\",\n          default: 30,\n          minimum: 1,\n          transition: !0,\n          units: \"pixels\",\n          expression: {\n            interpolated: !0,\n            parameters: [\"zoom\", \"feature\", \"feature-state\"]\n          },\n          \"property-type\": \"data-driven\"\n        },\n        \"heatmap-weight\": {\n          type: \"number\",\n          default: 1,\n          minimum: 0,\n          transition: !1,\n          expression: {\n            interpolated: !0,\n            parameters: [\"zoom\", \"feature\", \"feature-state\"]\n          },\n          \"property-type\": \"data-driven\"\n        },\n        \"heatmap-intensity\": {\n          type: \"number\",\n          default: 1,\n          minimum: 0,\n          transition: !0,\n          expression: {\n            interpolated: !0,\n            parameters: [\"zoom\"]\n          },\n          \"property-type\": \"data-constant\"\n        },\n        \"heatmap-color\": {\n          type: \"color\",\n          default: [\"interpolate\", [\"linear\"], [\"heatmap-density\"], 0, \"rgba(0, 0, 255, 0)\", .1, \"royalblue\", .3, \"cyan\", .5, \"lime\", .7, \"yellow\", 1, \"red\"],\n          transition: !1,\n          expression: {\n            interpolated: !0,\n            parameters: [\"heatmap-density\"]\n          },\n          \"property-type\": \"color-ramp\"\n        },\n        \"heatmap-opacity\": {\n          type: \"number\",\n          default: 1,\n          minimum: 0,\n          maximum: 1,\n          transition: !0,\n          expression: {\n            interpolated: !0,\n            parameters: [\"zoom\"]\n          },\n          \"property-type\": \"data-constant\"\n        }\n      },\n      paint_symbol: {\n        \"icon-opacity\": {\n          type: \"number\",\n          default: 1,\n          minimum: 0,\n          maximum: 1,\n          transition: !0,\n          requires: [\"icon-image\"],\n          expression: {\n            interpolated: !0,\n            parameters: [\"zoom\", \"feature\", \"feature-state\"]\n          },\n          \"property-type\": \"data-driven\"\n        },\n        \"icon-color\": {\n          type: \"color\",\n          default: \"#000000\",\n          transition: !0,\n          requires: [\"icon-image\"],\n          expression: {\n            interpolated: !0,\n            parameters: [\"zoom\", \"feature\", \"feature-state\"]\n          },\n          \"property-type\": \"data-driven\"\n        },\n        \"icon-halo-color\": {\n          type: \"color\",\n          default: \"rgba(0, 0, 0, 0)\",\n          transition: !0,\n          requires: [\"icon-image\"],\n          expression: {\n            interpolated: !0,\n            parameters: [\"zoom\", \"feature\", \"feature-state\"]\n          },\n          \"property-type\": \"data-driven\"\n        },\n        \"icon-halo-width\": {\n          type: \"number\",\n          default: 0,\n          minimum: 0,\n          transition: !0,\n          units: \"pixels\",\n          requires: [\"icon-image\"],\n          expression: {\n            interpolated: !0,\n            parameters: [\"zoom\", \"feature\", \"feature-state\"]\n          },\n          \"property-type\": \"data-driven\"\n        },\n        \"icon-halo-blur\": {\n          type: \"number\",\n          default: 0,\n          minimum: 0,\n          transition: !0,\n          units: \"pixels\",\n          requires: [\"icon-image\"],\n          expression: {\n            interpolated: !0,\n            parameters: [\"zoom\", \"feature\", \"feature-state\"]\n          },\n          \"property-type\": \"data-driven\"\n        },\n        \"icon-translate\": {\n          type: \"array\",\n          value: \"number\",\n          length: 2,\n          default: [0, 0],\n          transition: !0,\n          units: \"pixels\",\n          requires: [\"icon-image\"],\n          expression: {\n            interpolated: !0,\n            parameters: [\"zoom\"]\n          },\n          \"property-type\": \"data-constant\"\n        },\n        \"icon-translate-anchor\": {\n          type: \"enum\",\n          values: {\n            map: {},\n            viewport: {}\n          },\n          default: \"map\",\n          requires: [\"icon-image\", \"icon-translate\"],\n          expression: {\n            interpolated: !1,\n            parameters: [\"zoom\"]\n          },\n          \"property-type\": \"data-constant\"\n        },\n        \"text-opacity\": {\n          type: \"number\",\n          default: 1,\n          minimum: 0,\n          maximum: 1,\n          transition: !0,\n          requires: [\"text-field\"],\n          expression: {\n            interpolated: !0,\n            parameters: [\"zoom\", \"feature\", \"feature-state\"]\n          },\n          \"property-type\": \"data-driven\"\n        },\n        \"text-color\": {\n          type: \"color\",\n          default: \"#000000\",\n          transition: !0,\n          overridable: !0,\n          requires: [\"text-field\"],\n          expression: {\n            interpolated: !0,\n            parameters: [\"zoom\", \"feature\", \"feature-state\"]\n          },\n          \"property-type\": \"data-driven\"\n        },\n        \"text-halo-color\": {\n          type: \"color\",\n          default: \"rgba(0, 0, 0, 0)\",\n          transition: !0,\n          requires: [\"text-field\"],\n          expression: {\n            interpolated: !0,\n            parameters: [\"zoom\", \"feature\", \"feature-state\"]\n          },\n          \"property-type\": \"data-driven\"\n        },\n        \"text-halo-width\": {\n          type: \"number\",\n          default: 0,\n          minimum: 0,\n          transition: !0,\n          units: \"pixels\",\n          requires: [\"text-field\"],\n          expression: {\n            interpolated: !0,\n            parameters: [\"zoom\", \"feature\", \"feature-state\"]\n          },\n          \"property-type\": \"data-driven\"\n        },\n        \"text-halo-blur\": {\n          type: \"number\",\n          default: 0,\n          minimum: 0,\n          transition: !0,\n          units: \"pixels\",\n          requires: [\"text-field\"],\n          expression: {\n            interpolated: !0,\n            parameters: [\"zoom\", \"feature\", \"feature-state\"]\n          },\n          \"property-type\": \"data-driven\"\n        },\n        \"text-translate\": {\n          type: \"array\",\n          value: \"number\",\n          length: 2,\n          default: [0, 0],\n          transition: !0,\n          units: \"pixels\",\n          requires: [\"text-field\"],\n          expression: {\n            interpolated: !0,\n            parameters: [\"zoom\"]\n          },\n          \"property-type\": \"data-constant\"\n        },\n        \"text-translate-anchor\": {\n          type: \"enum\",\n          values: {\n            map: {},\n            viewport: {}\n          },\n          default: \"map\",\n          requires: [\"text-field\", \"text-translate\"],\n          expression: {\n            interpolated: !1,\n            parameters: [\"zoom\"]\n          },\n          \"property-type\": \"data-constant\"\n        }\n      },\n      paint_raster: {\n        \"raster-opacity\": {\n          type: \"number\",\n          default: 1,\n          minimum: 0,\n          maximum: 1,\n          transition: !0,\n          expression: {\n            interpolated: !0,\n            parameters: [\"zoom\"]\n          },\n          \"property-type\": \"data-constant\"\n        },\n        \"raster-hue-rotate\": {\n          type: \"number\",\n          default: 0,\n          period: 360,\n          transition: !0,\n          units: \"degrees\",\n          expression: {\n            interpolated: !0,\n            parameters: [\"zoom\"]\n          },\n          \"property-type\": \"data-constant\"\n        },\n        \"raster-brightness-min\": {\n          type: \"number\",\n          default: 0,\n          minimum: 0,\n          maximum: 1,\n          transition: !0,\n          expression: {\n            interpolated: !0,\n            parameters: [\"zoom\"]\n          },\n          \"property-type\": \"data-constant\"\n        },\n        \"raster-brightness-max\": {\n          type: \"number\",\n          default: 1,\n          minimum: 0,\n          maximum: 1,\n          transition: !0,\n          expression: {\n            interpolated: !0,\n            parameters: [\"zoom\"]\n          },\n          \"property-type\": \"data-constant\"\n        },\n        \"raster-saturation\": {\n          type: \"number\",\n          default: 0,\n          minimum: -1,\n          maximum: 1,\n          transition: !0,\n          expression: {\n            interpolated: !0,\n            parameters: [\"zoom\"]\n          },\n          \"property-type\": \"data-constant\"\n        },\n        \"raster-contrast\": {\n          type: \"number\",\n          default: 0,\n          minimum: -1,\n          maximum: 1,\n          transition: !0,\n          expression: {\n            interpolated: !0,\n            parameters: [\"zoom\"]\n          },\n          \"property-type\": \"data-constant\"\n        },\n        \"raster-resampling\": {\n          type: \"enum\",\n          values: {\n            linear: {},\n            nearest: {}\n          },\n          default: \"linear\",\n          expression: {\n            interpolated: !1,\n            parameters: [\"zoom\"]\n          },\n          \"property-type\": \"data-constant\"\n        },\n        \"raster-fade-duration\": {\n          type: \"number\",\n          default: 300,\n          minimum: 0,\n          transition: !1,\n          units: \"milliseconds\",\n          expression: {\n            interpolated: !0,\n            parameters: [\"zoom\"]\n          },\n          \"property-type\": \"data-constant\"\n        }\n      },\n      paint_hillshade: {\n        \"hillshade-illumination-direction\": {\n          type: \"number\",\n          default: 335,\n          minimum: 0,\n          maximum: 359,\n          transition: !1,\n          expression: {\n            interpolated: !0,\n            parameters: [\"zoom\"]\n          },\n          \"property-type\": \"data-constant\"\n        },\n        \"hillshade-illumination-anchor\": {\n          type: \"enum\",\n          values: {\n            map: {},\n            viewport: {}\n          },\n          default: \"viewport\",\n          expression: {\n            interpolated: !1,\n            parameters: [\"zoom\"]\n          },\n          \"property-type\": \"data-constant\"\n        },\n        \"hillshade-exaggeration\": {\n          type: \"number\",\n          default: .5,\n          minimum: 0,\n          maximum: 1,\n          transition: !0,\n          expression: {\n            interpolated: !0,\n            parameters: [\"zoom\"]\n          },\n          \"property-type\": \"data-constant\"\n        },\n        \"hillshade-shadow-color\": {\n          type: \"color\",\n          default: \"#000000\",\n          transition: !0,\n          expression: {\n            interpolated: !0,\n            parameters: [\"zoom\"]\n          },\n          \"property-type\": \"data-constant\"\n        },\n        \"hillshade-highlight-color\": {\n          type: \"color\",\n          default: \"#FFFFFF\",\n          transition: !0,\n          expression: {\n            interpolated: !0,\n            parameters: [\"zoom\"]\n          },\n          \"property-type\": \"data-constant\"\n        },\n        \"hillshade-accent-color\": {\n          type: \"color\",\n          default: \"#000000\",\n          transition: !0,\n          expression: {\n            interpolated: !0,\n            parameters: [\"zoom\"]\n          },\n          \"property-type\": \"data-constant\"\n        }\n      },\n      paint_background: {\n        \"background-color\": {\n          type: \"color\",\n          default: \"#000000\",\n          transition: !0,\n          requires: [{\n            \"!\": \"background-pattern\"\n          }],\n          expression: {\n            interpolated: !0,\n            parameters: [\"zoom\"]\n          },\n          \"property-type\": \"data-constant\"\n        },\n        \"background-pattern\": {\n          type: \"resolvedImage\",\n          transition: !0,\n          expression: {\n            interpolated: !1,\n            parameters: [\"zoom\"]\n          },\n          \"property-type\": \"cross-faded\"\n        },\n        \"background-opacity\": {\n          type: \"number\",\n          default: 1,\n          minimum: 0,\n          maximum: 1,\n          transition: !0,\n          expression: {\n            interpolated: !0,\n            parameters: [\"zoom\"]\n          },\n          \"property-type\": \"data-constant\"\n        }\n      },\n      transition: {\n        duration: {\n          type: \"number\",\n          default: 300,\n          minimum: 0,\n          units: \"milliseconds\"\n        },\n        delay: {\n          type: \"number\",\n          default: 0,\n          minimum: 0,\n          units: \"milliseconds\"\n        }\n      },\n      \"property-type\": {\n        \"data-driven\": {\n          type: \"property-type\"\n        },\n        \"cross-faded\": {\n          type: \"property-type\"\n        },\n        \"cross-faded-data-driven\": {\n          type: \"property-type\"\n        },\n        \"color-ramp\": {\n          type: \"property-type\"\n        },\n        \"data-constant\": {\n          type: \"property-type\"\n        },\n        constant: {\n          type: \"property-type\"\n        }\n      },\n      promoteId: {\n        \"*\": {\n          type: \"string\"\n        }\n      }\n    };\n\n    class it {\n      constructor(t, e, r, n) {\n        this.message = (t ? `${t}: ` : \"\") + r, n && (this.identifier = n), null != e && e.__line__ && (this.line = e.__line__);\n      }\n\n    }\n\n    function st(t) {\n      const e = t.value;\n      return e ? [new it(t.key, e, \"constants have been deprecated as of v8\")] : [];\n    }\n\n    function at(t) {\n      for (var _len2 = arguments.length, e = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        e[_key2 - 1] = arguments[_key2];\n      }\n\n      for (const r of e) for (const e in r) t[e] = r[e];\n\n      return t;\n    }\n\n    function ot(t) {\n      return t instanceof Number || t instanceof String || t instanceof Boolean ? t.valueOf() : t;\n    }\n\n    function lt(t) {\n      if (Array.isArray(t)) return t.map(lt);\n\n      if (t instanceof Object && !(t instanceof Number || t instanceof String || t instanceof Boolean)) {\n        const e = {};\n\n        for (const r in t) e[r] = lt(t[r]);\n\n        return e;\n      }\n\n      return ot(t);\n    }\n\n    class ut extends Error {\n      constructor(t, e) {\n        super(e), this.message = e, this.key = t;\n      }\n\n    }\n\n    class ct {\n      constructor(t) {\n        let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n        this.parent = t, this.bindings = {};\n\n        for (const [t, r] of e) this.bindings[t] = r;\n      }\n\n      concat(t) {\n        return new ct(this, t);\n      }\n\n      get(t) {\n        if (this.bindings[t]) return this.bindings[t];\n        if (this.parent) return this.parent.get(t);\n        throw new Error(`${t} not found in scope.`);\n      }\n\n      has(t) {\n        return !!this.bindings[t] || !!this.parent && this.parent.has(t);\n      }\n\n    }\n\n    const ht = {\n      kind: \"null\"\n    },\n          pt = {\n      kind: \"number\"\n    },\n          ft = {\n      kind: \"string\"\n    },\n          dt = {\n      kind: \"boolean\"\n    },\n          yt = {\n      kind: \"color\"\n    },\n          mt = {\n      kind: \"object\"\n    },\n          gt = {\n      kind: \"value\"\n    },\n          xt = {\n      kind: \"collator\"\n    },\n          vt = {\n      kind: \"formatted\"\n    },\n          bt = {\n      kind: \"resolvedImage\"\n    };\n\n    function wt(t, e) {\n      return {\n        kind: \"array\",\n        itemType: t,\n        N: e\n      };\n    }\n\n    function _t(t) {\n      if (\"array\" === t.kind) {\n        const e = _t(t.itemType);\n\n        return \"number\" == typeof t.N ? `array<${e}, ${t.N}>` : \"value\" === t.itemType.kind ? \"array\" : `array<${e}>`;\n      }\n\n      return t.kind;\n    }\n\n    const At = [ht, pt, ft, dt, yt, vt, mt, wt(gt), bt];\n\n    function kt(t, e) {\n      if (\"error\" === e.kind) return null;\n\n      if (\"array\" === t.kind) {\n        if (\"array\" === e.kind && (0 === e.N && \"value\" === e.itemType.kind || !kt(t.itemType, e.itemType)) && (\"number\" != typeof t.N || t.N === e.N)) return null;\n      } else {\n        if (t.kind === e.kind) return null;\n        if (\"value\" === t.kind) for (const t of At) if (!kt(t, e)) return null;\n      }\n\n      return `Expected ${_t(t)} but found ${_t(e)} instead.`;\n    }\n\n    function St(t, e) {\n      return e.some(e => e.kind === t.kind);\n    }\n\n    function zt(t, e) {\n      return e.some(e => \"null\" === e ? null === t : \"array\" === e ? Array.isArray(t) : \"object\" === e ? t && !Array.isArray(t) && \"object\" == typeof t : e === typeof t);\n    }\n\n    var It,\n        Mt = {\n      transparent: [0, 0, 0, 0],\n      aliceblue: [240, 248, 255, 1],\n      antiquewhite: [250, 235, 215, 1],\n      aqua: [0, 255, 255, 1],\n      aquamarine: [127, 255, 212, 1],\n      azure: [240, 255, 255, 1],\n      beige: [245, 245, 220, 1],\n      bisque: [255, 228, 196, 1],\n      black: [0, 0, 0, 1],\n      blanchedalmond: [255, 235, 205, 1],\n      blue: [0, 0, 255, 1],\n      blueviolet: [138, 43, 226, 1],\n      brown: [165, 42, 42, 1],\n      burlywood: [222, 184, 135, 1],\n      cadetblue: [95, 158, 160, 1],\n      chartreuse: [127, 255, 0, 1],\n      chocolate: [210, 105, 30, 1],\n      coral: [255, 127, 80, 1],\n      cornflowerblue: [100, 149, 237, 1],\n      cornsilk: [255, 248, 220, 1],\n      crimson: [220, 20, 60, 1],\n      cyan: [0, 255, 255, 1],\n      darkblue: [0, 0, 139, 1],\n      darkcyan: [0, 139, 139, 1],\n      darkgoldenrod: [184, 134, 11, 1],\n      darkgray: [169, 169, 169, 1],\n      darkgreen: [0, 100, 0, 1],\n      darkgrey: [169, 169, 169, 1],\n      darkkhaki: [189, 183, 107, 1],\n      darkmagenta: [139, 0, 139, 1],\n      darkolivegreen: [85, 107, 47, 1],\n      darkorange: [255, 140, 0, 1],\n      darkorchid: [153, 50, 204, 1],\n      darkred: [139, 0, 0, 1],\n      darksalmon: [233, 150, 122, 1],\n      darkseagreen: [143, 188, 143, 1],\n      darkslateblue: [72, 61, 139, 1],\n      darkslategray: [47, 79, 79, 1],\n      darkslategrey: [47, 79, 79, 1],\n      darkturquoise: [0, 206, 209, 1],\n      darkviolet: [148, 0, 211, 1],\n      deeppink: [255, 20, 147, 1],\n      deepskyblue: [0, 191, 255, 1],\n      dimgray: [105, 105, 105, 1],\n      dimgrey: [105, 105, 105, 1],\n      dodgerblue: [30, 144, 255, 1],\n      firebrick: [178, 34, 34, 1],\n      floralwhite: [255, 250, 240, 1],\n      forestgreen: [34, 139, 34, 1],\n      fuchsia: [255, 0, 255, 1],\n      gainsboro: [220, 220, 220, 1],\n      ghostwhite: [248, 248, 255, 1],\n      gold: [255, 215, 0, 1],\n      goldenrod: [218, 165, 32, 1],\n      gray: [128, 128, 128, 1],\n      green: [0, 128, 0, 1],\n      greenyellow: [173, 255, 47, 1],\n      grey: [128, 128, 128, 1],\n      honeydew: [240, 255, 240, 1],\n      hotpink: [255, 105, 180, 1],\n      indianred: [205, 92, 92, 1],\n      indigo: [75, 0, 130, 1],\n      ivory: [255, 255, 240, 1],\n      khaki: [240, 230, 140, 1],\n      lavender: [230, 230, 250, 1],\n      lavenderblush: [255, 240, 245, 1],\n      lawngreen: [124, 252, 0, 1],\n      lemonchiffon: [255, 250, 205, 1],\n      lightblue: [173, 216, 230, 1],\n      lightcoral: [240, 128, 128, 1],\n      lightcyan: [224, 255, 255, 1],\n      lightgoldenrodyellow: [250, 250, 210, 1],\n      lightgray: [211, 211, 211, 1],\n      lightgreen: [144, 238, 144, 1],\n      lightgrey: [211, 211, 211, 1],\n      lightpink: [255, 182, 193, 1],\n      lightsalmon: [255, 160, 122, 1],\n      lightseagreen: [32, 178, 170, 1],\n      lightskyblue: [135, 206, 250, 1],\n      lightslategray: [119, 136, 153, 1],\n      lightslategrey: [119, 136, 153, 1],\n      lightsteelblue: [176, 196, 222, 1],\n      lightyellow: [255, 255, 224, 1],\n      lime: [0, 255, 0, 1],\n      limegreen: [50, 205, 50, 1],\n      linen: [250, 240, 230, 1],\n      magenta: [255, 0, 255, 1],\n      maroon: [128, 0, 0, 1],\n      mediumaquamarine: [102, 205, 170, 1],\n      mediumblue: [0, 0, 205, 1],\n      mediumorchid: [186, 85, 211, 1],\n      mediumpurple: [147, 112, 219, 1],\n      mediumseagreen: [60, 179, 113, 1],\n      mediumslateblue: [123, 104, 238, 1],\n      mediumspringgreen: [0, 250, 154, 1],\n      mediumturquoise: [72, 209, 204, 1],\n      mediumvioletred: [199, 21, 133, 1],\n      midnightblue: [25, 25, 112, 1],\n      mintcream: [245, 255, 250, 1],\n      mistyrose: [255, 228, 225, 1],\n      moccasin: [255, 228, 181, 1],\n      navajowhite: [255, 222, 173, 1],\n      navy: [0, 0, 128, 1],\n      oldlace: [253, 245, 230, 1],\n      olive: [128, 128, 0, 1],\n      olivedrab: [107, 142, 35, 1],\n      orange: [255, 165, 0, 1],\n      orangered: [255, 69, 0, 1],\n      orchid: [218, 112, 214, 1],\n      palegoldenrod: [238, 232, 170, 1],\n      palegreen: [152, 251, 152, 1],\n      paleturquoise: [175, 238, 238, 1],\n      palevioletred: [219, 112, 147, 1],\n      papayawhip: [255, 239, 213, 1],\n      peachpuff: [255, 218, 185, 1],\n      peru: [205, 133, 63, 1],\n      pink: [255, 192, 203, 1],\n      plum: [221, 160, 221, 1],\n      powderblue: [176, 224, 230, 1],\n      purple: [128, 0, 128, 1],\n      rebeccapurple: [102, 51, 153, 1],\n      red: [255, 0, 0, 1],\n      rosybrown: [188, 143, 143, 1],\n      royalblue: [65, 105, 225, 1],\n      saddlebrown: [139, 69, 19, 1],\n      salmon: [250, 128, 114, 1],\n      sandybrown: [244, 164, 96, 1],\n      seagreen: [46, 139, 87, 1],\n      seashell: [255, 245, 238, 1],\n      sienna: [160, 82, 45, 1],\n      silver: [192, 192, 192, 1],\n      skyblue: [135, 206, 235, 1],\n      slateblue: [106, 90, 205, 1],\n      slategray: [112, 128, 144, 1],\n      slategrey: [112, 128, 144, 1],\n      snow: [255, 250, 250, 1],\n      springgreen: [0, 255, 127, 1],\n      steelblue: [70, 130, 180, 1],\n      tan: [210, 180, 140, 1],\n      teal: [0, 128, 128, 1],\n      thistle: [216, 191, 216, 1],\n      tomato: [255, 99, 71, 1],\n      turquoise: [64, 224, 208, 1],\n      violet: [238, 130, 238, 1],\n      wheat: [245, 222, 179, 1],\n      white: [255, 255, 255, 1],\n      whitesmoke: [245, 245, 245, 1],\n      yellow: [255, 255, 0, 1],\n      yellowgreen: [154, 205, 50, 1]\n    };\n\n    function Bt(t) {\n      return (t = Math.round(t)) < 0 ? 0 : t > 255 ? 255 : t;\n    }\n\n    function Ct(t) {\n      return Bt(\"%\" === t[t.length - 1] ? parseFloat(t) / 100 * 255 : parseInt(t));\n    }\n\n    function Pt(t) {\n      return (e = \"%\" === t[t.length - 1] ? parseFloat(t) / 100 : parseFloat(t)) < 0 ? 0 : e > 1 ? 1 : e;\n      var e;\n    }\n\n    function Vt(t, e, r) {\n      return r < 0 ? r += 1 : r > 1 && (r -= 1), 6 * r < 1 ? t + (e - t) * r * 6 : 2 * r < 1 ? e : 3 * r < 2 ? t + (e - t) * (2 / 3 - r) * 6 : t;\n    }\n\n    try {\n      It = {}.parseCSSColor = function (t) {\n        var e,\n            r = t.replace(/ /g, \"\").toLowerCase();\n        if (r in Mt) return Mt[r].slice();\n        if (\"#\" === r[0]) return 4 === r.length ? (e = parseInt(r.substr(1), 16)) >= 0 && e <= 4095 ? [(3840 & e) >> 4 | (3840 & e) >> 8, 240 & e | (240 & e) >> 4, 15 & e | (15 & e) << 4, 1] : null : 7 === r.length && (e = parseInt(r.substr(1), 16)) >= 0 && e <= 16777215 ? [(16711680 & e) >> 16, (65280 & e) >> 8, 255 & e, 1] : null;\n        var n = r.indexOf(\"(\"),\n            i = r.indexOf(\")\");\n\n        if (-1 !== n && i + 1 === r.length) {\n          var s = r.substr(0, n),\n              a = r.substr(n + 1, i - (n + 1)).split(\",\"),\n              o = 1;\n\n          switch (s) {\n            case \"rgba\":\n              if (4 !== a.length) return null;\n              o = Pt(a.pop());\n\n            case \"rgb\":\n              return 3 !== a.length ? null : [Ct(a[0]), Ct(a[1]), Ct(a[2]), o];\n\n            case \"hsla\":\n              if (4 !== a.length) return null;\n              o = Pt(a.pop());\n\n            case \"hsl\":\n              if (3 !== a.length) return null;\n              var l = (parseFloat(a[0]) % 360 + 360) % 360 / 360,\n                  u = Pt(a[1]),\n                  c = Pt(a[2]),\n                  h = c <= .5 ? c * (u + 1) : c + u - c * u,\n                  p = 2 * c - h;\n              return [Bt(255 * Vt(p, h, l + 1 / 3)), Bt(255 * Vt(p, h, l)), Bt(255 * Vt(p, h, l - 1 / 3)), o];\n\n            default:\n              return null;\n          }\n        }\n\n        return null;\n      };\n    } catch (t) {}\n\n    class Et {\n      constructor(t, e, r) {\n        let n = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n        this.r = t, this.g = e, this.b = r, this.a = n;\n      }\n\n      static parse(t) {\n        if (!t) return;\n        if (t instanceof Et) return t;\n        if (\"string\" != typeof t) return;\n        const e = It(t);\n        return e ? new Et(e[0] / 255 * e[3], e[1] / 255 * e[3], e[2] / 255 * e[3], e[3]) : void 0;\n      }\n\n      toString() {\n        const [t, e, r, n] = this.toArray();\n        return `rgba(${Math.round(t)},${Math.round(e)},${Math.round(r)},${n})`;\n      }\n\n      toArray() {\n        const {\n          r: t,\n          g: e,\n          b: r,\n          a: n\n        } = this;\n        return 0 === n ? [0, 0, 0, 0] : [255 * t / n, 255 * e / n, 255 * r / n, n];\n      }\n\n    }\n\n    Et.black = new Et(0, 0, 0, 1), Et.white = new Et(1, 1, 1, 1), Et.transparent = new Et(0, 0, 0, 0), Et.red = new Et(1, 0, 0, 1);\n\n    class Ft {\n      constructor(t, e, r) {\n        this.sensitivity = t ? e ? \"variant\" : \"case\" : e ? \"accent\" : \"base\", this.locale = r, this.collator = new Intl.Collator(this.locale ? this.locale : [], {\n          sensitivity: this.sensitivity,\n          usage: \"search\"\n        });\n      }\n\n      compare(t, e) {\n        return this.collator.compare(t, e);\n      }\n\n      resolvedLocale() {\n        return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;\n      }\n\n    }\n\n    class Tt {\n      constructor(t, e, r, n, i) {\n        this.text = t, this.image = e, this.scale = r, this.fontStack = n, this.textColor = i;\n      }\n\n    }\n\n    class Lt {\n      constructor(t) {\n        this.sections = t;\n      }\n\n      static fromString(t) {\n        return new Lt([new Tt(t, null, null, null, null)]);\n      }\n\n      isEmpty() {\n        return 0 === this.sections.length || !this.sections.some(t => 0 !== t.text.length || t.image && 0 !== t.image.name.length);\n      }\n\n      static factory(t) {\n        return t instanceof Lt ? t : Lt.fromString(t);\n      }\n\n      toString() {\n        return 0 === this.sections.length ? \"\" : this.sections.map(t => t.text).join(\"\");\n      }\n\n      serialize() {\n        const t = [\"format\"];\n\n        for (const e of this.sections) {\n          if (e.image) {\n            t.push([\"image\", e.image.name]);\n            continue;\n          }\n\n          t.push(e.text);\n          const r = {};\n          e.fontStack && (r[\"text-font\"] = [\"literal\", e.fontStack.split(\",\")]), e.scale && (r[\"font-scale\"] = e.scale), e.textColor && (r[\"text-color\"] = [\"rgba\"].concat(e.textColor.toArray())), t.push(r);\n        }\n\n        return t;\n      }\n\n    }\n\n    class Dt {\n      constructor(t) {\n        this.name = t.name, this.available = t.available;\n      }\n\n      toString() {\n        return this.name;\n      }\n\n      static fromString(t) {\n        return t ? new Dt({\n          name: t,\n          available: !1\n        }) : null;\n      }\n\n      serialize() {\n        return [\"image\", this.name];\n      }\n\n    }\n\n    function $t(t, e, r, n) {\n      return \"number\" == typeof t && t >= 0 && t <= 255 && \"number\" == typeof e && e >= 0 && e <= 255 && \"number\" == typeof r && r >= 0 && r <= 255 ? void 0 === n || \"number\" == typeof n && n >= 0 && n <= 1 ? null : `Invalid rgba value [${[t, e, r, n].join(\", \")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${(\"number\" == typeof n ? [t, e, r, n] : [t, e, r]).join(\", \")}]: 'r', 'g', and 'b' must be between 0 and 255.`;\n    }\n\n    function Ot(t) {\n      if (null === t) return !0;\n      if (\"string\" == typeof t) return !0;\n      if (\"boolean\" == typeof t) return !0;\n      if (\"number\" == typeof t) return !0;\n      if (t instanceof Et) return !0;\n      if (t instanceof Ft) return !0;\n      if (t instanceof Lt) return !0;\n      if (t instanceof Dt) return !0;\n\n      if (Array.isArray(t)) {\n        for (const e of t) if (!Ot(e)) return !1;\n\n        return !0;\n      }\n\n      if (\"object\" == typeof t) {\n        for (const e in t) if (!Ot(t[e])) return !1;\n\n        return !0;\n      }\n\n      return !1;\n    }\n\n    function Rt(t) {\n      if (null === t) return ht;\n      if (\"string\" == typeof t) return ft;\n      if (\"boolean\" == typeof t) return dt;\n      if (\"number\" == typeof t) return pt;\n      if (t instanceof Et) return yt;\n      if (t instanceof Ft) return xt;\n      if (t instanceof Lt) return vt;\n      if (t instanceof Dt) return bt;\n\n      if (Array.isArray(t)) {\n        const e = t.length;\n        let r;\n\n        for (const e of t) {\n          const t = Rt(e);\n\n          if (r) {\n            if (r === t) continue;\n            r = gt;\n            break;\n          }\n\n          r = t;\n        }\n\n        return wt(r || gt, e);\n      }\n\n      return mt;\n    }\n\n    function Ut(t) {\n      const e = typeof t;\n      return null === t ? \"\" : \"string\" === e || \"number\" === e || \"boolean\" === e ? String(t) : t instanceof Et || t instanceof Lt || t instanceof Dt ? t.toString() : JSON.stringify(t);\n    }\n\n    class qt {\n      constructor(t, e) {\n        this.type = t, this.value = e;\n      }\n\n      static parse(t, e) {\n        if (2 !== t.length) return e.error(`'literal' expression requires exactly one argument, but found ${t.length - 1} instead.`);\n        if (!Ot(t[1])) return e.error(\"invalid value\");\n        const r = t[1];\n        let n = Rt(r);\n        const i = e.expectedType;\n        return \"array\" !== n.kind || 0 !== n.N || !i || \"array\" !== i.kind || \"number\" == typeof i.N && 0 !== i.N || (n = i), new qt(n, r);\n      }\n\n      evaluate() {\n        return this.value;\n      }\n\n      eachChild() {}\n\n      outputDefined() {\n        return !0;\n      }\n\n      serialize() {\n        return \"array\" === this.type.kind || \"object\" === this.type.kind ? [\"literal\", this.value] : this.value instanceof Et ? [\"rgba\"].concat(this.value.toArray()) : this.value instanceof Lt ? this.value.serialize() : this.value;\n      }\n\n    }\n\n    class jt {\n      constructor(t) {\n        this.name = \"ExpressionEvaluationError\", this.message = t;\n      }\n\n      toJSON() {\n        return this.message;\n      }\n\n    }\n\n    const Nt = {\n      string: ft,\n      number: pt,\n      boolean: dt,\n      object: mt\n    };\n\n    class Kt {\n      constructor(t, e) {\n        this.type = t, this.args = e;\n      }\n\n      static parse(t, e) {\n        if (t.length < 2) return e.error(\"Expected at least one argument.\");\n        let r,\n            n = 1;\n        const i = t[0];\n\n        if (\"array\" === i) {\n          let i, s;\n\n          if (t.length > 2) {\n            const r = t[1];\n            if (\"string\" != typeof r || !(r in Nt) || \"object\" === r) return e.error('The item type argument of \"array\" must be one of string, number, boolean', 1);\n            i = Nt[r], n++;\n          } else i = gt;\n\n          if (t.length > 3) {\n            if (null !== t[2] && (\"number\" != typeof t[2] || t[2] < 0 || t[2] !== Math.floor(t[2]))) return e.error('The length argument to \"array\" must be a positive integer literal', 2);\n            s = t[2], n++;\n          }\n\n          r = wt(i, s);\n        } else r = Nt[i];\n\n        const s = [];\n\n        for (; n < t.length; n++) {\n          const r = e.parse(t[n], n, gt);\n          if (!r) return null;\n          s.push(r);\n        }\n\n        return new Kt(r, s);\n      }\n\n      evaluate(t) {\n        for (let e = 0; e < this.args.length; e++) {\n          const r = this.args[e].evaluate(t);\n          if (!kt(this.type, Rt(r))) return r;\n          if (e === this.args.length - 1) throw new jt(`Expected value to be of type ${_t(this.type)}, but found ${_t(Rt(r))} instead.`);\n        }\n\n        return null;\n      }\n\n      eachChild(t) {\n        this.args.forEach(t);\n      }\n\n      outputDefined() {\n        return this.args.every(t => t.outputDefined());\n      }\n\n      serialize() {\n        const t = this.type,\n              e = [t.kind];\n\n        if (\"array\" === t.kind) {\n          const r = t.itemType;\n\n          if (\"string\" === r.kind || \"number\" === r.kind || \"boolean\" === r.kind) {\n            e.push(r.kind);\n            const n = t.N;\n            (\"number\" == typeof n || this.args.length > 1) && e.push(n);\n          }\n        }\n\n        return e.concat(this.args.map(t => t.serialize()));\n      }\n\n    }\n\n    class Zt {\n      constructor(t) {\n        this.type = vt, this.sections = t;\n      }\n\n      static parse(t, e) {\n        if (t.length < 2) return e.error(\"Expected at least one argument.\");\n        const r = t[1];\n        if (!Array.isArray(r) && \"object\" == typeof r) return e.error(\"First argument must be an image or text section.\");\n        const n = [];\n        let i = !1;\n\n        for (let r = 1; r <= t.length - 1; ++r) {\n          const s = t[r];\n\n          if (i && \"object\" == typeof s && !Array.isArray(s)) {\n            i = !1;\n            let t = null;\n            if (s[\"font-scale\"] && (t = e.parse(s[\"font-scale\"], 1, pt), !t)) return null;\n            let r = null;\n            if (s[\"text-font\"] && (r = e.parse(s[\"text-font\"], 1, wt(ft)), !r)) return null;\n            let a = null;\n            if (s[\"text-color\"] && (a = e.parse(s[\"text-color\"], 1, yt), !a)) return null;\n            const o = n[n.length - 1];\n            o.scale = t, o.font = r, o.textColor = a;\n          } else {\n            const s = e.parse(t[r], 1, gt);\n            if (!s) return null;\n            const a = s.type.kind;\n            if (\"string\" !== a && \"value\" !== a && \"null\" !== a && \"resolvedImage\" !== a) return e.error(\"Formatted text type must be 'string', 'value', 'image' or 'null'.\");\n            i = !0, n.push({\n              content: s,\n              scale: null,\n              font: null,\n              textColor: null\n            });\n          }\n        }\n\n        return new Zt(n);\n      }\n\n      evaluate(t) {\n        return new Lt(this.sections.map(e => {\n          const r = e.content.evaluate(t);\n          return Rt(r) === bt ? new Tt(\"\", r, null, null, null) : new Tt(Ut(r), null, e.scale ? e.scale.evaluate(t) : null, e.font ? e.font.evaluate(t).join(\",\") : null, e.textColor ? e.textColor.evaluate(t) : null);\n        }));\n      }\n\n      eachChild(t) {\n        for (const e of this.sections) t(e.content), e.scale && t(e.scale), e.font && t(e.font), e.textColor && t(e.textColor);\n      }\n\n      outputDefined() {\n        return !1;\n      }\n\n      serialize() {\n        const t = [\"format\"];\n\n        for (const e of this.sections) {\n          t.push(e.content.serialize());\n          const r = {};\n          e.scale && (r[\"font-scale\"] = e.scale.serialize()), e.font && (r[\"text-font\"] = e.font.serialize()), e.textColor && (r[\"text-color\"] = e.textColor.serialize()), t.push(r);\n        }\n\n        return t;\n      }\n\n    }\n\n    class Gt {\n      constructor(t) {\n        this.type = bt, this.input = t;\n      }\n\n      static parse(t, e) {\n        if (2 !== t.length) return e.error(\"Expected two arguments.\");\n        const r = e.parse(t[1], 1, ft);\n        return r ? new Gt(r) : e.error(\"No image name provided.\");\n      }\n\n      evaluate(t) {\n        const e = this.input.evaluate(t),\n              r = Dt.fromString(e);\n        return r && t.availableImages && (r.available = t.availableImages.indexOf(e) > -1), r;\n      }\n\n      eachChild(t) {\n        t(this.input);\n      }\n\n      outputDefined() {\n        return !1;\n      }\n\n      serialize() {\n        return [\"image\", this.input.serialize()];\n      }\n\n    }\n\n    const Jt = {\n      \"to-boolean\": dt,\n      \"to-color\": yt,\n      \"to-number\": pt,\n      \"to-string\": ft\n    };\n\n    class Xt {\n      constructor(t, e) {\n        this.type = t, this.args = e;\n      }\n\n      static parse(t, e) {\n        if (t.length < 2) return e.error(\"Expected at least one argument.\");\n        const r = t[0];\n        if ((\"to-boolean\" === r || \"to-string\" === r) && 2 !== t.length) return e.error(\"Expected one argument.\");\n        const n = Jt[r],\n              i = [];\n\n        for (let r = 1; r < t.length; r++) {\n          const n = e.parse(t[r], r, gt);\n          if (!n) return null;\n          i.push(n);\n        }\n\n        return new Xt(n, i);\n      }\n\n      evaluate(t) {\n        if (\"boolean\" === this.type.kind) return Boolean(this.args[0].evaluate(t));\n\n        if (\"color\" === this.type.kind) {\n          let e, r;\n\n          for (const n of this.args) {\n            if (e = n.evaluate(t), r = null, e instanceof Et) return e;\n\n            if (\"string\" == typeof e) {\n              const r = t.parseColor(e);\n              if (r) return r;\n            } else if (Array.isArray(e) && (r = e.length < 3 || e.length > 4 ? `Invalid rbga value ${JSON.stringify(e)}: expected an array containing either three or four numeric values.` : $t(e[0], e[1], e[2], e[3]), !r)) return new Et(e[0] / 255, e[1] / 255, e[2] / 255, e[3]);\n          }\n\n          throw new jt(r || `Could not parse color from value '${\"string\" == typeof e ? e : String(JSON.stringify(e))}'`);\n        }\n\n        if (\"number\" === this.type.kind) {\n          let e = null;\n\n          for (const r of this.args) {\n            if (e = r.evaluate(t), null === e) return 0;\n            const n = Number(e);\n            if (!isNaN(n)) return n;\n          }\n\n          throw new jt(`Could not convert ${JSON.stringify(e)} to number.`);\n        }\n\n        return \"formatted\" === this.type.kind ? Lt.fromString(Ut(this.args[0].evaluate(t))) : \"resolvedImage\" === this.type.kind ? Dt.fromString(Ut(this.args[0].evaluate(t))) : Ut(this.args[0].evaluate(t));\n      }\n\n      eachChild(t) {\n        this.args.forEach(t);\n      }\n\n      outputDefined() {\n        return this.args.every(t => t.outputDefined());\n      }\n\n      serialize() {\n        if (\"formatted\" === this.type.kind) return new Zt([{\n          content: this.args[0],\n          scale: null,\n          font: null,\n          textColor: null\n        }]).serialize();\n        if (\"resolvedImage\" === this.type.kind) return new Gt(this.args[0]).serialize();\n        const t = [`to-${this.type.kind}`];\n        return this.eachChild(e => {\n          t.push(e.serialize());\n        }), t;\n      }\n\n    }\n\n    const Yt = [\"Unknown\", \"Point\", \"LineString\", \"Polygon\"];\n\n    class Ht {\n      constructor() {\n        this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null;\n      }\n\n      id() {\n        return this.feature && \"id\" in this.feature ? this.feature.id : null;\n      }\n\n      geometryType() {\n        return this.feature ? \"number\" == typeof this.feature.type ? Yt[this.feature.type] : this.feature.type : null;\n      }\n\n      geometry() {\n        return this.feature && \"geometry\" in this.feature ? this.feature.geometry : null;\n      }\n\n      canonicalID() {\n        return this.canonical;\n      }\n\n      properties() {\n        return this.feature && this.feature.properties || {};\n      }\n\n      parseColor(t) {\n        let e = this._parseColorCache[t];\n        return e || (e = this._parseColorCache[t] = Et.parse(t)), e;\n      }\n\n    }\n\n    class Wt {\n      constructor(t, e, r, n) {\n        this.name = t, this.type = e, this._evaluate = r, this.args = n;\n      }\n\n      evaluate(t) {\n        return this._evaluate(t, this.args);\n      }\n\n      eachChild(t) {\n        this.args.forEach(t);\n      }\n\n      outputDefined() {\n        return !1;\n      }\n\n      serialize() {\n        return [this.name].concat(this.args.map(t => t.serialize()));\n      }\n\n      static parse(t, e) {\n        const r = t[0],\n              n = Wt.definitions[r];\n        if (!n) return e.error(`Unknown expression \"${r}\". If you wanted a literal array, use [\"literal\", [...]].`, 0);\n        const i = Array.isArray(n) ? n[0] : n.type,\n              s = Array.isArray(n) ? [[n[1], n[2]]] : n.overloads,\n              a = s.filter(_ref => {\n          let [e] = _ref;\n          return !Array.isArray(e) || e.length === t.length - 1;\n        });\n        let o = null;\n\n        for (const [n, s] of a) {\n          o = new we(e.registry, e.path, null, e.scope);\n          const a = [];\n          let l = !1;\n\n          for (let e = 1; e < t.length; e++) {\n            const r = t[e],\n                  i = Array.isArray(n) ? n[e - 1] : n.type,\n                  s = o.parse(r, 1 + a.length, i);\n\n            if (!s) {\n              l = !0;\n              break;\n            }\n\n            a.push(s);\n          }\n\n          if (!l) if (Array.isArray(n) && n.length !== a.length) o.error(`Expected ${n.length} arguments, but found ${a.length} instead.`);else {\n            for (let t = 0; t < a.length; t++) {\n              const e = Array.isArray(n) ? n[t] : n.type,\n                    r = a[t];\n              o.concat(t + 1).checkSubtype(e, r.type);\n            }\n\n            if (0 === o.errors.length) return new Wt(r, i, s, a);\n          }\n        }\n\n        if (1 === a.length) e.errors.push(...o.errors);else {\n          const r = (a.length ? a : s).map(_ref2 => {\n            let [t] = _ref2;\n            return e = t, Array.isArray(e) ? `(${e.map(_t).join(\", \")})` : `(${_t(e.type)}...)`;\n            var e;\n          }).join(\" | \"),\n                n = [];\n\n          for (let r = 1; r < t.length; r++) {\n            const i = e.parse(t[r], 1 + n.length);\n            if (!i) return null;\n            n.push(_t(i.type));\n          }\n\n          e.error(`Expected arguments of type ${r}, but found (${n.join(\", \")}) instead.`);\n        }\n        return null;\n      }\n\n      static register(t, e) {\n        Wt.definitions = e;\n\n        for (const r in e) t[r] = Wt;\n      }\n\n    }\n\n    class Qt {\n      constructor(t, e, r) {\n        this.type = xt, this.locale = r, this.caseSensitive = t, this.diacriticSensitive = e;\n      }\n\n      static parse(t, e) {\n        if (2 !== t.length) return e.error(\"Expected one argument.\");\n        const r = t[1];\n        if (\"object\" != typeof r || Array.isArray(r)) return e.error(\"Collator options argument must be an object.\");\n        const n = e.parse(void 0 !== r[\"case-sensitive\"] && r[\"case-sensitive\"], 1, dt);\n        if (!n) return null;\n        const i = e.parse(void 0 !== r[\"diacritic-sensitive\"] && r[\"diacritic-sensitive\"], 1, dt);\n        if (!i) return null;\n        let s = null;\n        return r.locale && (s = e.parse(r.locale, 1, ft), !s) ? null : new Qt(n, i, s);\n      }\n\n      evaluate(t) {\n        return new Ft(this.caseSensitive.evaluate(t), this.diacriticSensitive.evaluate(t), this.locale ? this.locale.evaluate(t) : null);\n      }\n\n      eachChild(t) {\n        t(this.caseSensitive), t(this.diacriticSensitive), this.locale && t(this.locale);\n      }\n\n      outputDefined() {\n        return !1;\n      }\n\n      serialize() {\n        const t = {};\n        return t[\"case-sensitive\"] = this.caseSensitive.serialize(), t[\"diacritic-sensitive\"] = this.diacriticSensitive.serialize(), this.locale && (t.locale = this.locale.serialize()), [\"collator\", t];\n      }\n\n    }\n\n    const te = 8192;\n\n    function ee(t, e) {\n      t[0] = Math.min(t[0], e[0]), t[1] = Math.min(t[1], e[1]), t[2] = Math.max(t[2], e[0]), t[3] = Math.max(t[3], e[1]);\n    }\n\n    function re(t, e) {\n      return !(t[0] <= e[0] || t[2] >= e[2] || t[1] <= e[1] || t[3] >= e[3]);\n    }\n\n    function ne(t, e) {\n      const r = (180 + t[0]) / 360,\n            n = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t[1] * Math.PI / 360))) / 360,\n            i = Math.pow(2, e.z);\n      return [Math.round(r * i * te), Math.round(n * i * te)];\n    }\n\n    function ie(t, e, r) {\n      const n = t[0] - e[0],\n            i = t[1] - e[1],\n            s = t[0] - r[0],\n            a = t[1] - r[1];\n      return n * a - s * i == 0 && n * s <= 0 && i * a <= 0;\n    }\n\n    function se(t, e) {\n      let r = !1;\n\n      for (let a = 0, o = e.length; a < o; a++) {\n        const o = e[a];\n\n        for (let e = 0, a = o.length; e < a - 1; e++) {\n          if (ie(t, o[e], o[e + 1])) return !1;\n          (i = o[e])[1] > (n = t)[1] != (s = o[e + 1])[1] > n[1] && n[0] < (s[0] - i[0]) * (n[1] - i[1]) / (s[1] - i[1]) + i[0] && (r = !r);\n        }\n      }\n\n      var n, i, s;\n      return r;\n    }\n\n    function ae(t, e) {\n      for (let r = 0; r < e.length; r++) if (se(t, e[r])) return !0;\n\n      return !1;\n    }\n\n    function oe(t, e, r, n) {\n      const i = n[0] - r[0],\n            s = n[1] - r[1],\n            a = (t[0] - r[0]) * s - i * (t[1] - r[1]),\n            o = (e[0] - r[0]) * s - i * (e[1] - r[1]);\n      return a > 0 && o < 0 || a < 0 && o > 0;\n    }\n\n    function le(t, e, r) {\n      for (const u of r) for (let r = 0; r < u.length - 1; ++r) if (0 != (o = [(a = u[r + 1])[0] - (s = u[r])[0], a[1] - s[1]])[0] * (l = [(i = e)[0] - (n = t)[0], i[1] - n[1]])[1] - o[1] * l[0] && oe(n, i, s, a) && oe(s, a, n, i)) return !0;\n\n      var n, i, s, a, o, l;\n      return !1;\n    }\n\n    function ue(t, e) {\n      for (let r = 0; r < t.length; ++r) if (!se(t[r], e)) return !1;\n\n      for (let r = 0; r < t.length - 1; ++r) if (le(t[r], t[r + 1], e)) return !1;\n\n      return !0;\n    }\n\n    function ce(t, e) {\n      for (let r = 0; r < e.length; r++) if (ue(t, e[r])) return !0;\n\n      return !1;\n    }\n\n    function he(t, e, r) {\n      const n = [];\n\n      for (let i = 0; i < t.length; i++) {\n        const s = [];\n\n        for (let n = 0; n < t[i].length; n++) {\n          const a = ne(t[i][n], r);\n          ee(e, a), s.push(a);\n        }\n\n        n.push(s);\n      }\n\n      return n;\n    }\n\n    function pe(t, e, r) {\n      const n = [];\n\n      for (let i = 0; i < t.length; i++) {\n        const s = he(t[i], e, r);\n        n.push(s);\n      }\n\n      return n;\n    }\n\n    function fe(t, e, r, n) {\n      if (t[0] < r[0] || t[0] > r[2]) {\n        const e = .5 * n;\n        let i = t[0] - r[0] > e ? -n : r[0] - t[0] > e ? n : 0;\n        0 === i && (i = t[0] - r[2] > e ? -n : r[2] - t[0] > e ? n : 0), t[0] += i;\n      }\n\n      ee(e, t);\n    }\n\n    function de(t, e, r, n) {\n      const i = Math.pow(2, n.z) * te,\n            s = [n.x * te, n.y * te],\n            a = [];\n\n      for (const n of t) for (const t of n) {\n        const n = [t.x + s[0], t.y + s[1]];\n        fe(n, e, r, i), a.push(n);\n      }\n\n      return a;\n    }\n\n    function ye(t, e, r, n) {\n      const i = Math.pow(2, n.z) * te,\n            s = [n.x * te, n.y * te],\n            a = [];\n\n      for (const r of t) {\n        const t = [];\n\n        for (const n of r) {\n          const r = [n.x + s[0], n.y + s[1]];\n          ee(e, r), t.push(r);\n        }\n\n        a.push(t);\n      }\n\n      if (e[2] - e[0] <= i / 2) {\n        (o = e)[0] = o[1] = 1 / 0, o[2] = o[3] = -1 / 0;\n\n        for (const t of a) for (const n of t) fe(n, e, r, i);\n      }\n\n      var o;\n      return a;\n    }\n\n    class me {\n      constructor(t, e) {\n        this.type = dt, this.geojson = t, this.geometries = e;\n      }\n\n      static parse(t, e) {\n        if (2 !== t.length) return e.error(`'within' expression requires exactly one argument, but found ${t.length - 1} instead.`);\n\n        if (Ot(t[1])) {\n          const e = t[1];\n          if (\"FeatureCollection\" === e.type) for (let t = 0; t < e.features.length; ++t) {\n            const r = e.features[t].geometry.type;\n            if (\"Polygon\" === r || \"MultiPolygon\" === r) return new me(e, e.features[t].geometry);\n          } else if (\"Feature\" === e.type) {\n            const t = e.geometry.type;\n            if (\"Polygon\" === t || \"MultiPolygon\" === t) return new me(e, e.geometry);\n          } else if (\"Polygon\" === e.type || \"MultiPolygon\" === e.type) return new me(e, e);\n        }\n\n        return e.error(\"'within' expression requires valid geojson object that contains polygon geometry type.\");\n      }\n\n      evaluate(t) {\n        if (null != t.geometry() && null != t.canonicalID()) {\n          if (\"Point\" === t.geometryType()) return function (t, e) {\n            const r = [1 / 0, 1 / 0, -1 / 0, -1 / 0],\n                  n = [1 / 0, 1 / 0, -1 / 0, -1 / 0],\n                  i = t.canonicalID();\n\n            if (\"Polygon\" === e.type) {\n              const s = he(e.coordinates, n, i),\n                    a = de(t.geometry(), r, n, i);\n              if (!re(r, n)) return !1;\n\n              for (const t of a) if (!se(t, s)) return !1;\n            }\n\n            if (\"MultiPolygon\" === e.type) {\n              const s = pe(e.coordinates, n, i),\n                    a = de(t.geometry(), r, n, i);\n              if (!re(r, n)) return !1;\n\n              for (const t of a) if (!ae(t, s)) return !1;\n            }\n\n            return !0;\n          }(t, this.geometries);\n          if (\"LineString\" === t.geometryType()) return function (t, e) {\n            const r = [1 / 0, 1 / 0, -1 / 0, -1 / 0],\n                  n = [1 / 0, 1 / 0, -1 / 0, -1 / 0],\n                  i = t.canonicalID();\n\n            if (\"Polygon\" === e.type) {\n              const s = he(e.coordinates, n, i),\n                    a = ye(t.geometry(), r, n, i);\n              if (!re(r, n)) return !1;\n\n              for (const t of a) if (!ue(t, s)) return !1;\n            }\n\n            if (\"MultiPolygon\" === e.type) {\n              const s = pe(e.coordinates, n, i),\n                    a = ye(t.geometry(), r, n, i);\n              if (!re(r, n)) return !1;\n\n              for (const t of a) if (!ce(t, s)) return !1;\n            }\n\n            return !0;\n          }(t, this.geometries);\n        }\n\n        return !1;\n      }\n\n      eachChild() {}\n\n      outputDefined() {\n        return !0;\n      }\n\n      serialize() {\n        return [\"within\", this.geojson];\n      }\n\n    }\n\n    function ge(t) {\n      if (t instanceof Wt) {\n        if (\"get\" === t.name && 1 === t.args.length) return !1;\n        if (\"feature-state\" === t.name) return !1;\n        if (\"has\" === t.name && 1 === t.args.length) return !1;\n        if (\"properties\" === t.name || \"geometry-type\" === t.name || \"id\" === t.name) return !1;\n        if (/^filter-/.test(t.name)) return !1;\n      }\n\n      if (t instanceof me) return !1;\n      let e = !0;\n      return t.eachChild(t => {\n        e && !ge(t) && (e = !1);\n      }), e;\n    }\n\n    function xe(t) {\n      if (t instanceof Wt && \"feature-state\" === t.name) return !1;\n      let e = !0;\n      return t.eachChild(t => {\n        e && !xe(t) && (e = !1);\n      }), e;\n    }\n\n    function ve(t, e) {\n      if (t instanceof Wt && e.indexOf(t.name) >= 0) return !1;\n      let r = !0;\n      return t.eachChild(t => {\n        r && !ve(t, e) && (r = !1);\n      }), r;\n    }\n\n    class be {\n      constructor(t, e) {\n        this.type = e.type, this.name = t, this.boundExpression = e;\n      }\n\n      static parse(t, e) {\n        if (2 !== t.length || \"string\" != typeof t[1]) return e.error(\"'var' expression requires exactly one string literal argument.\");\n        const r = t[1];\n        return e.scope.has(r) ? new be(r, e.scope.get(r)) : e.error(`Unknown variable \"${r}\". Make sure \"${r}\" has been bound in an enclosing \"let\" expression before using it.`, 1);\n      }\n\n      evaluate(t) {\n        return this.boundExpression.evaluate(t);\n      }\n\n      eachChild() {}\n\n      outputDefined() {\n        return !1;\n      }\n\n      serialize() {\n        return [\"var\", this.name];\n      }\n\n    }\n\n    class we {\n      constructor(t) {\n        let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n        let r = arguments.length > 2 ? arguments[2] : undefined;\n        let n = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new ct();\n        let i = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n        this.registry = t, this.path = e, this.key = e.map(t => `[${t}]`).join(\"\"), this.scope = n, this.errors = i, this.expectedType = r;\n      }\n\n      parse(t, e, r, n) {\n        let i = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n        return e ? this.concat(e, r, n)._parse(t, i) : this._parse(t, i);\n      }\n\n      _parse(t, e) {\n        function r(t, e, r) {\n          return \"assert\" === r ? new Kt(e, [t]) : \"coerce\" === r ? new Xt(e, [t]) : t;\n        }\n\n        if (null !== t && \"string\" != typeof t && \"boolean\" != typeof t && \"number\" != typeof t || (t = [\"literal\", t]), Array.isArray(t)) {\n          if (0 === t.length) return this.error('Expected an array with at least one element. If you wanted a literal array, use [\"literal\", []].');\n          const n = t[0];\n          if (\"string\" != typeof n) return this.error(`Expression name must be a string, but found ${typeof n} instead. If you wanted a literal array, use [\"literal\", [...]].`, 0), null;\n          const i = this.registry[n];\n\n          if (i) {\n            let n = i.parse(t, this);\n            if (!n) return null;\n\n            if (this.expectedType) {\n              const t = this.expectedType,\n                    i = n.type;\n              if (\"string\" !== t.kind && \"number\" !== t.kind && \"boolean\" !== t.kind && \"object\" !== t.kind && \"array\" !== t.kind || \"value\" !== i.kind) {\n                if (\"color\" !== t.kind && \"formatted\" !== t.kind && \"resolvedImage\" !== t.kind || \"value\" !== i.kind && \"string\" !== i.kind) {\n                  if (this.checkSubtype(t, i)) return null;\n                } else n = r(n, t, e.typeAnnotation || \"coerce\");\n              } else n = r(n, t, e.typeAnnotation || \"assert\");\n            }\n\n            if (!(n instanceof qt) && \"resolvedImage\" !== n.type.kind && _e(n)) {\n              const t = new Ht();\n\n              try {\n                n = new qt(n.type, n.evaluate(t));\n              } catch (t) {\n                return this.error(t.message), null;\n              }\n            }\n\n            return n;\n          }\n\n          return this.error(`Unknown expression \"${n}\". If you wanted a literal array, use [\"literal\", [...]].`, 0);\n        }\n\n        return this.error(void 0 === t ? \"'undefined' value invalid. Use null instead.\" : \"object\" == typeof t ? 'Bare objects invalid. Use [\"literal\", {...}] instead.' : `Expected an array, but found ${typeof t} instead.`);\n      }\n\n      concat(t, e, r) {\n        const n = \"number\" == typeof t ? this.path.concat(t) : this.path,\n              i = r ? this.scope.concat(r) : this.scope;\n        return new we(this.registry, n, e || null, i, this.errors);\n      }\n\n      error(t) {\n        for (var _len3 = arguments.length, e = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n          e[_key3 - 1] = arguments[_key3];\n        }\n\n        const r = `${this.key}${e.map(t => `[${t}]`).join(\"\")}`;\n        this.errors.push(new ut(r, t));\n      }\n\n      checkSubtype(t, e) {\n        const r = kt(t, e);\n        return r && this.error(r), r;\n      }\n\n    }\n\n    function _e(t) {\n      if (t instanceof be) return _e(t.boundExpression);\n      if (t instanceof Wt && \"error\" === t.name) return !1;\n      if (t instanceof Qt) return !1;\n      if (t instanceof me) return !1;\n      const e = t instanceof Xt || t instanceof Kt;\n      let r = !0;\n      return t.eachChild(t => {\n        r = e ? r && _e(t) : r && t instanceof qt;\n      }), !!r && ge(t) && ve(t, [\"zoom\", \"heatmap-density\", \"line-progress\", \"accumulated\", \"is-supported-script\"]);\n    }\n\n    function Ae(t, e) {\n      const r = t.length - 1;\n      let n,\n          i,\n          s = 0,\n          a = r,\n          o = 0;\n\n      for (; s <= a;) if (o = Math.floor((s + a) / 2), n = t[o], i = t[o + 1], n <= e) {\n        if (o === r || e < i) return o;\n        s = o + 1;\n      } else {\n        if (!(n > e)) throw new jt(\"Input is not a number.\");\n        a = o - 1;\n      }\n\n      return 0;\n    }\n\n    class ke {\n      constructor(t, e, r) {\n        this.type = t, this.input = e, this.labels = [], this.outputs = [];\n\n        for (const [t, e] of r) this.labels.push(t), this.outputs.push(e);\n      }\n\n      static parse(t, e) {\n        if (t.length - 1 < 4) return e.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);\n        if ((t.length - 1) % 2 != 0) return e.error(\"Expected an even number of arguments.\");\n        const r = e.parse(t[1], 1, pt);\n        if (!r) return null;\n        const n = [];\n        let i = null;\n        e.expectedType && \"value\" !== e.expectedType.kind && (i = e.expectedType);\n\n        for (let r = 1; r < t.length; r += 2) {\n          const s = 1 === r ? -1 / 0 : t[r],\n                a = t[r + 1],\n                o = r,\n                l = r + 1;\n          if (\"number\" != typeof s) return e.error('Input/output pairs for \"step\" expressions must be defined using literal numeric values (not computed expressions) for the input values.', o);\n          if (n.length && n[n.length - 1][0] >= s) return e.error('Input/output pairs for \"step\" expressions must be arranged with input values in strictly ascending order.', o);\n          const u = e.parse(a, l, i);\n          if (!u) return null;\n          i = i || u.type, n.push([s, u]);\n        }\n\n        return new ke(i, r, n);\n      }\n\n      evaluate(t) {\n        const e = this.labels,\n              r = this.outputs;\n        if (1 === e.length) return r[0].evaluate(t);\n        const n = this.input.evaluate(t);\n        if (n <= e[0]) return r[0].evaluate(t);\n        const i = e.length;\n        return n >= e[i - 1] ? r[i - 1].evaluate(t) : r[Ae(e, n)].evaluate(t);\n      }\n\n      eachChild(t) {\n        t(this.input);\n\n        for (const e of this.outputs) t(e);\n      }\n\n      outputDefined() {\n        return this.outputs.every(t => t.outputDefined());\n      }\n\n      serialize() {\n        const t = [\"step\", this.input.serialize()];\n\n        for (let e = 0; e < this.labels.length; e++) e > 0 && t.push(this.labels[e]), t.push(this.outputs[e].serialize());\n\n        return t;\n      }\n\n    }\n\n    function Se(t, e, r) {\n      return t * (1 - r) + e * r;\n    }\n\n    var ze = Object.freeze({\n      __proto__: null,\n      number: Se,\n      color: function (t, e, r) {\n        return new Et(Se(t.r, e.r, r), Se(t.g, e.g, r), Se(t.b, e.b, r), Se(t.a, e.a, r));\n      },\n      array: function (t, e, r) {\n        return t.map((t, n) => Se(t, e[n], r));\n      }\n    });\n    const Ie = .95047,\n          Me = 1.08883,\n          Be = 4 / 29,\n          Ce = 6 / 29,\n          Pe = 3 * Ce * Ce,\n          Ve = Math.PI / 180,\n          Ee = 180 / Math.PI;\n\n    function Fe(t) {\n      return t > .008856451679035631 ? Math.pow(t, 1 / 3) : t / Pe + Be;\n    }\n\n    function Te(t) {\n      return t > Ce ? t * t * t : Pe * (t - Be);\n    }\n\n    function Le(t) {\n      return 255 * (t <= .0031308 ? 12.92 * t : 1.055 * Math.pow(t, 1 / 2.4) - .055);\n    }\n\n    function De(t) {\n      return (t /= 255) <= .04045 ? t / 12.92 : Math.pow((t + .055) / 1.055, 2.4);\n    }\n\n    function $e(t) {\n      const e = De(t.r),\n            r = De(t.g),\n            n = De(t.b),\n            i = Fe((.4124564 * e + .3575761 * r + .1804375 * n) / Ie),\n            s = Fe((.2126729 * e + .7151522 * r + .072175 * n) / 1);\n      return {\n        l: 116 * s - 16,\n        a: 500 * (i - s),\n        b: 200 * (s - Fe((.0193339 * e + .119192 * r + .9503041 * n) / Me)),\n        alpha: t.a\n      };\n    }\n\n    function Oe(t) {\n      let e = (t.l + 16) / 116,\n          r = isNaN(t.a) ? e : e + t.a / 500,\n          n = isNaN(t.b) ? e : e - t.b / 200;\n      return e = 1 * Te(e), r = Ie * Te(r), n = Me * Te(n), new Et(Le(3.2404542 * r - 1.5371385 * e - .4985314 * n), Le(-.969266 * r + 1.8760108 * e + .041556 * n), Le(.0556434 * r - .2040259 * e + 1.0572252 * n), t.alpha);\n    }\n\n    function Re(t, e, r) {\n      const n = e - t;\n      return t + r * (n > 180 || n < -180 ? n - 360 * Math.round(n / 360) : n);\n    }\n\n    const Ue = {\n      forward: $e,\n      reverse: Oe,\n      interpolate: function (t, e, r) {\n        return {\n          l: Se(t.l, e.l, r),\n          a: Se(t.a, e.a, r),\n          b: Se(t.b, e.b, r),\n          alpha: Se(t.alpha, e.alpha, r)\n        };\n      }\n    },\n          qe = {\n      forward: function (t) {\n        const {\n          l: e,\n          a: r,\n          b: n\n        } = $e(t),\n              i = Math.atan2(n, r) * Ee;\n        return {\n          h: i < 0 ? i + 360 : i,\n          c: Math.sqrt(r * r + n * n),\n          l: e,\n          alpha: t.a\n        };\n      },\n      reverse: function (t) {\n        const e = t.h * Ve,\n              r = t.c;\n        return Oe({\n          l: t.l,\n          a: Math.cos(e) * r,\n          b: Math.sin(e) * r,\n          alpha: t.alpha\n        });\n      },\n      interpolate: function (t, e, r) {\n        return {\n          h: Re(t.h, e.h, r),\n          c: Se(t.c, e.c, r),\n          l: Se(t.l, e.l, r),\n          alpha: Se(t.alpha, e.alpha, r)\n        };\n      }\n    };\n    var je = Object.freeze({\n      __proto__: null,\n      lab: Ue,\n      hcl: qe\n    });\n\n    class Ne {\n      constructor(t, e, r, n, i) {\n        this.type = t, this.operator = e, this.interpolation = r, this.input = n, this.labels = [], this.outputs = [];\n\n        for (const [t, e] of i) this.labels.push(t), this.outputs.push(e);\n      }\n\n      static interpolationFactor(t, r, n, i) {\n        let s = 0;\n        if (\"exponential\" === t.name) s = Ke(r, t.base, n, i);else if (\"linear\" === t.name) s = Ke(r, 1, n, i);else if (\"cubic-bezier\" === t.name) {\n          const a = t.controlPoints;\n          s = new e(a[0], a[1], a[2], a[3]).solve(Ke(r, 1, n, i));\n        }\n        return s;\n      }\n\n      static parse(t, e) {\n        let [r, n, i, ...s] = t;\n        if (!Array.isArray(n) || 0 === n.length) return e.error(\"Expected an interpolation type expression.\", 1);\n        if (\"linear\" === n[0]) n = {\n          name: \"linear\"\n        };else if (\"exponential\" === n[0]) {\n          const t = n[1];\n          if (\"number\" != typeof t) return e.error(\"Exponential interpolation requires a numeric base.\", 1, 1);\n          n = {\n            name: \"exponential\",\n            base: t\n          };\n        } else {\n          if (\"cubic-bezier\" !== n[0]) return e.error(`Unknown interpolation type ${String(n[0])}`, 1, 0);\n          {\n            const t = n.slice(1);\n            if (4 !== t.length || t.some(t => \"number\" != typeof t || t < 0 || t > 1)) return e.error(\"Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.\", 1);\n            n = {\n              name: \"cubic-bezier\",\n              controlPoints: t\n            };\n          }\n        }\n        if (t.length - 1 < 4) return e.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);\n        if ((t.length - 1) % 2 != 0) return e.error(\"Expected an even number of arguments.\");\n        if (i = e.parse(i, 2, pt), !i) return null;\n        const a = [];\n        let o = null;\n        \"interpolate-hcl\" === r || \"interpolate-lab\" === r ? o = yt : e.expectedType && \"value\" !== e.expectedType.kind && (o = e.expectedType);\n\n        for (let t = 0; t < s.length; t += 2) {\n          const r = s[t],\n                n = s[t + 1],\n                i = t + 3,\n                l = t + 4;\n          if (\"number\" != typeof r) return e.error('Input/output pairs for \"interpolate\" expressions must be defined using literal numeric values (not computed expressions) for the input values.', i);\n          if (a.length && a[a.length - 1][0] >= r) return e.error('Input/output pairs for \"interpolate\" expressions must be arranged with input values in strictly ascending order.', i);\n          const u = e.parse(n, l, o);\n          if (!u) return null;\n          o = o || u.type, a.push([r, u]);\n        }\n\n        return \"number\" === o.kind || \"color\" === o.kind || \"array\" === o.kind && \"number\" === o.itemType.kind && \"number\" == typeof o.N ? new Ne(o, r, n, i, a) : e.error(`Type ${_t(o)} is not interpolatable.`);\n      }\n\n      evaluate(t) {\n        const e = this.labels,\n              r = this.outputs;\n        if (1 === e.length) return r[0].evaluate(t);\n        const n = this.input.evaluate(t);\n        if (n <= e[0]) return r[0].evaluate(t);\n        const i = e.length;\n        if (n >= e[i - 1]) return r[i - 1].evaluate(t);\n        const s = Ae(e, n),\n              a = Ne.interpolationFactor(this.interpolation, n, e[s], e[s + 1]),\n              o = r[s].evaluate(t),\n              l = r[s + 1].evaluate(t);\n        return \"interpolate\" === this.operator ? ze[this.type.kind.toLowerCase()](o, l, a) : \"interpolate-hcl\" === this.operator ? qe.reverse(qe.interpolate(qe.forward(o), qe.forward(l), a)) : Ue.reverse(Ue.interpolate(Ue.forward(o), Ue.forward(l), a));\n      }\n\n      eachChild(t) {\n        t(this.input);\n\n        for (const e of this.outputs) t(e);\n      }\n\n      outputDefined() {\n        return this.outputs.every(t => t.outputDefined());\n      }\n\n      serialize() {\n        let t;\n        t = \"linear\" === this.interpolation.name ? [\"linear\"] : \"exponential\" === this.interpolation.name ? 1 === this.interpolation.base ? [\"linear\"] : [\"exponential\", this.interpolation.base] : [\"cubic-bezier\"].concat(this.interpolation.controlPoints);\n        const e = [this.operator, t, this.input.serialize()];\n\n        for (let t = 0; t < this.labels.length; t++) e.push(this.labels[t], this.outputs[t].serialize());\n\n        return e;\n      }\n\n    }\n\n    function Ke(t, e, r, n) {\n      const i = n - r,\n            s = t - r;\n      return 0 === i ? 0 : 1 === e ? s / i : (Math.pow(e, s) - 1) / (Math.pow(e, i) - 1);\n    }\n\n    class Ze {\n      constructor(t, e) {\n        this.type = t, this.args = e;\n      }\n\n      static parse(t, e) {\n        if (t.length < 2) return e.error(\"Expectected at least one argument.\");\n        let r = null;\n        const n = e.expectedType;\n        n && \"value\" !== n.kind && (r = n);\n        const i = [];\n\n        for (const n of t.slice(1)) {\n          const t = e.parse(n, 1 + i.length, r, void 0, {\n            typeAnnotation: \"omit\"\n          });\n          if (!t) return null;\n          r = r || t.type, i.push(t);\n        }\n\n        const s = n && i.some(t => kt(n, t.type));\n        return new Ze(s ? gt : r, i);\n      }\n\n      evaluate(t) {\n        let e,\n            r = null,\n            n = 0;\n\n        for (const i of this.args) if (n++, r = i.evaluate(t), r && r instanceof Dt && !r.available && (e || (e = r.name), r = null, n === this.args.length && (r = e)), null !== r) break;\n\n        return r;\n      }\n\n      eachChild(t) {\n        this.args.forEach(t);\n      }\n\n      outputDefined() {\n        return this.args.every(t => t.outputDefined());\n      }\n\n      serialize() {\n        const t = [\"coalesce\"];\n        return this.eachChild(e => {\n          t.push(e.serialize());\n        }), t;\n      }\n\n    }\n\n    class Ge {\n      constructor(t, e) {\n        this.type = e.type, this.bindings = [].concat(t), this.result = e;\n      }\n\n      evaluate(t) {\n        return this.result.evaluate(t);\n      }\n\n      eachChild(t) {\n        for (const e of this.bindings) t(e[1]);\n\n        t(this.result);\n      }\n\n      static parse(t, e) {\n        if (t.length < 4) return e.error(`Expected at least 3 arguments, but found ${t.length - 1} instead.`);\n        const r = [];\n\n        for (let n = 1; n < t.length - 1; n += 2) {\n          const i = t[n];\n          if (\"string\" != typeof i) return e.error(`Expected string, but found ${typeof i} instead.`, n);\n          if (/[^a-zA-Z0-9_]/.test(i)) return e.error(\"Variable names must contain only alphanumeric characters or '_'.\", n);\n          const s = e.parse(t[n + 1], n + 1);\n          if (!s) return null;\n          r.push([i, s]);\n        }\n\n        const n = e.parse(t[t.length - 1], t.length - 1, e.expectedType, r);\n        return n ? new Ge(r, n) : null;\n      }\n\n      outputDefined() {\n        return this.result.outputDefined();\n      }\n\n      serialize() {\n        const t = [\"let\"];\n\n        for (const [e, r] of this.bindings) t.push(e, r.serialize());\n\n        return t.push(this.result.serialize()), t;\n      }\n\n    }\n\n    class Je {\n      constructor(t, e, r) {\n        this.type = t, this.index = e, this.input = r;\n      }\n\n      static parse(t, e) {\n        if (3 !== t.length) return e.error(`Expected 2 arguments, but found ${t.length - 1} instead.`);\n        const r = e.parse(t[1], 1, pt),\n              n = e.parse(t[2], 2, wt(e.expectedType || gt));\n        return r && n ? new Je(n.type.itemType, r, n) : null;\n      }\n\n      evaluate(t) {\n        const e = this.index.evaluate(t),\n              r = this.input.evaluate(t);\n        if (e < 0) throw new jt(`Array index out of bounds: ${e} < 0.`);\n        if (e >= r.length) throw new jt(`Array index out of bounds: ${e} > ${r.length - 1}.`);\n        if (e !== Math.floor(e)) throw new jt(`Array index must be an integer, but found ${e} instead.`);\n        return r[e];\n      }\n\n      eachChild(t) {\n        t(this.index), t(this.input);\n      }\n\n      outputDefined() {\n        return !1;\n      }\n\n      serialize() {\n        return [\"at\", this.index.serialize(), this.input.serialize()];\n      }\n\n    }\n\n    class Xe {\n      constructor(t, e) {\n        this.type = dt, this.needle = t, this.haystack = e;\n      }\n\n      static parse(t, e) {\n        if (3 !== t.length) return e.error(`Expected 2 arguments, but found ${t.length - 1} instead.`);\n        const r = e.parse(t[1], 1, gt),\n              n = e.parse(t[2], 2, gt);\n        return r && n ? St(r.type, [dt, ft, pt, ht, gt]) ? new Xe(r, n) : e.error(`Expected first argument to be of type boolean, string, number or null, but found ${_t(r.type)} instead`) : null;\n      }\n\n      evaluate(t) {\n        const e = this.needle.evaluate(t),\n              r = this.haystack.evaluate(t);\n        if (!r) return !1;\n        if (!zt(e, [\"boolean\", \"string\", \"number\", \"null\"])) throw new jt(`Expected first argument to be of type boolean, string, number or null, but found ${_t(Rt(e))} instead.`);\n        if (!zt(r, [\"string\", \"array\"])) throw new jt(`Expected second argument to be of type array or string, but found ${_t(Rt(r))} instead.`);\n        return r.indexOf(e) >= 0;\n      }\n\n      eachChild(t) {\n        t(this.needle), t(this.haystack);\n      }\n\n      outputDefined() {\n        return !0;\n      }\n\n      serialize() {\n        return [\"in\", this.needle.serialize(), this.haystack.serialize()];\n      }\n\n    }\n\n    class Ye {\n      constructor(t, e, r) {\n        this.type = pt, this.needle = t, this.haystack = e, this.fromIndex = r;\n      }\n\n      static parse(t, e) {\n        if (t.length <= 2 || t.length >= 5) return e.error(`Expected 3 or 4 arguments, but found ${t.length - 1} instead.`);\n        const r = e.parse(t[1], 1, gt),\n              n = e.parse(t[2], 2, gt);\n        if (!r || !n) return null;\n        if (!St(r.type, [dt, ft, pt, ht, gt])) return e.error(`Expected first argument to be of type boolean, string, number or null, but found ${_t(r.type)} instead`);\n\n        if (4 === t.length) {\n          const i = e.parse(t[3], 3, pt);\n          return i ? new Ye(r, n, i) : null;\n        }\n\n        return new Ye(r, n);\n      }\n\n      evaluate(t) {\n        const e = this.needle.evaluate(t),\n              r = this.haystack.evaluate(t);\n        if (!zt(e, [\"boolean\", \"string\", \"number\", \"null\"])) throw new jt(`Expected first argument to be of type boolean, string, number or null, but found ${_t(Rt(e))} instead.`);\n        if (!zt(r, [\"string\", \"array\"])) throw new jt(`Expected second argument to be of type array or string, but found ${_t(Rt(r))} instead.`);\n\n        if (this.fromIndex) {\n          const n = this.fromIndex.evaluate(t);\n          return r.indexOf(e, n);\n        }\n\n        return r.indexOf(e);\n      }\n\n      eachChild(t) {\n        t(this.needle), t(this.haystack), this.fromIndex && t(this.fromIndex);\n      }\n\n      outputDefined() {\n        return !1;\n      }\n\n      serialize() {\n        if (null != this.fromIndex && void 0 !== this.fromIndex) {\n          const t = this.fromIndex.serialize();\n          return [\"index-of\", this.needle.serialize(), this.haystack.serialize(), t];\n        }\n\n        return [\"index-of\", this.needle.serialize(), this.haystack.serialize()];\n      }\n\n    }\n\n    class He {\n      constructor(t, e, r, n, i, s) {\n        this.inputType = t, this.type = e, this.input = r, this.cases = n, this.outputs = i, this.otherwise = s;\n      }\n\n      static parse(t, e) {\n        if (t.length < 5) return e.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);\n        if (t.length % 2 != 1) return e.error(\"Expected an even number of arguments.\");\n        let r, n;\n        e.expectedType && \"value\" !== e.expectedType.kind && (n = e.expectedType);\n        const i = {},\n              s = [];\n\n        for (let a = 2; a < t.length - 1; a += 2) {\n          let o = t[a];\n          const l = t[a + 1];\n          Array.isArray(o) || (o = [o]);\n          const u = e.concat(a);\n          if (0 === o.length) return u.error(\"Expected at least one branch label.\");\n\n          for (const t of o) {\n            if (\"number\" != typeof t && \"string\" != typeof t) return u.error(\"Branch labels must be numbers or strings.\");\n            if (\"number\" == typeof t && Math.abs(t) > Number.MAX_SAFE_INTEGER) return u.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);\n            if (\"number\" == typeof t && Math.floor(t) !== t) return u.error(\"Numeric branch labels must be integer values.\");\n\n            if (r) {\n              if (u.checkSubtype(r, Rt(t))) return null;\n            } else r = Rt(t);\n\n            if (void 0 !== i[String(t)]) return u.error(\"Branch labels must be unique.\");\n            i[String(t)] = s.length;\n          }\n\n          const c = e.parse(l, a, n);\n          if (!c) return null;\n          n = n || c.type, s.push(c);\n        }\n\n        const a = e.parse(t[1], 1, gt);\n        if (!a) return null;\n        const o = e.parse(t[t.length - 1], t.length - 1, n);\n        return o ? \"value\" !== a.type.kind && e.concat(1).checkSubtype(r, a.type) ? null : new He(r, n, a, i, s, o) : null;\n      }\n\n      evaluate(t) {\n        const e = this.input.evaluate(t);\n        return (Rt(e) === this.inputType && this.outputs[this.cases[e]] || this.otherwise).evaluate(t);\n      }\n\n      eachChild(t) {\n        t(this.input), this.outputs.forEach(t), t(this.otherwise);\n      }\n\n      outputDefined() {\n        return this.outputs.every(t => t.outputDefined()) && this.otherwise.outputDefined();\n      }\n\n      serialize() {\n        const t = [\"match\", this.input.serialize()],\n              e = Object.keys(this.cases).sort(),\n              r = [],\n              n = {};\n\n        for (const t of e) {\n          const e = n[this.cases[t]];\n          void 0 === e ? (n[this.cases[t]] = r.length, r.push([this.cases[t], [t]])) : r[e][1].push(t);\n        }\n\n        const i = t => \"number\" === this.inputType.kind ? Number(t) : t;\n\n        for (const [e, n] of r) t.push(1 === n.length ? i(n[0]) : n.map(i)), t.push(this.outputs[e].serialize());\n\n        return t.push(this.otherwise.serialize()), t;\n      }\n\n    }\n\n    class We {\n      constructor(t, e, r) {\n        this.type = t, this.branches = e, this.otherwise = r;\n      }\n\n      static parse(t, e) {\n        if (t.length < 4) return e.error(`Expected at least 3 arguments, but found only ${t.length - 1}.`);\n        if (t.length % 2 != 0) return e.error(\"Expected an odd number of arguments.\");\n        let r;\n        e.expectedType && \"value\" !== e.expectedType.kind && (r = e.expectedType);\n        const n = [];\n\n        for (let i = 1; i < t.length - 1; i += 2) {\n          const s = e.parse(t[i], i, dt);\n          if (!s) return null;\n          const a = e.parse(t[i + 1], i + 1, r);\n          if (!a) return null;\n          n.push([s, a]), r = r || a.type;\n        }\n\n        const i = e.parse(t[t.length - 1], t.length - 1, r);\n        return i ? new We(r, n, i) : null;\n      }\n\n      evaluate(t) {\n        for (const [e, r] of this.branches) if (e.evaluate(t)) return r.evaluate(t);\n\n        return this.otherwise.evaluate(t);\n      }\n\n      eachChild(t) {\n        for (const [e, r] of this.branches) t(e), t(r);\n\n        t(this.otherwise);\n      }\n\n      outputDefined() {\n        return this.branches.every(_ref3 => {\n          let [t, e] = _ref3;\n          return e.outputDefined();\n        }) && this.otherwise.outputDefined();\n      }\n\n      serialize() {\n        const t = [\"case\"];\n        return this.eachChild(e => {\n          t.push(e.serialize());\n        }), t;\n      }\n\n    }\n\n    class Qe {\n      constructor(t, e, r, n) {\n        this.type = t, this.input = e, this.beginIndex = r, this.endIndex = n;\n      }\n\n      static parse(t, e) {\n        if (t.length <= 2 || t.length >= 5) return e.error(`Expected 3 or 4 arguments, but found ${t.length - 1} instead.`);\n        const r = e.parse(t[1], 1, gt),\n              n = e.parse(t[2], 2, pt);\n        if (!r || !n) return null;\n        if (!St(r.type, [wt(gt), ft, gt])) return e.error(`Expected first argument to be of type array or string, but found ${_t(r.type)} instead`);\n\n        if (4 === t.length) {\n          const i = e.parse(t[3], 3, pt);\n          return i ? new Qe(r.type, r, n, i) : null;\n        }\n\n        return new Qe(r.type, r, n);\n      }\n\n      evaluate(t) {\n        const e = this.input.evaluate(t),\n              r = this.beginIndex.evaluate(t);\n        if (!zt(e, [\"string\", \"array\"])) throw new jt(`Expected first argument to be of type array or string, but found ${_t(Rt(e))} instead.`);\n\n        if (this.endIndex) {\n          const n = this.endIndex.evaluate(t);\n          return e.slice(r, n);\n        }\n\n        return e.slice(r);\n      }\n\n      eachChild(t) {\n        t(this.input), t(this.beginIndex), this.endIndex && t(this.endIndex);\n      }\n\n      outputDefined() {\n        return !1;\n      }\n\n      serialize() {\n        if (null != this.endIndex && void 0 !== this.endIndex) {\n          const t = this.endIndex.serialize();\n          return [\"slice\", this.input.serialize(), this.beginIndex.serialize(), t];\n        }\n\n        return [\"slice\", this.input.serialize(), this.beginIndex.serialize()];\n      }\n\n    }\n\n    function tr(t, e) {\n      return \"==\" === t || \"!=\" === t ? \"boolean\" === e.kind || \"string\" === e.kind || \"number\" === e.kind || \"null\" === e.kind || \"value\" === e.kind : \"string\" === e.kind || \"number\" === e.kind || \"value\" === e.kind;\n    }\n\n    function er(t, e, r, n) {\n      return 0 === n.compare(e, r);\n    }\n\n    function rr(t, e, r) {\n      const n = \"==\" !== t && \"!=\" !== t;\n      return class i {\n        constructor(t, e, r) {\n          this.type = dt, this.lhs = t, this.rhs = e, this.collator = r, this.hasUntypedArgument = \"value\" === t.type.kind || \"value\" === e.type.kind;\n        }\n\n        static parse(t, e) {\n          if (3 !== t.length && 4 !== t.length) return e.error(\"Expected two or three arguments.\");\n          const r = t[0];\n          let s = e.parse(t[1], 1, gt);\n          if (!s) return null;\n          if (!tr(r, s.type)) return e.concat(1).error(`\"${r}\" comparisons are not supported for type '${_t(s.type)}'.`);\n          let a = e.parse(t[2], 2, gt);\n          if (!a) return null;\n          if (!tr(r, a.type)) return e.concat(2).error(`\"${r}\" comparisons are not supported for type '${_t(a.type)}'.`);\n          if (s.type.kind !== a.type.kind && \"value\" !== s.type.kind && \"value\" !== a.type.kind) return e.error(`Cannot compare types '${_t(s.type)}' and '${_t(a.type)}'.`);\n          n && (\"value\" === s.type.kind && \"value\" !== a.type.kind ? s = new Kt(a.type, [s]) : \"value\" !== s.type.kind && \"value\" === a.type.kind && (a = new Kt(s.type, [a])));\n          let o = null;\n\n          if (4 === t.length) {\n            if (\"string\" !== s.type.kind && \"string\" !== a.type.kind && \"value\" !== s.type.kind && \"value\" !== a.type.kind) return e.error(\"Cannot use collator to compare non-string types.\");\n            if (o = e.parse(t[3], 3, xt), !o) return null;\n          }\n\n          return new i(s, a, o);\n        }\n\n        evaluate(i) {\n          const s = this.lhs.evaluate(i),\n                a = this.rhs.evaluate(i);\n\n          if (n && this.hasUntypedArgument) {\n            const e = Rt(s),\n                  r = Rt(a);\n            if (e.kind !== r.kind || \"string\" !== e.kind && \"number\" !== e.kind) throw new jt(`Expected arguments for \"${t}\" to be (string, string) or (number, number), but found (${e.kind}, ${r.kind}) instead.`);\n          }\n\n          if (this.collator && !n && this.hasUntypedArgument) {\n            const t = Rt(s),\n                  r = Rt(a);\n            if (\"string\" !== t.kind || \"string\" !== r.kind) return e(i, s, a);\n          }\n\n          return this.collator ? r(i, s, a, this.collator.evaluate(i)) : e(i, s, a);\n        }\n\n        eachChild(t) {\n          t(this.lhs), t(this.rhs), this.collator && t(this.collator);\n        }\n\n        outputDefined() {\n          return !0;\n        }\n\n        serialize() {\n          const e = [t];\n          return this.eachChild(t => {\n            e.push(t.serialize());\n          }), e;\n        }\n\n      };\n    }\n\n    const nr = rr(\"==\", function (t, e, r) {\n      return e === r;\n    }, er),\n          ir = rr(\"!=\", function (t, e, r) {\n      return e !== r;\n    }, function (t, e, r, n) {\n      return !er(0, e, r, n);\n    }),\n          sr = rr(\"<\", function (t, e, r) {\n      return e < r;\n    }, function (t, e, r, n) {\n      return n.compare(e, r) < 0;\n    }),\n          ar = rr(\">\", function (t, e, r) {\n      return e > r;\n    }, function (t, e, r, n) {\n      return n.compare(e, r) > 0;\n    }),\n          or = rr(\"<=\", function (t, e, r) {\n      return e <= r;\n    }, function (t, e, r, n) {\n      return n.compare(e, r) <= 0;\n    }),\n          lr = rr(\">=\", function (t, e, r) {\n      return e >= r;\n    }, function (t, e, r, n) {\n      return n.compare(e, r) >= 0;\n    });\n\n    class ur {\n      constructor(t, e, r, n, i) {\n        this.type = ft, this.number = t, this.locale = e, this.currency = r, this.minFractionDigits = n, this.maxFractionDigits = i;\n      }\n\n      static parse(t, e) {\n        if (3 !== t.length) return e.error(\"Expected two arguments.\");\n        const r = e.parse(t[1], 1, pt);\n        if (!r) return null;\n        const n = t[2];\n        if (\"object\" != typeof n || Array.isArray(n)) return e.error(\"NumberFormat options argument must be an object.\");\n        let i = null;\n        if (n.locale && (i = e.parse(n.locale, 1, ft), !i)) return null;\n        let s = null;\n        if (n.currency && (s = e.parse(n.currency, 1, ft), !s)) return null;\n        let a = null;\n        if (n[\"min-fraction-digits\"] && (a = e.parse(n[\"min-fraction-digits\"], 1, pt), !a)) return null;\n        let o = null;\n        return n[\"max-fraction-digits\"] && (o = e.parse(n[\"max-fraction-digits\"], 1, pt), !o) ? null : new ur(r, i, s, a, o);\n      }\n\n      evaluate(t) {\n        return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t) : [], {\n          style: this.currency ? \"currency\" : \"decimal\",\n          currency: this.currency ? this.currency.evaluate(t) : void 0,\n          minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t) : void 0,\n          maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t) : void 0\n        }).format(this.number.evaluate(t));\n      }\n\n      eachChild(t) {\n        t(this.number), this.locale && t(this.locale), this.currency && t(this.currency), this.minFractionDigits && t(this.minFractionDigits), this.maxFractionDigits && t(this.maxFractionDigits);\n      }\n\n      outputDefined() {\n        return !1;\n      }\n\n      serialize() {\n        const t = {};\n        return this.locale && (t.locale = this.locale.serialize()), this.currency && (t.currency = this.currency.serialize()), this.minFractionDigits && (t[\"min-fraction-digits\"] = this.minFractionDigits.serialize()), this.maxFractionDigits && (t[\"max-fraction-digits\"] = this.maxFractionDigits.serialize()), [\"number-format\", this.number.serialize(), t];\n      }\n\n    }\n\n    class cr {\n      constructor(t) {\n        this.type = pt, this.input = t;\n      }\n\n      static parse(t, e) {\n        if (2 !== t.length) return e.error(`Expected 1 argument, but found ${t.length - 1} instead.`);\n        const r = e.parse(t[1], 1);\n        return r ? \"array\" !== r.type.kind && \"string\" !== r.type.kind && \"value\" !== r.type.kind ? e.error(`Expected argument of type string or array, but found ${_t(r.type)} instead.`) : new cr(r) : null;\n      }\n\n      evaluate(t) {\n        const e = this.input.evaluate(t);\n        if (\"string\" == typeof e) return e.length;\n        if (Array.isArray(e)) return e.length;\n        throw new jt(`Expected value to be of type string or array, but found ${_t(Rt(e))} instead.`);\n      }\n\n      eachChild(t) {\n        t(this.input);\n      }\n\n      outputDefined() {\n        return !1;\n      }\n\n      serialize() {\n        const t = [\"length\"];\n        return this.eachChild(e => {\n          t.push(e.serialize());\n        }), t;\n      }\n\n    }\n\n    const hr = {\n      \"==\": nr,\n      \"!=\": ir,\n      \">\": ar,\n      \"<\": sr,\n      \">=\": lr,\n      \"<=\": or,\n      array: Kt,\n      at: Je,\n      boolean: Kt,\n      case: We,\n      coalesce: Ze,\n      collator: Qt,\n      format: Zt,\n      image: Gt,\n      in: Xe,\n      \"index-of\": Ye,\n      interpolate: Ne,\n      \"interpolate-hcl\": Ne,\n      \"interpolate-lab\": Ne,\n      length: cr,\n      let: Ge,\n      literal: qt,\n      match: He,\n      number: Kt,\n      \"number-format\": ur,\n      object: Kt,\n      slice: Qe,\n      step: ke,\n      string: Kt,\n      \"to-boolean\": Xt,\n      \"to-color\": Xt,\n      \"to-number\": Xt,\n      \"to-string\": Xt,\n      var: be,\n      within: me\n    };\n\n    function pr(t, _ref4) {\n      let [e, r, n, i] = _ref4;\n      e = e.evaluate(t), r = r.evaluate(t), n = n.evaluate(t);\n      const s = i ? i.evaluate(t) : 1,\n            a = $t(e, r, n, s);\n      if (a) throw new jt(a);\n      return new Et(e / 255 * s, r / 255 * s, n / 255 * s, s);\n    }\n\n    function fr(t, e) {\n      return t in e;\n    }\n\n    function dr(t, e) {\n      const r = e[t];\n      return void 0 === r ? null : r;\n    }\n\n    function yr(t) {\n      return {\n        type: t\n      };\n    }\n\n    function mr(t) {\n      return {\n        result: \"success\",\n        value: t\n      };\n    }\n\n    function gr(t) {\n      return {\n        result: \"error\",\n        value: t\n      };\n    }\n\n    function xr(t) {\n      return \"data-driven\" === t[\"property-type\"] || \"cross-faded-data-driven\" === t[\"property-type\"];\n    }\n\n    function vr(t) {\n      return !!t.expression && t.expression.parameters.indexOf(\"zoom\") > -1;\n    }\n\n    function br(t) {\n      return !!t.expression && t.expression.interpolated;\n    }\n\n    function wr(t) {\n      return t instanceof Number ? \"number\" : t instanceof String ? \"string\" : t instanceof Boolean ? \"boolean\" : Array.isArray(t) ? \"array\" : null === t ? \"null\" : typeof t;\n    }\n\n    function _r(t) {\n      return \"object\" == typeof t && null !== t && !Array.isArray(t);\n    }\n\n    function Ar(t) {\n      return t;\n    }\n\n    function kr(t, e) {\n      const r = \"color\" === e.type,\n            n = t.stops && \"object\" == typeof t.stops[0][0],\n            i = n || !(n || void 0 !== t.property),\n            s = t.type || (br(e) ? \"exponential\" : \"interval\");\n      if (r && ((t = at({}, t)).stops && (t.stops = t.stops.map(t => [t[0], Et.parse(t[1])])), t.default = Et.parse(t.default ? t.default : e.default)), t.colorSpace && \"rgb\" !== t.colorSpace && !je[t.colorSpace]) throw new Error(`Unknown color space: ${t.colorSpace}`);\n      let a, o, l;\n      if (\"exponential\" === s) a = Mr;else if (\"interval\" === s) a = Ir;else if (\"categorical\" === s) {\n        a = zr, o = Object.create(null);\n\n        for (const e of t.stops) o[e[0]] = e[1];\n\n        l = typeof t.stops[0][0];\n      } else {\n        if (\"identity\" !== s) throw new Error(`Unknown function type \"${s}\"`);\n        a = Br;\n      }\n\n      if (n) {\n        const r = {},\n              n = [];\n\n        for (let e = 0; e < t.stops.length; e++) {\n          const i = t.stops[e],\n                s = i[0].zoom;\n          void 0 === r[s] && (r[s] = {\n            zoom: s,\n            type: t.type,\n            property: t.property,\n            default: t.default,\n            stops: []\n          }, n.push(s)), r[s].stops.push([i[0].value, i[1]]);\n        }\n\n        const i = [];\n\n        for (const t of n) i.push([r[t].zoom, kr(r[t], e)]);\n\n        const s = {\n          name: \"linear\"\n        };\n        return {\n          kind: \"composite\",\n          interpolationType: s,\n          interpolationFactor: Ne.interpolationFactor.bind(void 0, s),\n          zoomStops: i.map(t => t[0]),\n          evaluate: (_ref5, n) => {\n            let {\n              zoom: r\n            } = _ref5;\n            return Mr({\n              stops: i,\n              base: t.base\n            }, e, r).evaluate(r, n);\n          }\n        };\n      }\n\n      if (i) {\n        const r = \"exponential\" === s ? {\n          name: \"exponential\",\n          base: void 0 !== t.base ? t.base : 1\n        } : null;\n        return {\n          kind: \"camera\",\n          interpolationType: r,\n          interpolationFactor: Ne.interpolationFactor.bind(void 0, r),\n          zoomStops: t.stops.map(t => t[0]),\n          evaluate: _ref6 => {\n            let {\n              zoom: r\n            } = _ref6;\n            return a(t, e, r, o, l);\n          }\n        };\n      }\n\n      return {\n        kind: \"source\",\n\n        evaluate(r, n) {\n          const i = n && n.properties ? n.properties[t.property] : void 0;\n          return void 0 === i ? Sr(t.default, e.default) : a(t, e, i, o, l);\n        }\n\n      };\n    }\n\n    function Sr(t, e, r) {\n      return void 0 !== t ? t : void 0 !== e ? e : void 0 !== r ? r : void 0;\n    }\n\n    function zr(t, e, r, n, i) {\n      return Sr(typeof r === i ? n[r] : void 0, t.default, e.default);\n    }\n\n    function Ir(t, e, r) {\n      if (\"number\" !== wr(r)) return Sr(t.default, e.default);\n      const n = t.stops.length;\n      if (1 === n) return t.stops[0][1];\n      if (r <= t.stops[0][0]) return t.stops[0][1];\n      if (r >= t.stops[n - 1][0]) return t.stops[n - 1][1];\n      const i = Ae(t.stops.map(t => t[0]), r);\n      return t.stops[i][1];\n    }\n\n    function Mr(t, e, r) {\n      const n = void 0 !== t.base ? t.base : 1;\n      if (\"number\" !== wr(r)) return Sr(t.default, e.default);\n      const i = t.stops.length;\n      if (1 === i) return t.stops[0][1];\n      if (r <= t.stops[0][0]) return t.stops[0][1];\n      if (r >= t.stops[i - 1][0]) return t.stops[i - 1][1];\n\n      const s = Ae(t.stops.map(t => t[0]), r),\n            a = function (t, e, r, n) {\n        const i = n - r,\n              s = t - r;\n        return 0 === i ? 0 : 1 === e ? s / i : (Math.pow(e, s) - 1) / (Math.pow(e, i) - 1);\n      }(r, n, t.stops[s][0], t.stops[s + 1][0]),\n            o = t.stops[s][1],\n            l = t.stops[s + 1][1];\n\n      let u = ze[e.type] || Ar;\n\n      if (t.colorSpace && \"rgb\" !== t.colorSpace) {\n        const e = je[t.colorSpace];\n\n        u = (t, r) => e.reverse(e.interpolate(e.forward(t), e.forward(r), a));\n      }\n\n      return \"function\" == typeof o.evaluate ? {\n        evaluate() {\n          for (var _len4 = arguments.length, t = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n            t[_key4] = arguments[_key4];\n          }\n\n          const e = o.evaluate.apply(void 0, t),\n                r = l.evaluate.apply(void 0, t);\n          if (void 0 !== e && void 0 !== r) return u(e, r, a);\n        }\n\n      } : u(o, l, a);\n    }\n\n    function Br(t, e, r) {\n      return \"color\" === e.type ? r = Et.parse(r) : \"formatted\" === e.type ? r = Lt.fromString(r.toString()) : \"resolvedImage\" === e.type ? r = Dt.fromString(r.toString()) : wr(r) === e.type || \"enum\" === e.type && e.values[r] || (r = void 0), Sr(r, t.default, e.default);\n    }\n\n    Wt.register(hr, {\n      error: [{\n        kind: \"error\"\n      }, [ft], (t, _ref7) => {\n        let [e] = _ref7;\n        throw new jt(e.evaluate(t));\n      }],\n      typeof: [ft, [gt], (t, _ref8) => {\n        let [e] = _ref8;\n        return _t(Rt(e.evaluate(t)));\n      }],\n      \"to-rgba\": [wt(pt, 4), [yt], (t, _ref9) => {\n        let [e] = _ref9;\n        return e.evaluate(t).toArray();\n      }],\n      rgb: [yt, [pt, pt, pt], pr],\n      rgba: [yt, [pt, pt, pt, pt], pr],\n      has: {\n        type: dt,\n        overloads: [[[ft], (t, _ref10) => {\n          let [e] = _ref10;\n          return fr(e.evaluate(t), t.properties());\n        }], [[ft, mt], (t, _ref11) => {\n          let [e, r] = _ref11;\n          return fr(e.evaluate(t), r.evaluate(t));\n        }]]\n      },\n      get: {\n        type: gt,\n        overloads: [[[ft], (t, _ref12) => {\n          let [e] = _ref12;\n          return dr(e.evaluate(t), t.properties());\n        }], [[ft, mt], (t, _ref13) => {\n          let [e, r] = _ref13;\n          return dr(e.evaluate(t), r.evaluate(t));\n        }]]\n      },\n      \"feature-state\": [gt, [ft], (t, _ref14) => {\n        let [e] = _ref14;\n        return dr(e.evaluate(t), t.featureState || {});\n      }],\n      properties: [mt, [], t => t.properties()],\n      \"geometry-type\": [ft, [], t => t.geometryType()],\n      id: [gt, [], t => t.id()],\n      zoom: [pt, [], t => t.globals.zoom],\n      \"heatmap-density\": [pt, [], t => t.globals.heatmapDensity || 0],\n      \"line-progress\": [pt, [], t => t.globals.lineProgress || 0],\n      accumulated: [gt, [], t => void 0 === t.globals.accumulated ? null : t.globals.accumulated],\n      \"+\": [pt, yr(pt), (t, e) => {\n        let r = 0;\n\n        for (const n of e) r += n.evaluate(t);\n\n        return r;\n      }],\n      \"*\": [pt, yr(pt), (t, e) => {\n        let r = 1;\n\n        for (const n of e) r *= n.evaluate(t);\n\n        return r;\n      }],\n      \"-\": {\n        type: pt,\n        overloads: [[[pt, pt], (t, _ref15) => {\n          let [e, r] = _ref15;\n          return e.evaluate(t) - r.evaluate(t);\n        }], [[pt], (t, _ref16) => {\n          let [e] = _ref16;\n          return -e.evaluate(t);\n        }]]\n      },\n      \"/\": [pt, [pt, pt], (t, _ref17) => {\n        let [e, r] = _ref17;\n        return e.evaluate(t) / r.evaluate(t);\n      }],\n      \"%\": [pt, [pt, pt], (t, _ref18) => {\n        let [e, r] = _ref18;\n        return e.evaluate(t) % r.evaluate(t);\n      }],\n      ln2: [pt, [], () => Math.LN2],\n      pi: [pt, [], () => Math.PI],\n      e: [pt, [], () => Math.E],\n      \"^\": [pt, [pt, pt], (t, _ref19) => {\n        let [e, r] = _ref19;\n        return Math.pow(e.evaluate(t), r.evaluate(t));\n      }],\n      sqrt: [pt, [pt], (t, _ref20) => {\n        let [e] = _ref20;\n        return Math.sqrt(e.evaluate(t));\n      }],\n      log10: [pt, [pt], (t, _ref21) => {\n        let [e] = _ref21;\n        return Math.log(e.evaluate(t)) / Math.LN10;\n      }],\n      ln: [pt, [pt], (t, _ref22) => {\n        let [e] = _ref22;\n        return Math.log(e.evaluate(t));\n      }],\n      log2: [pt, [pt], (t, _ref23) => {\n        let [e] = _ref23;\n        return Math.log(e.evaluate(t)) / Math.LN2;\n      }],\n      sin: [pt, [pt], (t, _ref24) => {\n        let [e] = _ref24;\n        return Math.sin(e.evaluate(t));\n      }],\n      cos: [pt, [pt], (t, _ref25) => {\n        let [e] = _ref25;\n        return Math.cos(e.evaluate(t));\n      }],\n      tan: [pt, [pt], (t, _ref26) => {\n        let [e] = _ref26;\n        return Math.tan(e.evaluate(t));\n      }],\n      asin: [pt, [pt], (t, _ref27) => {\n        let [e] = _ref27;\n        return Math.asin(e.evaluate(t));\n      }],\n      acos: [pt, [pt], (t, _ref28) => {\n        let [e] = _ref28;\n        return Math.acos(e.evaluate(t));\n      }],\n      atan: [pt, [pt], (t, _ref29) => {\n        let [e] = _ref29;\n        return Math.atan(e.evaluate(t));\n      }],\n      min: [pt, yr(pt), (t, e) => Math.min(...e.map(e => e.evaluate(t)))],\n      max: [pt, yr(pt), (t, e) => Math.max(...e.map(e => e.evaluate(t)))],\n      abs: [pt, [pt], (t, _ref30) => {\n        let [e] = _ref30;\n        return Math.abs(e.evaluate(t));\n      }],\n      round: [pt, [pt], (t, _ref31) => {\n        let [e] = _ref31;\n        const r = e.evaluate(t);\n        return r < 0 ? -Math.round(-r) : Math.round(r);\n      }],\n      floor: [pt, [pt], (t, _ref32) => {\n        let [e] = _ref32;\n        return Math.floor(e.evaluate(t));\n      }],\n      ceil: [pt, [pt], (t, _ref33) => {\n        let [e] = _ref33;\n        return Math.ceil(e.evaluate(t));\n      }],\n      \"filter-==\": [dt, [ft, gt], (t, _ref34) => {\n        let [e, r] = _ref34;\n        return t.properties()[e.value] === r.value;\n      }],\n      \"filter-id-==\": [dt, [gt], (t, _ref35) => {\n        let [e] = _ref35;\n        return t.id() === e.value;\n      }],\n      \"filter-type-==\": [dt, [ft], (t, _ref36) => {\n        let [e] = _ref36;\n        return t.geometryType() === e.value;\n      }],\n      \"filter-<\": [dt, [ft, gt], (t, _ref37) => {\n        let [e, r] = _ref37;\n        const n = t.properties()[e.value],\n              i = r.value;\n        return typeof n == typeof i && n < i;\n      }],\n      \"filter-id-<\": [dt, [gt], (t, _ref38) => {\n        let [e] = _ref38;\n        const r = t.id(),\n              n = e.value;\n        return typeof r == typeof n && r < n;\n      }],\n      \"filter->\": [dt, [ft, gt], (t, _ref39) => {\n        let [e, r] = _ref39;\n        const n = t.properties()[e.value],\n              i = r.value;\n        return typeof n == typeof i && n > i;\n      }],\n      \"filter-id->\": [dt, [gt], (t, _ref40) => {\n        let [e] = _ref40;\n        const r = t.id(),\n              n = e.value;\n        return typeof r == typeof n && r > n;\n      }],\n      \"filter-<=\": [dt, [ft, gt], (t, _ref41) => {\n        let [e, r] = _ref41;\n        const n = t.properties()[e.value],\n              i = r.value;\n        return typeof n == typeof i && n <= i;\n      }],\n      \"filter-id-<=\": [dt, [gt], (t, _ref42) => {\n        let [e] = _ref42;\n        const r = t.id(),\n              n = e.value;\n        return typeof r == typeof n && r <= n;\n      }],\n      \"filter->=\": [dt, [ft, gt], (t, _ref43) => {\n        let [e, r] = _ref43;\n        const n = t.properties()[e.value],\n              i = r.value;\n        return typeof n == typeof i && n >= i;\n      }],\n      \"filter-id->=\": [dt, [gt], (t, _ref44) => {\n        let [e] = _ref44;\n        const r = t.id(),\n              n = e.value;\n        return typeof r == typeof n && r >= n;\n      }],\n      \"filter-has\": [dt, [gt], (t, _ref45) => {\n        let [e] = _ref45;\n        return e.value in t.properties();\n      }],\n      \"filter-has-id\": [dt, [], t => null !== t.id() && void 0 !== t.id()],\n      \"filter-type-in\": [dt, [wt(ft)], (t, _ref46) => {\n        let [e] = _ref46;\n        return e.value.indexOf(t.geometryType()) >= 0;\n      }],\n      \"filter-id-in\": [dt, [wt(gt)], (t, _ref47) => {\n        let [e] = _ref47;\n        return e.value.indexOf(t.id()) >= 0;\n      }],\n      \"filter-in-small\": [dt, [ft, wt(gt)], (t, _ref48) => {\n        let [e, r] = _ref48;\n        return r.value.indexOf(t.properties()[e.value]) >= 0;\n      }],\n      \"filter-in-large\": [dt, [ft, wt(gt)], (t, _ref49) => {\n        let [e, r] = _ref49;\n        return function (t, e, r, n) {\n          for (; r <= n;) {\n            const i = r + n >> 1;\n            if (e[i] === t) return !0;\n            e[i] > t ? n = i - 1 : r = i + 1;\n          }\n\n          return !1;\n        }(t.properties()[e.value], r.value, 0, r.value.length - 1);\n      }],\n      all: {\n        type: dt,\n        overloads: [[[dt, dt], (t, _ref50) => {\n          let [e, r] = _ref50;\n          return e.evaluate(t) && r.evaluate(t);\n        }], [yr(dt), (t, e) => {\n          for (const r of e) if (!r.evaluate(t)) return !1;\n\n          return !0;\n        }]]\n      },\n      any: {\n        type: dt,\n        overloads: [[[dt, dt], (t, _ref51) => {\n          let [e, r] = _ref51;\n          return e.evaluate(t) || r.evaluate(t);\n        }], [yr(dt), (t, e) => {\n          for (const r of e) if (r.evaluate(t)) return !0;\n\n          return !1;\n        }]]\n      },\n      \"!\": [dt, [dt], (t, _ref52) => {\n        let [e] = _ref52;\n        return !e.evaluate(t);\n      }],\n      \"is-supported-script\": [dt, [ft], (t, _ref53) => {\n        let [e] = _ref53;\n        const r = t.globals && t.globals.isSupportedScript;\n        return !r || r(e.evaluate(t));\n      }],\n      upcase: [ft, [ft], (t, _ref54) => {\n        let [e] = _ref54;\n        return e.evaluate(t).toUpperCase();\n      }],\n      downcase: [ft, [ft], (t, _ref55) => {\n        let [e] = _ref55;\n        return e.evaluate(t).toLowerCase();\n      }],\n      concat: [ft, yr(gt), (t, e) => e.map(e => Ut(e.evaluate(t))).join(\"\")],\n      \"resolved-locale\": [ft, [xt], (t, _ref56) => {\n        let [e] = _ref56;\n        return e.evaluate(t).resolvedLocale();\n      }]\n    });\n\n    class Cr {\n      constructor(t, e) {\n        this.expression = t, this._warningHistory = {}, this._evaluator = new Ht(), this._defaultValue = e ? function (t) {\n          return \"color\" === t.type && _r(t.default) ? new Et(0, 0, 0, 0) : \"color\" === t.type ? Et.parse(t.default) || null : void 0 === t.default ? null : t.default;\n        }(e) : null, this._enumValues = e && \"enum\" === e.type ? e.values : null;\n      }\n\n      evaluateWithoutErrorHandling(t, e, r, n, i, s) {\n        return this._evaluator.globals = t, this._evaluator.feature = e, this._evaluator.featureState = r, this._evaluator.canonical = n, this._evaluator.availableImages = i || null, this._evaluator.formattedSection = s, this.expression.evaluate(this._evaluator);\n      }\n\n      evaluate(t, e, r, n, i, s) {\n        this._evaluator.globals = t, this._evaluator.feature = e || null, this._evaluator.featureState = r || null, this._evaluator.canonical = n, this._evaluator.availableImages = i || null, this._evaluator.formattedSection = s || null;\n\n        try {\n          const t = this.expression.evaluate(this._evaluator);\n          if (null == t || \"number\" == typeof t && t != t) return this._defaultValue;\n          if (this._enumValues && !(t in this._enumValues)) throw new jt(`Expected value to be one of ${Object.keys(this._enumValues).map(t => JSON.stringify(t)).join(\", \")}, but found ${JSON.stringify(t)} instead.`);\n          return t;\n        } catch (t) {\n          return this._warningHistory[t.message] || (this._warningHistory[t.message] = !0, \"undefined\" != typeof console && console.warn(t.message)), this._defaultValue;\n        }\n      }\n\n    }\n\n    function Pr(t) {\n      return Array.isArray(t) && t.length > 0 && \"string\" == typeof t[0] && t[0] in hr;\n    }\n\n    function Vr(t, e) {\n      const r = new we(hr, [], e ? function (t) {\n        const e = {\n          color: yt,\n          string: ft,\n          number: pt,\n          enum: ft,\n          boolean: dt,\n          formatted: vt,\n          resolvedImage: bt\n        };\n        return \"array\" === t.type ? wt(e[t.value] || gt, t.length) : e[t.type];\n      }(e) : void 0),\n            n = r.parse(t, void 0, void 0, void 0, e && \"string\" === e.type ? {\n        typeAnnotation: \"coerce\"\n      } : void 0);\n      return n ? mr(new Cr(n, e)) : gr(r.errors);\n    }\n\n    class Er {\n      constructor(t, e) {\n        this.kind = t, this._styleExpression = e, this.isStateDependent = \"constant\" !== t && !xe(e.expression);\n      }\n\n      evaluateWithoutErrorHandling(t, e, r, n, i, s) {\n        return this._styleExpression.evaluateWithoutErrorHandling(t, e, r, n, i, s);\n      }\n\n      evaluate(t, e, r, n, i, s) {\n        return this._styleExpression.evaluate(t, e, r, n, i, s);\n      }\n\n    }\n\n    class Fr {\n      constructor(t, e, r, n) {\n        this.kind = t, this.zoomStops = r, this._styleExpression = e, this.isStateDependent = \"camera\" !== t && !xe(e.expression), this.interpolationType = n;\n      }\n\n      evaluateWithoutErrorHandling(t, e, r, n, i, s) {\n        return this._styleExpression.evaluateWithoutErrorHandling(t, e, r, n, i, s);\n      }\n\n      evaluate(t, e, r, n, i, s) {\n        return this._styleExpression.evaluate(t, e, r, n, i, s);\n      }\n\n      interpolationFactor(t, e, r) {\n        return this.interpolationType ? Ne.interpolationFactor(this.interpolationType, t, e, r) : 0;\n      }\n\n    }\n\n    function Tr(t, e) {\n      const r = Vr(t, e);\n      if (\"error\" === r.result) return r;\n      const n = r.value.expression,\n            i = ge(n);\n      if (!i && !xr(e)) return gr([new ut(\"\", \"data expressions not supported\")]);\n      const s = ve(n, [\"zoom\"]);\n      if (!s && !vr(e)) return gr([new ut(\"\", \"zoom expressions not supported\")]);\n      const a = Dr(n);\n      return a || s ? a instanceof ut ? gr([a]) : a instanceof Ne && !br(e) ? gr([new ut(\"\", '\"interpolate\" expressions cannot be used with this property')]) : mr(a ? new Fr(i ? \"camera\" : \"composite\", r.value, a.labels, a instanceof Ne ? a.interpolation : void 0) : new Er(i ? \"constant\" : \"source\", r.value)) : gr([new ut(\"\", '\"zoom\" expression may only be used as input to a top-level \"step\" or \"interpolate\" expression.')]);\n    }\n\n    class Lr {\n      constructor(t, e) {\n        this._parameters = t, this._specification = e, at(this, kr(this._parameters, this._specification));\n      }\n\n      static deserialize(t) {\n        return new Lr(t._parameters, t._specification);\n      }\n\n      static serialize(t) {\n        return {\n          _parameters: t._parameters,\n          _specification: t._specification\n        };\n      }\n\n    }\n\n    function Dr(t) {\n      let e = null;\n      if (t instanceof Ge) e = Dr(t.result);else if (t instanceof Ze) {\n        for (const r of t.args) if (e = Dr(r), e) break;\n      } else (t instanceof ke || t instanceof Ne) && t.input instanceof Wt && \"zoom\" === t.input.name && (e = t);\n      return e instanceof ut || t.eachChild(t => {\n        const r = Dr(t);\n        r instanceof ut ? e = r : !e && r ? e = new ut(\"\", '\"zoom\" expression may only be used as input to a top-level \"step\" or \"interpolate\" expression.') : e && r && e !== r && (e = new ut(\"\", 'Only one zoom-based \"step\" or \"interpolate\" subexpression may be used in an expression.'));\n      }), e;\n    }\n\n    function $r(t) {\n      const e = t.key,\n            r = t.value,\n            n = t.valueSpec || {},\n            i = t.objectElementValidators || {},\n            s = t.style,\n            a = t.styleSpec;\n      let o = [];\n      const l = wr(r);\n      if (\"object\" !== l) return [new it(e, r, `object expected, ${l} found`)];\n\n      for (const t in r) {\n        const l = t.split(\".\")[0],\n              u = n[l] || n[\"*\"];\n        let c;\n        if (i[l]) c = i[l];else if (n[l]) c = pn;else if (i[\"*\"]) c = i[\"*\"];else {\n          if (!n[\"*\"]) {\n            o.push(new it(e, r[t], `unknown property \"${t}\"`));\n            continue;\n          }\n\n          c = pn;\n        }\n        o = o.concat(c({\n          key: (e ? `${e}.` : e) + t,\n          value: r[t],\n          valueSpec: u,\n          style: s,\n          styleSpec: a,\n          object: r,\n          objectKey: t\n        }, r));\n      }\n\n      for (const t in n) i[t] || n[t].required && void 0 === n[t].default && void 0 === r[t] && o.push(new it(e, r, `missing required property \"${t}\"`));\n\n      return o;\n    }\n\n    function Or(t) {\n      const e = t.value,\n            r = t.valueSpec,\n            n = t.style,\n            i = t.styleSpec,\n            s = t.key,\n            a = t.arrayElementValidator || pn;\n      if (\"array\" !== wr(e)) return [new it(s, e, `array expected, ${wr(e)} found`)];\n      if (r.length && e.length !== r.length) return [new it(s, e, `array length ${r.length} expected, length ${e.length} found`)];\n      if (r[\"min-length\"] && e.length < r[\"min-length\"]) return [new it(s, e, `array length at least ${r[\"min-length\"]} expected, length ${e.length} found`)];\n      let o = {\n        type: r.value,\n        values: r.values\n      };\n      i.$version < 7 && (o.function = r.function), \"object\" === wr(r.value) && (o = r.value);\n      let l = [];\n\n      for (let t = 0; t < e.length; t++) l = l.concat(a({\n        array: e,\n        arrayIndex: t,\n        value: e[t],\n        valueSpec: o,\n        style: n,\n        styleSpec: i,\n        key: `${s}[${t}]`\n      }));\n\n      return l;\n    }\n\n    function Rr(t) {\n      const e = t.key,\n            r = t.value,\n            n = t.valueSpec;\n      let i = wr(r);\n      return \"number\" === i && r != r && (i = \"NaN\"), \"number\" !== i ? [new it(e, r, `number expected, ${i} found`)] : \"minimum\" in n && r < n.minimum ? [new it(e, r, `${r} is less than the minimum value ${n.minimum}`)] : \"maximum\" in n && r > n.maximum ? [new it(e, r, `${r} is greater than the maximum value ${n.maximum}`)] : [];\n    }\n\n    function Ur(t) {\n      const e = t.valueSpec,\n            r = ot(t.value.type);\n      let n,\n          i,\n          s,\n          a = {};\n      const o = \"categorical\" !== r && void 0 === t.value.property,\n            l = !o,\n            u = \"array\" === wr(t.value.stops) && \"array\" === wr(t.value.stops[0]) && \"object\" === wr(t.value.stops[0][0]),\n            c = $r({\n        key: t.key,\n        value: t.value,\n        valueSpec: t.styleSpec.function,\n        style: t.style,\n        styleSpec: t.styleSpec,\n        objectElementValidators: {\n          stops: function (t) {\n            if (\"identity\" === r) return [new it(t.key, t.value, 'identity function may not have a \"stops\" property')];\n            let e = [];\n            const n = t.value;\n            return e = e.concat(Or({\n              key: t.key,\n              value: n,\n              valueSpec: t.valueSpec,\n              style: t.style,\n              styleSpec: t.styleSpec,\n              arrayElementValidator: h\n            })), \"array\" === wr(n) && 0 === n.length && e.push(new it(t.key, n, \"array must have at least one stop\")), e;\n          },\n          default: function (t) {\n            return pn({\n              key: t.key,\n              value: t.value,\n              valueSpec: e,\n              style: t.style,\n              styleSpec: t.styleSpec\n            });\n          }\n        }\n      });\n      return \"identity\" === r && o && c.push(new it(t.key, t.value, 'missing required property \"property\"')), \"identity\" === r || t.value.stops || c.push(new it(t.key, t.value, 'missing required property \"stops\"')), \"exponential\" === r && t.valueSpec.expression && !br(t.valueSpec) && c.push(new it(t.key, t.value, \"exponential functions not supported\")), t.styleSpec.$version >= 8 && (l && !xr(t.valueSpec) ? c.push(new it(t.key, t.value, \"property functions not supported\")) : o && !vr(t.valueSpec) && c.push(new it(t.key, t.value, \"zoom functions not supported\"))), \"categorical\" !== r && !u || void 0 !== t.value.property || c.push(new it(t.key, t.value, '\"property\" property is required')), c;\n\n      function h(t) {\n        let r = [];\n        const n = t.value,\n              o = t.key;\n        if (\"array\" !== wr(n)) return [new it(o, n, `array expected, ${wr(n)} found`)];\n        if (2 !== n.length) return [new it(o, n, `array length 2 expected, length ${n.length} found`)];\n\n        if (u) {\n          if (\"object\" !== wr(n[0])) return [new it(o, n, `object expected, ${wr(n[0])} found`)];\n          if (void 0 === n[0].zoom) return [new it(o, n, \"object stop key must have zoom\")];\n          if (void 0 === n[0].value) return [new it(o, n, \"object stop key must have value\")];\n          if (s && s > ot(n[0].zoom)) return [new it(o, n[0].zoom, \"stop zoom values must appear in ascending order\")];\n          ot(n[0].zoom) !== s && (s = ot(n[0].zoom), i = void 0, a = {}), r = r.concat($r({\n            key: `${o}[0]`,\n            value: n[0],\n            valueSpec: {\n              zoom: {}\n            },\n            style: t.style,\n            styleSpec: t.styleSpec,\n            objectElementValidators: {\n              zoom: Rr,\n              value: p\n            }\n          }));\n        } else r = r.concat(p({\n          key: `${o}[0]`,\n          value: n[0],\n          valueSpec: {},\n          style: t.style,\n          styleSpec: t.styleSpec\n        }, n));\n\n        return Pr(lt(n[1])) ? r.concat([new it(`${o}[1]`, n[1], \"expressions are not allowed in function stops.\")]) : r.concat(pn({\n          key: `${o}[1]`,\n          value: n[1],\n          valueSpec: e,\n          style: t.style,\n          styleSpec: t.styleSpec\n        }));\n      }\n\n      function p(t, s) {\n        const o = wr(t.value),\n              l = ot(t.value),\n              u = null !== t.value ? t.value : s;\n\n        if (n) {\n          if (o !== n) return [new it(t.key, u, `${o} stop domain type must match previous stop domain type ${n}`)];\n        } else n = o;\n\n        if (\"number\" !== o && \"string\" !== o && \"boolean\" !== o) return [new it(t.key, u, \"stop domain value must be a number, string, or boolean\")];\n\n        if (\"number\" !== o && \"categorical\" !== r) {\n          let n = `number expected, ${o} found`;\n          return xr(e) && void 0 === r && (n += '\\nIf you intended to use a categorical function, specify `\"type\": \"categorical\"`.'), [new it(t.key, u, n)];\n        }\n\n        return \"categorical\" !== r || \"number\" !== o || isFinite(l) && Math.floor(l) === l ? \"categorical\" !== r && \"number\" === o && void 0 !== i && l < i ? [new it(t.key, u, \"stop domain values must appear in ascending order\")] : (i = l, \"categorical\" === r && l in a ? [new it(t.key, u, \"stop domain values must be unique\")] : (a[l] = !0, [])) : [new it(t.key, u, `integer expected, found ${l}`)];\n      }\n    }\n\n    function qr(t) {\n      const e = (\"property\" === t.expressionContext ? Tr : Vr)(lt(t.value), t.valueSpec);\n      if (\"error\" === e.result) return e.value.map(e => new it(`${t.key}${e.key}`, t.value, e.message));\n      const r = e.value.expression || e.value._styleExpression.expression;\n      if (\"property\" === t.expressionContext && \"text-font\" === t.propertyKey && !r.outputDefined()) return [new it(t.key, t.value, `Invalid data expression for \"${t.propertyKey}\". Output values must be contained as literals within the expression.`)];\n      if (\"property\" === t.expressionContext && \"layout\" === t.propertyType && !xe(r)) return [new it(t.key, t.value, '\"feature-state\" data expressions are not supported with layout properties.')];\n      if (\"filter\" === t.expressionContext && !xe(r)) return [new it(t.key, t.value, '\"feature-state\" data expressions are not supported with filters.')];\n\n      if (t.expressionContext && 0 === t.expressionContext.indexOf(\"cluster\")) {\n        if (!ve(r, [\"zoom\", \"feature-state\"])) return [new it(t.key, t.value, '\"zoom\" and \"feature-state\" expressions are not supported with cluster properties.')];\n        if (\"cluster-initial\" === t.expressionContext && !ge(r)) return [new it(t.key, t.value, \"Feature data expressions are not supported with initial expression part of cluster properties.\")];\n      }\n\n      return [];\n    }\n\n    function jr(t) {\n      const e = t.key,\n            r = t.value,\n            n = t.valueSpec,\n            i = [];\n      return Array.isArray(n.values) ? -1 === n.values.indexOf(ot(r)) && i.push(new it(e, r, `expected one of [${n.values.join(\", \")}], ${JSON.stringify(r)} found`)) : -1 === Object.keys(n.values).indexOf(ot(r)) && i.push(new it(e, r, `expected one of [${Object.keys(n.values).join(\", \")}], ${JSON.stringify(r)} found`)), i;\n    }\n\n    function Nr(t) {\n      if (!0 === t || !1 === t) return !0;\n      if (!Array.isArray(t) || 0 === t.length) return !1;\n\n      switch (t[0]) {\n        case \"has\":\n          return t.length >= 2 && \"$id\" !== t[1] && \"$type\" !== t[1];\n\n        case \"in\":\n          return t.length >= 3 && (\"string\" != typeof t[1] || Array.isArray(t[2]));\n\n        case \"!in\":\n        case \"!has\":\n        case \"none\":\n          return !1;\n\n        case \"==\":\n        case \"!=\":\n        case \">\":\n        case \">=\":\n        case \"<\":\n        case \"<=\":\n          return 3 !== t.length || Array.isArray(t[1]) || Array.isArray(t[2]);\n\n        case \"any\":\n        case \"all\":\n          for (const e of t.slice(1)) if (!Nr(e) && \"boolean\" != typeof e) return !1;\n\n          return !0;\n\n        default:\n          return !0;\n      }\n    }\n\n    const Kr = {\n      type: \"boolean\",\n      default: !1,\n      transition: !1,\n      \"property-type\": \"data-driven\",\n      expression: {\n        interpolated: !1,\n        parameters: [\"zoom\", \"feature\"]\n      }\n    };\n\n    function Zr(t) {\n      if (null == t) return {\n        filter: () => !0,\n        needGeometry: !1\n      };\n      Nr(t) || (t = Xr(t));\n      const e = Vr(t, Kr);\n      if (\"error\" === e.result) throw new Error(e.value.map(t => `${t.key}: ${t.message}`).join(\", \"));\n      return {\n        filter: (t, r, n) => e.value.evaluate(t, r, {}, n),\n        needGeometry: Jr(t)\n      };\n    }\n\n    function Gr(t, e) {\n      return t < e ? -1 : t > e ? 1 : 0;\n    }\n\n    function Jr(t) {\n      if (!Array.isArray(t)) return !1;\n      if (\"within\" === t[0]) return !0;\n\n      for (let e = 1; e < t.length; e++) if (Jr(t[e])) return !0;\n\n      return !1;\n    }\n\n    function Xr(t) {\n      if (!t) return !0;\n      const e = t[0];\n      return t.length <= 1 ? \"any\" !== e : \"==\" === e ? Yr(t[1], t[2], \"==\") : \"!=\" === e ? Qr(Yr(t[1], t[2], \"==\")) : \"<\" === e || \">\" === e || \"<=\" === e || \">=\" === e ? Yr(t[1], t[2], e) : \"any\" === e ? (r = t.slice(1), [\"any\"].concat(r.map(Xr))) : \"all\" === e ? [\"all\"].concat(t.slice(1).map(Xr)) : \"none\" === e ? [\"all\"].concat(t.slice(1).map(Xr).map(Qr)) : \"in\" === e ? Hr(t[1], t.slice(2)) : \"!in\" === e ? Qr(Hr(t[1], t.slice(2))) : \"has\" === e ? Wr(t[1]) : \"!has\" === e ? Qr(Wr(t[1])) : \"within\" !== e || t;\n      var r;\n    }\n\n    function Yr(t, e, r) {\n      switch (t) {\n        case \"$type\":\n          return [`filter-type-${r}`, e];\n\n        case \"$id\":\n          return [`filter-id-${r}`, e];\n\n        default:\n          return [`filter-${r}`, t, e];\n      }\n    }\n\n    function Hr(t, e) {\n      if (0 === e.length) return !1;\n\n      switch (t) {\n        case \"$type\":\n          return [\"filter-type-in\", [\"literal\", e]];\n\n        case \"$id\":\n          return [\"filter-id-in\", [\"literal\", e]];\n\n        default:\n          return e.length > 200 && !e.some(t => typeof t != typeof e[0]) ? [\"filter-in-large\", t, [\"literal\", e.sort(Gr)]] : [\"filter-in-small\", t, [\"literal\", e]];\n      }\n    }\n\n    function Wr(t) {\n      switch (t) {\n        case \"$type\":\n          return !0;\n\n        case \"$id\":\n          return [\"filter-has-id\"];\n\n        default:\n          return [\"filter-has\", t];\n      }\n    }\n\n    function Qr(t) {\n      return [\"!\", t];\n    }\n\n    function tn(t) {\n      return Nr(lt(t.value)) ? qr(at({}, t, {\n        expressionContext: \"filter\",\n        valueSpec: {\n          value: \"boolean\"\n        }\n      })) : en(t);\n    }\n\n    function en(t) {\n      const e = t.value,\n            r = t.key;\n      if (\"array\" !== wr(e)) return [new it(r, e, `array expected, ${wr(e)} found`)];\n      const n = t.styleSpec;\n      let i,\n          s = [];\n      if (e.length < 1) return [new it(r, e, \"filter array must have at least 1 element\")];\n\n      switch (s = s.concat(jr({\n        key: `${r}[0]`,\n        value: e[0],\n        valueSpec: n.filter_operator,\n        style: t.style,\n        styleSpec: t.styleSpec\n      })), ot(e[0])) {\n        case \"<\":\n        case \"<=\":\n        case \">\":\n        case \">=\":\n          e.length >= 2 && \"$type\" === ot(e[1]) && s.push(new it(r, e, `\"$type\" cannot be use with operator \"${e[0]}\"`));\n\n        case \"==\":\n        case \"!=\":\n          3 !== e.length && s.push(new it(r, e, `filter array for operator \"${e[0]}\" must have 3 elements`));\n\n        case \"in\":\n        case \"!in\":\n          e.length >= 2 && (i = wr(e[1]), \"string\" !== i && s.push(new it(`${r}[1]`, e[1], `string expected, ${i} found`)));\n\n          for (let a = 2; a < e.length; a++) i = wr(e[a]), \"$type\" === ot(e[1]) ? s = s.concat(jr({\n            key: `${r}[${a}]`,\n            value: e[a],\n            valueSpec: n.geometry_type,\n            style: t.style,\n            styleSpec: t.styleSpec\n          })) : \"string\" !== i && \"number\" !== i && \"boolean\" !== i && s.push(new it(`${r}[${a}]`, e[a], `string, number, or boolean expected, ${i} found`));\n\n          break;\n\n        case \"any\":\n        case \"all\":\n        case \"none\":\n          for (let n = 1; n < e.length; n++) s = s.concat(en({\n            key: `${r}[${n}]`,\n            value: e[n],\n            style: t.style,\n            styleSpec: t.styleSpec\n          }));\n\n          break;\n\n        case \"has\":\n        case \"!has\":\n          i = wr(e[1]), 2 !== e.length ? s.push(new it(r, e, `filter array for \"${e[0]}\" operator must have 2 elements`)) : \"string\" !== i && s.push(new it(`${r}[1]`, e[1], `string expected, ${i} found`));\n          break;\n\n        case \"within\":\n          i = wr(e[1]), 2 !== e.length ? s.push(new it(r, e, `filter array for \"${e[0]}\" operator must have 2 elements`)) : \"object\" !== i && s.push(new it(`${r}[1]`, e[1], `object expected, ${i} found`));\n      }\n\n      return s;\n    }\n\n    function rn(t, e) {\n      const r = t.key,\n            n = t.style,\n            i = t.styleSpec,\n            s = t.value,\n            a = t.objectKey,\n            o = i[`${e}_${t.layerType}`];\n      if (!o) return [];\n      const l = a.match(/^(.*)-transition$/);\n      if (\"paint\" === e && l && o[l[1]] && o[l[1]].transition) return pn({\n        key: r,\n        value: s,\n        valueSpec: i.transition,\n        style: n,\n        styleSpec: i\n      });\n      const u = t.valueSpec || o[a];\n      if (!u) return [new it(r, s, `unknown property \"${a}\"`)];\n      let c;\n      if (\"string\" === wr(s) && xr(u) && !u.tokens && (c = /^{([^}]+)}$/.exec(s))) return [new it(r, s, `\"${a}\" does not support interpolation syntax\\nUse an identity property function instead: \\`{ \"type\": \"identity\", \"property\": ${JSON.stringify(c[1])} }\\`.`)];\n      const h = [];\n      return \"symbol\" === t.layerType && (\"text-field\" === a && n && !n.glyphs && h.push(new it(r, s, 'use of \"text-field\" requires a style \"glyphs\" property')), \"text-font\" === a && _r(lt(s)) && \"identity\" === ot(s.type) && h.push(new it(r, s, '\"text-font\" does not support identity functions'))), h.concat(pn({\n        key: t.key,\n        value: s,\n        valueSpec: u,\n        style: n,\n        styleSpec: i,\n        expressionContext: \"property\",\n        propertyType: e,\n        propertyKey: a\n      }));\n    }\n\n    function nn(t) {\n      return rn(t, \"paint\");\n    }\n\n    function sn(t) {\n      return rn(t, \"layout\");\n    }\n\n    function an(t) {\n      let e = [];\n      const r = t.value,\n            n = t.key,\n            i = t.style,\n            s = t.styleSpec;\n      r.type || r.ref || e.push(new it(n, r, 'either \"type\" or \"ref\" is required'));\n      let a = ot(r.type);\n      const o = ot(r.ref);\n\n      if (r.id) {\n        const s = ot(r.id);\n\n        for (let a = 0; a < t.arrayIndex; a++) {\n          const t = i.layers[a];\n          ot(t.id) === s && e.push(new it(n, r.id, `duplicate layer id \"${r.id}\", previously used at line ${t.id.__line__}`));\n        }\n      }\n\n      if (\"ref\" in r) {\n        let t;\n        [\"type\", \"source\", \"source-layer\", \"filter\", \"layout\"].forEach(t => {\n          t in r && e.push(new it(n, r[t], `\"${t}\" is prohibited for ref layers`));\n        }), i.layers.forEach(e => {\n          ot(e.id) === o && (t = e);\n        }), t ? t.ref ? e.push(new it(n, r.ref, \"ref cannot reference another ref layer\")) : a = ot(t.type) : e.push(new it(n, r.ref, `ref layer \"${o}\" not found`));\n      } else if (\"background\" !== a) if (r.source) {\n        const t = i.sources && i.sources[r.source],\n              s = t && ot(t.type);\n        t ? \"vector\" === s && \"raster\" === a ? e.push(new it(n, r.source, `layer \"${r.id}\" requires a raster source`)) : \"raster\" === s && \"raster\" !== a ? e.push(new it(n, r.source, `layer \"${r.id}\" requires a vector source`)) : \"vector\" !== s || r[\"source-layer\"] ? \"raster-dem\" === s && \"hillshade\" !== a ? e.push(new it(n, r.source, \"raster-dem source can only be used with layer type 'hillshade'.\")) : \"line\" !== a || !r.paint || !r.paint[\"line-gradient\"] || \"geojson\" === s && t.lineMetrics || e.push(new it(n, r, `layer \"${r.id}\" specifies a line-gradient, which requires a GeoJSON source with \\`lineMetrics\\` enabled.`)) : e.push(new it(n, r, `layer \"${r.id}\" must specify a \"source-layer\"`)) : e.push(new it(n, r.source, `source \"${r.source}\" not found`));\n      } else e.push(new it(n, r, 'missing required property \"source\"'));\n\n      return e = e.concat($r({\n        key: n,\n        value: r,\n        valueSpec: s.layer,\n        style: t.style,\n        styleSpec: t.styleSpec,\n        objectElementValidators: {\n          \"*\": () => [],\n          type: () => pn({\n            key: `${n}.type`,\n            value: r.type,\n            valueSpec: s.layer.type,\n            style: t.style,\n            styleSpec: t.styleSpec,\n            object: r,\n            objectKey: \"type\"\n          }),\n          filter: tn,\n          layout: t => $r({\n            layer: r,\n            key: t.key,\n            value: t.value,\n            style: t.style,\n            styleSpec: t.styleSpec,\n            objectElementValidators: {\n              \"*\": t => sn(at({\n                layerType: a\n              }, t))\n            }\n          }),\n          paint: t => $r({\n            layer: r,\n            key: t.key,\n            value: t.value,\n            style: t.style,\n            styleSpec: t.styleSpec,\n            objectElementValidators: {\n              \"*\": t => nn(at({\n                layerType: a\n              }, t))\n            }\n          })\n        }\n      })), e;\n    }\n\n    function on(t) {\n      const e = t.value,\n            r = t.key,\n            n = wr(e);\n      return \"string\" !== n ? [new it(r, e, `string expected, ${n} found`)] : [];\n    }\n\n    const ln = {\n      promoteId: function (_ref57) {\n        let {\n          key: t,\n          value: e\n        } = _ref57;\n        if (\"string\" === wr(e)) return on({\n          key: t,\n          value: e\n        });\n        {\n          const r = [];\n\n          for (const n in e) r.push(...on({\n            key: `${t}.${n}`,\n            value: e[n]\n          }));\n\n          return r;\n        }\n      }\n    };\n\n    function un(t) {\n      const e = t.value,\n            r = t.key,\n            n = t.styleSpec,\n            i = t.style;\n      if (!e.type) return [new it(r, e, '\"type\" is required')];\n      const s = ot(e.type);\n      let a;\n\n      switch (s) {\n        case \"vector\":\n        case \"raster\":\n        case \"raster-dem\":\n          return a = $r({\n            key: r,\n            value: e,\n            valueSpec: n[`source_${s.replace(\"-\", \"_\")}`],\n            style: t.style,\n            styleSpec: n,\n            objectElementValidators: ln\n          }), a;\n\n        case \"geojson\":\n          if (a = $r({\n            key: r,\n            value: e,\n            valueSpec: n.source_geojson,\n            style: i,\n            styleSpec: n,\n            objectElementValidators: ln\n          }), e.cluster) for (const t in e.clusterProperties) {\n            const [n, i] = e.clusterProperties[t],\n                  s = \"string\" == typeof n ? [n, [\"accumulated\"], [\"get\", t]] : n;\n            a.push(...qr({\n              key: `${r}.${t}.map`,\n              value: i,\n              expressionContext: \"cluster-map\"\n            })), a.push(...qr({\n              key: `${r}.${t}.reduce`,\n              value: s,\n              expressionContext: \"cluster-reduce\"\n            }));\n          }\n          return a;\n\n        case \"video\":\n          return $r({\n            key: r,\n            value: e,\n            valueSpec: n.source_video,\n            style: i,\n            styleSpec: n\n          });\n\n        case \"image\":\n          return $r({\n            key: r,\n            value: e,\n            valueSpec: n.source_image,\n            style: i,\n            styleSpec: n\n          });\n\n        case \"canvas\":\n          return [new it(r, null, \"Please use runtime APIs to add canvas sources, rather than including them in stylesheets.\", \"source.canvas\")];\n\n        default:\n          return jr({\n            key: `${r}.type`,\n            value: e.type,\n            valueSpec: {\n              values: [\"vector\", \"raster\", \"raster-dem\", \"geojson\", \"video\", \"image\"]\n            },\n            style: i,\n            styleSpec: n\n          });\n      }\n    }\n\n    function cn(t) {\n      const e = t.value,\n            r = t.styleSpec,\n            n = r.light,\n            i = t.style;\n      let s = [];\n      const a = wr(e);\n      if (void 0 === e) return s;\n      if (\"object\" !== a) return s = s.concat([new it(\"light\", e, `object expected, ${a} found`)]), s;\n\n      for (const t in e) {\n        const a = t.match(/^(.*)-transition$/);\n        s = s.concat(a && n[a[1]] && n[a[1]].transition ? pn({\n          key: t,\n          value: e[t],\n          valueSpec: r.transition,\n          style: i,\n          styleSpec: r\n        }) : n[t] ? pn({\n          key: t,\n          value: e[t],\n          valueSpec: n[t],\n          style: i,\n          styleSpec: r\n        }) : [new it(t, e[t], `unknown property \"${t}\"`)]);\n      }\n\n      return s;\n    }\n\n    const hn = {\n      \"*\": () => [],\n      array: Or,\n      boolean: function (t) {\n        const e = t.value,\n              r = t.key,\n              n = wr(e);\n        return \"boolean\" !== n ? [new it(r, e, `boolean expected, ${n} found`)] : [];\n      },\n      number: Rr,\n      color: function (t) {\n        const e = t.key,\n              r = t.value,\n              n = wr(r);\n        return \"string\" !== n ? [new it(e, r, `color expected, ${n} found`)] : null === It(r) ? [new it(e, r, `color expected, \"${r}\" found`)] : [];\n      },\n      constants: st,\n      enum: jr,\n      filter: tn,\n      function: Ur,\n      layer: an,\n      object: $r,\n      source: un,\n      light: cn,\n      string: on,\n      formatted: function (t) {\n        return 0 === on(t).length ? [] : qr(t);\n      },\n      resolvedImage: function (t) {\n        return 0 === on(t).length ? [] : qr(t);\n      }\n    };\n\n    function pn(t) {\n      const e = t.value,\n            r = t.valueSpec,\n            n = t.styleSpec;\n      return r.expression && _r(ot(e)) ? Ur(t) : r.expression && Pr(lt(e)) ? qr(t) : r.type && hn[r.type] ? hn[r.type](t) : $r(at({}, t, {\n        valueSpec: r.type ? n[r.type] : r\n      }));\n    }\n\n    function fn(t) {\n      const e = t.value,\n            r = t.key,\n            n = on(t);\n      return n.length || (-1 === e.indexOf(\"{fontstack}\") && n.push(new it(r, e, '\"glyphs\" url must include a \"{fontstack}\" token')), -1 === e.indexOf(\"{range}\") && n.push(new it(r, e, '\"glyphs\" url must include a \"{range}\" token'))), n;\n    }\n\n    function dn(t) {\n      let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : nt;\n      let r = [];\n      return r = r.concat(pn({\n        key: \"\",\n        value: t,\n        valueSpec: e.$root,\n        styleSpec: e,\n        style: t,\n        objectElementValidators: {\n          glyphs: fn,\n          \"*\": () => []\n        }\n      })), t.constants && (r = r.concat(st({\n        key: \"constants\",\n        value: t.constants,\n        style: t,\n        styleSpec: e\n      }))), yn(r);\n    }\n\n    function yn(t) {\n      return [].concat(t).sort((t, e) => t.line - e.line);\n    }\n\n    function mn(t) {\n      return function () {\n        for (var _len5 = arguments.length, e = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n          e[_key5] = arguments[_key5];\n        }\n\n        return yn(t.apply(this, e));\n      };\n    }\n\n    dn.source = mn(un), dn.light = mn(cn), dn.layer = mn(an), dn.filter = mn(tn), dn.paintProperty = mn(nn), dn.layoutProperty = mn(sn);\n    const gn = dn,\n          xn = gn.light,\n          vn = gn.paintProperty,\n          bn = gn.layoutProperty;\n\n    function wn(t, e) {\n      let r = !1;\n      if (e && e.length) for (const n of e) t.fire(new et(new Error(n.message))), r = !0;\n      return r;\n    }\n\n    class _n {\n      constructor(t, e, r) {\n        const n = this.cells = [];\n\n        if (t instanceof ArrayBuffer) {\n          this.arrayBuffer = t;\n          const i = new Int32Array(this.arrayBuffer);\n          t = i[0], this.d = (e = i[1]) + 2 * (r = i[2]);\n\n          for (let t = 0; t < this.d * this.d; t++) {\n            const e = i[3 + t],\n                  r = i[3 + t + 1];\n            n.push(e === r ? null : i.subarray(e, r));\n          }\n\n          const s = i[3 + n.length + 1];\n          this.keys = i.subarray(i[3 + n.length], s), this.bboxes = i.subarray(s), this.insert = this._insertReadonly;\n        } else {\n          this.d = e + 2 * r;\n\n          for (let t = 0; t < this.d * this.d; t++) n.push([]);\n\n          this.keys = [], this.bboxes = [];\n        }\n\n        this.n = e, this.extent = t, this.padding = r, this.scale = e / t, this.uid = 0;\n        const i = r / e * t;\n        this.min = -i, this.max = t + i;\n      }\n\n      insert(t, e, r, n, i) {\n        this._forEachCell(e, r, n, i, this._insertCell, this.uid++, void 0, void 0), this.keys.push(t), this.bboxes.push(e), this.bboxes.push(r), this.bboxes.push(n), this.bboxes.push(i);\n      }\n\n      _insertReadonly() {\n        throw new Error(\"Cannot insert into a GridIndex created from an ArrayBuffer.\");\n      }\n\n      _insertCell(t, e, r, n, i, s) {\n        this.cells[i].push(s);\n      }\n\n      query(t, e, r, n, i) {\n        const s = this.min,\n              a = this.max;\n        if (t <= s && e <= s && a <= r && a <= n && !i) return Array.prototype.slice.call(this.keys);\n        {\n          const s = [];\n          return this._forEachCell(t, e, r, n, this._queryCell, s, {}, i), s;\n        }\n      }\n\n      _queryCell(t, e, r, n, i, s, a, o) {\n        const l = this.cells[i];\n\n        if (null !== l) {\n          const i = this.keys,\n                u = this.bboxes;\n\n          for (let c = 0; c < l.length; c++) {\n            const h = l[c];\n\n            if (void 0 === a[h]) {\n              const l = 4 * h;\n              (o ? o(u[l + 0], u[l + 1], u[l + 2], u[l + 3]) : t <= u[l + 2] && e <= u[l + 3] && r >= u[l + 0] && n >= u[l + 1]) ? (a[h] = !0, s.push(i[h])) : a[h] = !1;\n            }\n          }\n        }\n      }\n\n      _forEachCell(t, e, r, n, i, s, a, o) {\n        const l = this._convertToCellCoord(t),\n              u = this._convertToCellCoord(e),\n              c = this._convertToCellCoord(r),\n              h = this._convertToCellCoord(n);\n\n        for (let p = l; p <= c; p++) for (let l = u; l <= h; l++) {\n          const u = this.d * l + p;\n          if ((!o || o(this._convertFromCellCoord(p), this._convertFromCellCoord(l), this._convertFromCellCoord(p + 1), this._convertFromCellCoord(l + 1))) && i.call(this, t, e, r, n, u, s, a, o)) return;\n        }\n      }\n\n      _convertFromCellCoord(t) {\n        return (t - this.padding) / this.scale;\n      }\n\n      _convertToCellCoord(t) {\n        return Math.max(0, Math.min(this.d - 1, Math.floor(t * this.scale) + this.padding));\n      }\n\n      toArrayBuffer() {\n        if (this.arrayBuffer) return this.arrayBuffer;\n        const t = this.cells,\n              e = 3 + this.cells.length + 1 + 1;\n        let r = 0;\n\n        for (let t = 0; t < this.cells.length; t++) r += this.cells[t].length;\n\n        const n = new Int32Array(e + r + this.keys.length + this.bboxes.length);\n        n[0] = this.extent, n[1] = this.n, n[2] = this.padding;\n        let i = e;\n\n        for (let e = 0; e < t.length; e++) {\n          const r = t[e];\n          n[3 + e] = i, n.set(r, i), i += r.length;\n        }\n\n        return n[3 + t.length] = i, n.set(this.keys, i), i += this.keys.length, n[3 + t.length + 1] = i, n.set(this.bboxes, i), i += this.bboxes.length, n.buffer;\n      }\n\n      static serialize(t, e) {\n        const r = t.toArrayBuffer();\n        return e && e.push(r), {\n          buffer: r\n        };\n      }\n\n      static deserialize(t) {\n        return new _n(t.buffer);\n      }\n\n    }\n\n    const An = {};\n\n    function kn(t, e) {\n      let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      Object.defineProperty(e, \"_classRegistryKey\", {\n        value: t,\n        writeable: !1\n      }), An[t] = {\n        klass: e,\n        omit: r.omit || [],\n        shallow: r.shallow || []\n      };\n    }\n\n    kn(\"Object\", Object), kn(\"TransferableGridIndex\", _n), kn(\"Color\", Et), kn(\"Error\", Error), kn(\"AJAXError\", q), kn(\"ResolvedImage\", Dt), kn(\"StylePropertyFunction\", Lr), kn(\"StyleExpression\", Cr, {\n      omit: [\"_evaluator\"]\n    }), kn(\"ZoomDependentExpression\", Fr), kn(\"ZoomConstantExpression\", Er), kn(\"CompoundExpression\", Wt, {\n      omit: [\"_evaluate\"]\n    });\n\n    for (const t in hr) hr[t]._classRegistryKey || kn(`Expression_${t}`, hr[t]);\n\n    function Sn(t) {\n      return t && \"undefined\" != typeof ArrayBuffer && (t instanceof ArrayBuffer || t.constructor && \"ArrayBuffer\" === t.constructor.name);\n    }\n\n    function zn(t, e) {\n      if (null == t || \"boolean\" == typeof t || \"number\" == typeof t || \"string\" == typeof t || t instanceof Boolean || t instanceof Number || t instanceof String || t instanceof Date || t instanceof RegExp || t instanceof Blob) return t;\n      if (Sn(t)) return e && e.push(t), t;\n      if (A(t)) return e && e.push(t), t;\n\n      if (ArrayBuffer.isView(t)) {\n        const r = t;\n        return e && e.push(r.buffer), r;\n      }\n\n      if (t instanceof ImageData) return e && e.push(t.data.buffer), t;\n\n      if (Array.isArray(t)) {\n        const r = [];\n\n        for (const n of t) r.push(zn(n, e));\n\n        return r;\n      }\n\n      if (\"object\" == typeof t) {\n        const r = t.constructor,\n              n = r._classRegistryKey;\n        if (!n) throw new Error(\"can't serialize object of unregistered class\");\n        const i = r.serialize ? r.serialize(t, e) : {};\n\n        if (!r.serialize) {\n          for (const r in t) {\n            if (!t.hasOwnProperty(r)) continue;\n            if (An[n].omit.indexOf(r) >= 0) continue;\n            const s = t[r];\n            i[r] = An[n].shallow.indexOf(r) >= 0 ? s : zn(s, e);\n          }\n\n          t instanceof Error && (i.message = t.message);\n        }\n\n        if (i.$name) throw new Error(\"$name property is reserved for worker serialization logic.\");\n        return \"Object\" !== n && (i.$name = n), i;\n      }\n\n      throw new Error(\"can't serialize object of type \" + typeof t);\n    }\n\n    function In(t) {\n      if (null == t || \"boolean\" == typeof t || \"number\" == typeof t || \"string\" == typeof t || t instanceof Boolean || t instanceof Number || t instanceof String || t instanceof Date || t instanceof RegExp || t instanceof Blob || Sn(t) || A(t) || ArrayBuffer.isView(t) || t instanceof ImageData) return t;\n      if (Array.isArray(t)) return t.map(In);\n\n      if (\"object\" == typeof t) {\n        const e = t.$name || \"Object\";\n        if (!An[e]) throw new Error(`can't deserialize unregistered class ${e}`);\n        const {\n          klass: r\n        } = An[e];\n        if (!r) throw new Error(`can't deserialize unregistered class ${e}`);\n        if (r.deserialize) return r.deserialize(t);\n        const n = Object.create(r.prototype);\n\n        for (const r of Object.keys(t)) {\n          if (\"$name\" === r) continue;\n          const i = t[r];\n          n[r] = An[e].shallow.indexOf(r) >= 0 ? i : In(i);\n        }\n\n        return n;\n      }\n\n      throw new Error(\"can't deserialize object of type \" + typeof t);\n    }\n\n    class Mn {\n      constructor() {\n        this.first = !0;\n      }\n\n      update(t, e) {\n        const r = Math.floor(t);\n        return this.first ? (this.first = !1, this.lastIntegerZoom = r, this.lastIntegerZoomTime = 0, this.lastZoom = t, this.lastFloorZoom = r, !0) : (this.lastFloorZoom > r ? (this.lastIntegerZoom = r + 1, this.lastIntegerZoomTime = e) : this.lastFloorZoom < r && (this.lastIntegerZoom = r, this.lastIntegerZoomTime = e), t !== this.lastZoom && (this.lastZoom = t, this.lastFloorZoom = r, !0));\n      }\n\n    }\n\n    const Bn = {\n      \"Latin-1 Supplement\": t => t >= 128 && t <= 255,\n      Arabic: t => t >= 1536 && t <= 1791,\n      \"Arabic Supplement\": t => t >= 1872 && t <= 1919,\n      \"Arabic Extended-A\": t => t >= 2208 && t <= 2303,\n      \"Hangul Jamo\": t => t >= 4352 && t <= 4607,\n      \"Unified Canadian Aboriginal Syllabics\": t => t >= 5120 && t <= 5759,\n      Khmer: t => t >= 6016 && t <= 6143,\n      \"Unified Canadian Aboriginal Syllabics Extended\": t => t >= 6320 && t <= 6399,\n      \"General Punctuation\": t => t >= 8192 && t <= 8303,\n      \"Letterlike Symbols\": t => t >= 8448 && t <= 8527,\n      \"Number Forms\": t => t >= 8528 && t <= 8591,\n      \"Miscellaneous Technical\": t => t >= 8960 && t <= 9215,\n      \"Control Pictures\": t => t >= 9216 && t <= 9279,\n      \"Optical Character Recognition\": t => t >= 9280 && t <= 9311,\n      \"Enclosed Alphanumerics\": t => t >= 9312 && t <= 9471,\n      \"Geometric Shapes\": t => t >= 9632 && t <= 9727,\n      \"Miscellaneous Symbols\": t => t >= 9728 && t <= 9983,\n      \"Miscellaneous Symbols and Arrows\": t => t >= 11008 && t <= 11263,\n      \"CJK Radicals Supplement\": t => t >= 11904 && t <= 12031,\n      \"Kangxi Radicals\": t => t >= 12032 && t <= 12255,\n      \"Ideographic Description Characters\": t => t >= 12272 && t <= 12287,\n      \"CJK Symbols and Punctuation\": t => t >= 12288 && t <= 12351,\n      Hiragana: t => t >= 12352 && t <= 12447,\n      Katakana: t => t >= 12448 && t <= 12543,\n      Bopomofo: t => t >= 12544 && t <= 12591,\n      \"Hangul Compatibility Jamo\": t => t >= 12592 && t <= 12687,\n      Kanbun: t => t >= 12688 && t <= 12703,\n      \"Bopomofo Extended\": t => t >= 12704 && t <= 12735,\n      \"CJK Strokes\": t => t >= 12736 && t <= 12783,\n      \"Katakana Phonetic Extensions\": t => t >= 12784 && t <= 12799,\n      \"Enclosed CJK Letters and Months\": t => t >= 12800 && t <= 13055,\n      \"CJK Compatibility\": t => t >= 13056 && t <= 13311,\n      \"CJK Unified Ideographs Extension A\": t => t >= 13312 && t <= 19903,\n      \"Yijing Hexagram Symbols\": t => t >= 19904 && t <= 19967,\n      \"CJK Unified Ideographs\": t => t >= 19968 && t <= 40959,\n      \"Yi Syllables\": t => t >= 40960 && t <= 42127,\n      \"Yi Radicals\": t => t >= 42128 && t <= 42191,\n      \"Hangul Jamo Extended-A\": t => t >= 43360 && t <= 43391,\n      \"Hangul Syllables\": t => t >= 44032 && t <= 55215,\n      \"Hangul Jamo Extended-B\": t => t >= 55216 && t <= 55295,\n      \"Private Use Area\": t => t >= 57344 && t <= 63743,\n      \"CJK Compatibility Ideographs\": t => t >= 63744 && t <= 64255,\n      \"Arabic Presentation Forms-A\": t => t >= 64336 && t <= 65023,\n      \"Vertical Forms\": t => t >= 65040 && t <= 65055,\n      \"CJK Compatibility Forms\": t => t >= 65072 && t <= 65103,\n      \"Small Form Variants\": t => t >= 65104 && t <= 65135,\n      \"Arabic Presentation Forms-B\": t => t >= 65136 && t <= 65279,\n      \"Halfwidth and Fullwidth Forms\": t => t >= 65280 && t <= 65519\n    };\n\n    function Cn(t) {\n      for (const e of t) if (En(e.charCodeAt(0))) return !0;\n\n      return !1;\n    }\n\n    function Pn(t) {\n      for (const e of t) if (!Vn(e.charCodeAt(0))) return !1;\n\n      return !0;\n    }\n\n    function Vn(t) {\n      return !(Bn.Arabic(t) || Bn[\"Arabic Supplement\"](t) || Bn[\"Arabic Extended-A\"](t) || Bn[\"Arabic Presentation Forms-A\"](t) || Bn[\"Arabic Presentation Forms-B\"](t));\n    }\n\n    function En(t) {\n      return !(746 !== t && 747 !== t && (t < 4352 || !(Bn[\"Bopomofo Extended\"](t) || Bn.Bopomofo(t) || Bn[\"CJK Compatibility Forms\"](t) && !(t >= 65097 && t <= 65103) || Bn[\"CJK Compatibility Ideographs\"](t) || Bn[\"CJK Compatibility\"](t) || Bn[\"CJK Radicals Supplement\"](t) || Bn[\"CJK Strokes\"](t) || !(!Bn[\"CJK Symbols and Punctuation\"](t) || t >= 12296 && t <= 12305 || t >= 12308 && t <= 12319 || 12336 === t) || Bn[\"CJK Unified Ideographs Extension A\"](t) || Bn[\"CJK Unified Ideographs\"](t) || Bn[\"Enclosed CJK Letters and Months\"](t) || Bn[\"Hangul Compatibility Jamo\"](t) || Bn[\"Hangul Jamo Extended-A\"](t) || Bn[\"Hangul Jamo Extended-B\"](t) || Bn[\"Hangul Jamo\"](t) || Bn[\"Hangul Syllables\"](t) || Bn.Hiragana(t) || Bn[\"Ideographic Description Characters\"](t) || Bn.Kanbun(t) || Bn[\"Kangxi Radicals\"](t) || Bn[\"Katakana Phonetic Extensions\"](t) || Bn.Katakana(t) && 12540 !== t || !(!Bn[\"Halfwidth and Fullwidth Forms\"](t) || 65288 === t || 65289 === t || 65293 === t || t >= 65306 && t <= 65310 || 65339 === t || 65341 === t || 65343 === t || t >= 65371 && t <= 65503 || 65507 === t || t >= 65512 && t <= 65519) || !(!Bn[\"Small Form Variants\"](t) || t >= 65112 && t <= 65118 || t >= 65123 && t <= 65126) || Bn[\"Unified Canadian Aboriginal Syllabics\"](t) || Bn[\"Unified Canadian Aboriginal Syllabics Extended\"](t) || Bn[\"Vertical Forms\"](t) || Bn[\"Yijing Hexagram Symbols\"](t) || Bn[\"Yi Syllables\"](t) || Bn[\"Yi Radicals\"](t))));\n    }\n\n    function Fn(t) {\n      return !(En(t) || function (t) {\n        return !!(Bn[\"Latin-1 Supplement\"](t) && (167 === t || 169 === t || 174 === t || 177 === t || 188 === t || 189 === t || 190 === t || 215 === t || 247 === t) || Bn[\"General Punctuation\"](t) && (8214 === t || 8224 === t || 8225 === t || 8240 === t || 8241 === t || 8251 === t || 8252 === t || 8258 === t || 8263 === t || 8264 === t || 8265 === t || 8273 === t) || Bn[\"Letterlike Symbols\"](t) || Bn[\"Number Forms\"](t) || Bn[\"Miscellaneous Technical\"](t) && (t >= 8960 && t <= 8967 || t >= 8972 && t <= 8991 || t >= 8996 && t <= 9e3 || 9003 === t || t >= 9085 && t <= 9114 || t >= 9150 && t <= 9165 || 9167 === t || t >= 9169 && t <= 9179 || t >= 9186 && t <= 9215) || Bn[\"Control Pictures\"](t) && 9251 !== t || Bn[\"Optical Character Recognition\"](t) || Bn[\"Enclosed Alphanumerics\"](t) || Bn[\"Geometric Shapes\"](t) || Bn[\"Miscellaneous Symbols\"](t) && !(t >= 9754 && t <= 9759) || Bn[\"Miscellaneous Symbols and Arrows\"](t) && (t >= 11026 && t <= 11055 || t >= 11088 && t <= 11097 || t >= 11192 && t <= 11243) || Bn[\"CJK Symbols and Punctuation\"](t) || Bn.Katakana(t) || Bn[\"Private Use Area\"](t) || Bn[\"CJK Compatibility Forms\"](t) || Bn[\"Small Form Variants\"](t) || Bn[\"Halfwidth and Fullwidth Forms\"](t) || 8734 === t || 8756 === t || 8757 === t || t >= 9984 && t <= 10087 || t >= 10102 && t <= 10131 || 65532 === t || 65533 === t);\n      }(t));\n    }\n\n    function Tn(t) {\n      return t >= 1424 && t <= 2303 || Bn[\"Arabic Presentation Forms-A\"](t) || Bn[\"Arabic Presentation Forms-B\"](t);\n    }\n\n    function Ln(t, e) {\n      return !(!e && Tn(t) || t >= 2304 && t <= 3583 || t >= 3840 && t <= 4255 || Bn.Khmer(t));\n    }\n\n    function Dn(t) {\n      for (const e of t) if (Tn(e.charCodeAt(0))) return !0;\n\n      return !1;\n    }\n\n    const $n = \"deferred\",\n          On = \"loading\",\n          Rn = \"loaded\";\n    let Un = null,\n        qn = \"unavailable\",\n        jn = null;\n\n    const Nn = function (t) {\n      t && \"string\" == typeof t && t.indexOf(\"NetworkError\") > -1 && (qn = \"error\"), Un && Un(t);\n    };\n\n    function Kn() {\n      Zn.fire(new tt(\"pluginStateChange\", {\n        pluginStatus: qn,\n        pluginURL: jn\n      }));\n    }\n\n    const Zn = new rt(),\n          Gn = function () {\n      return qn;\n    },\n          Jn = function () {\n      if (qn !== $n || !jn) throw new Error(\"rtl-text-plugin cannot be downloaded unless a pluginURL is specified\");\n      qn = On, Kn(), jn && Z({\n        url: jn\n      }, t => {\n        t ? Nn(t) : (qn = Rn, Kn());\n      });\n    },\n          Xn = {\n      applyArabicShaping: null,\n      processBidirectionalText: null,\n      processStyledBidirectionalText: null,\n      isLoaded: () => qn === Rn || null != Xn.applyArabicShaping,\n      isLoading: () => qn === On,\n\n      setState(t) {\n        qn = t.pluginStatus, jn = t.pluginURL;\n      },\n\n      isParsed: () => null != Xn.applyArabicShaping && null != Xn.processBidirectionalText && null != Xn.processStyledBidirectionalText,\n      getPluginURL: () => jn\n    };\n\n    class Yn {\n      constructor(t, e) {\n        this.zoom = t, e ? (this.now = e.now, this.fadeDuration = e.fadeDuration, this.zoomHistory = e.zoomHistory, this.transition = e.transition) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new Mn(), this.transition = {});\n      }\n\n      isSupportedScript(t) {\n        return function (t, e) {\n          for (const r of t) if (!Ln(r.charCodeAt(0), e)) return !1;\n\n          return !0;\n        }(t, Xn.isLoaded());\n      }\n\n      crossFadingFactor() {\n        return 0 === this.fadeDuration ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1);\n      }\n\n      getCrossfadeParameters() {\n        const t = this.zoom,\n              e = t - Math.floor(t),\n              r = this.crossFadingFactor();\n        return t > this.zoomHistory.lastIntegerZoom ? {\n          fromScale: 2,\n          toScale: 1,\n          t: e + (1 - e) * r\n        } : {\n          fromScale: .5,\n          toScale: 1,\n          t: 1 - (1 - r) * e\n        };\n      }\n\n    }\n\n    class Hn {\n      constructor(t, e) {\n        this.property = t, this.value = e, this.expression = function (t, e) {\n          if (_r(t)) return new Lr(t, e);\n\n          if (Pr(t)) {\n            const r = Tr(t, e);\n            if (\"error\" === r.result) throw new Error(r.value.map(t => `${t.key}: ${t.message}`).join(\", \"));\n            return r.value;\n          }\n\n          {\n            let r = t;\n            return \"string\" == typeof t && \"color\" === e.type && (r = Et.parse(t)), {\n              kind: \"constant\",\n              evaluate: () => r\n            };\n          }\n        }(void 0 === e ? t.specification.default : e, t.specification);\n      }\n\n      isDataDriven() {\n        return \"source\" === this.expression.kind || \"composite\" === this.expression.kind;\n      }\n\n      possiblyEvaluate(t, e, r) {\n        return this.property.possiblyEvaluate(this, t, e, r);\n      }\n\n    }\n\n    class Wn {\n      constructor(t) {\n        this.property = t, this.value = new Hn(t, void 0);\n      }\n\n      transitioned(t, e) {\n        return new ti(this.property, this.value, e, o({}, t.transition, this.transition), t.now);\n      }\n\n      untransitioned() {\n        return new ti(this.property, this.value, null, {}, 0);\n      }\n\n    }\n\n    class Qn {\n      constructor(t) {\n        this._properties = t, this._values = Object.create(t.defaultTransitionablePropertyValues);\n      }\n\n      getValue(t) {\n        return p(this._values[t].value.value);\n      }\n\n      setValue(t, e) {\n        Object.prototype.hasOwnProperty.call(this._values, t) || (this._values[t] = new Wn(this._values[t].property)), this._values[t].value = new Hn(this._values[t].property, null === e ? void 0 : p(e));\n      }\n\n      getTransition(t) {\n        return p(this._values[t].transition);\n      }\n\n      setTransition(t, e) {\n        Object.prototype.hasOwnProperty.call(this._values, t) || (this._values[t] = new Wn(this._values[t].property)), this._values[t].transition = p(e) || void 0;\n      }\n\n      serialize() {\n        const t = {};\n\n        for (const e of Object.keys(this._values)) {\n          const r = this.getValue(e);\n          void 0 !== r && (t[e] = r);\n          const n = this.getTransition(e);\n          void 0 !== n && (t[`${e}-transition`] = n);\n        }\n\n        return t;\n      }\n\n      transitioned(t, e) {\n        const r = new ei(this._properties);\n\n        for (const n of Object.keys(this._values)) r._values[n] = this._values[n].transitioned(t, e._values[n]);\n\n        return r;\n      }\n\n      untransitioned() {\n        const t = new ei(this._properties);\n\n        for (const e of Object.keys(this._values)) t._values[e] = this._values[e].untransitioned();\n\n        return t;\n      }\n\n    }\n\n    class ti {\n      constructor(t, e, r, n, i) {\n        this.property = t, this.value = e, this.begin = i + n.delay || 0, this.end = this.begin + n.duration || 0, t.specification.transition && (n.delay || n.duration) && (this.prior = r);\n      }\n\n      possiblyEvaluate(t, e, r) {\n        const n = t.now || 0,\n              i = this.value.possiblyEvaluate(t, e, r),\n              s = this.prior;\n\n        if (s) {\n          if (n > this.end) return this.prior = null, i;\n          if (this.value.isDataDriven()) return this.prior = null, i;\n          if (n < this.begin) return s.possiblyEvaluate(t, e, r);\n          {\n            const a = (n - this.begin) / (this.end - this.begin);\n            return this.property.interpolate(s.possiblyEvaluate(t, e, r), i, function (t) {\n              if (t <= 0) return 0;\n              if (t >= 1) return 1;\n              const e = t * t,\n                    r = e * t;\n              return 4 * (t < .5 ? r : 3 * (t - e) + r - .75);\n            }(a));\n          }\n        }\n\n        return i;\n      }\n\n    }\n\n    class ei {\n      constructor(t) {\n        this._properties = t, this._values = Object.create(t.defaultTransitioningPropertyValues);\n      }\n\n      possiblyEvaluate(t, e, r) {\n        const n = new ii(this._properties);\n\n        for (const i of Object.keys(this._values)) n._values[i] = this._values[i].possiblyEvaluate(t, e, r);\n\n        return n;\n      }\n\n      hasTransition() {\n        for (const t of Object.keys(this._values)) if (this._values[t].prior) return !0;\n\n        return !1;\n      }\n\n    }\n\n    class ri {\n      constructor(t) {\n        this._properties = t, this._values = Object.create(t.defaultPropertyValues);\n      }\n\n      getValue(t) {\n        return p(this._values[t].value);\n      }\n\n      setValue(t, e) {\n        this._values[t] = new Hn(this._values[t].property, null === e ? void 0 : p(e));\n      }\n\n      serialize() {\n        const t = {};\n\n        for (const e of Object.keys(this._values)) {\n          const r = this.getValue(e);\n          void 0 !== r && (t[e] = r);\n        }\n\n        return t;\n      }\n\n      possiblyEvaluate(t, e, r) {\n        const n = new ii(this._properties);\n\n        for (const i of Object.keys(this._values)) n._values[i] = this._values[i].possiblyEvaluate(t, e, r);\n\n        return n;\n      }\n\n    }\n\n    class ni {\n      constructor(t, e, r) {\n        this.property = t, this.value = e, this.parameters = r;\n      }\n\n      isConstant() {\n        return \"constant\" === this.value.kind;\n      }\n\n      constantOr(t) {\n        return \"constant\" === this.value.kind ? this.value.value : t;\n      }\n\n      evaluate(t, e, r, n) {\n        return this.property.evaluate(this.value, this.parameters, t, e, r, n);\n      }\n\n    }\n\n    class ii {\n      constructor(t) {\n        this._properties = t, this._values = Object.create(t.defaultPossiblyEvaluatedValues);\n      }\n\n      get(t) {\n        return this._values[t];\n      }\n\n    }\n\n    class si {\n      constructor(t) {\n        this.specification = t;\n      }\n\n      possiblyEvaluate(t, e) {\n        return t.expression.evaluate(e);\n      }\n\n      interpolate(t, e, r) {\n        const n = ze[this.specification.type];\n        return n ? n(t, e, r) : t;\n      }\n\n    }\n\n    class ai {\n      constructor(t, e) {\n        this.specification = t, this.overrides = e;\n      }\n\n      possiblyEvaluate(t, e, r, n) {\n        return new ni(this, \"constant\" === t.expression.kind || \"camera\" === t.expression.kind ? {\n          kind: \"constant\",\n          value: t.expression.evaluate(e, null, {}, r, n)\n        } : t.expression, e);\n      }\n\n      interpolate(t, e, r) {\n        if (\"constant\" !== t.value.kind || \"constant\" !== e.value.kind) return t;\n        if (void 0 === t.value.value || void 0 === e.value.value) return new ni(this, {\n          kind: \"constant\",\n          value: void 0\n        }, t.parameters);\n        const n = ze[this.specification.type];\n        return n ? new ni(this, {\n          kind: \"constant\",\n          value: n(t.value.value, e.value.value, r)\n        }, t.parameters) : t;\n      }\n\n      evaluate(t, e, r, n, i, s) {\n        return \"constant\" === t.kind ? t.value : t.evaluate(e, r, n, i, s);\n      }\n\n    }\n\n    class oi extends ai {\n      possiblyEvaluate(t, e, r, n) {\n        if (void 0 === t.value) return new ni(this, {\n          kind: \"constant\",\n          value: void 0\n        }, e);\n\n        if (\"constant\" === t.expression.kind) {\n          const i = t.expression.evaluate(e, null, {}, r, n),\n                s = \"resolvedImage\" === t.property.specification.type && \"string\" != typeof i ? i.name : i,\n                a = this._calculate(s, s, s, e);\n\n          return new ni(this, {\n            kind: \"constant\",\n            value: a\n          }, e);\n        }\n\n        if (\"camera\" === t.expression.kind) {\n          const r = this._calculate(t.expression.evaluate({\n            zoom: e.zoom - 1\n          }), t.expression.evaluate({\n            zoom: e.zoom\n          }), t.expression.evaluate({\n            zoom: e.zoom + 1\n          }), e);\n\n          return new ni(this, {\n            kind: \"constant\",\n            value: r\n          }, e);\n        }\n\n        return new ni(this, t.expression, e);\n      }\n\n      evaluate(t, e, r, n, i, s) {\n        if (\"source\" === t.kind) {\n          const a = t.evaluate(e, r, n, i, s);\n          return this._calculate(a, a, a, e);\n        }\n\n        return \"composite\" === t.kind ? this._calculate(t.evaluate({\n          zoom: Math.floor(e.zoom) - 1\n        }, r, n), t.evaluate({\n          zoom: Math.floor(e.zoom)\n        }, r, n), t.evaluate({\n          zoom: Math.floor(e.zoom) + 1\n        }, r, n), e) : t.value;\n      }\n\n      _calculate(t, e, r, n) {\n        return n.zoom > n.zoomHistory.lastIntegerZoom ? {\n          from: t,\n          to: e\n        } : {\n          from: r,\n          to: e\n        };\n      }\n\n      interpolate(t) {\n        return t;\n      }\n\n    }\n\n    class li {\n      constructor(t) {\n        this.specification = t;\n      }\n\n      possiblyEvaluate(t, e, r, n) {\n        if (void 0 !== t.value) {\n          if (\"constant\" === t.expression.kind) {\n            const i = t.expression.evaluate(e, null, {}, r, n);\n            return this._calculate(i, i, i, e);\n          }\n\n          return this._calculate(t.expression.evaluate(new Yn(Math.floor(e.zoom - 1), e)), t.expression.evaluate(new Yn(Math.floor(e.zoom), e)), t.expression.evaluate(new Yn(Math.floor(e.zoom + 1), e)), e);\n        }\n      }\n\n      _calculate(t, e, r, n) {\n        return n.zoom > n.zoomHistory.lastIntegerZoom ? {\n          from: t,\n          to: e\n        } : {\n          from: r,\n          to: e\n        };\n      }\n\n      interpolate(t) {\n        return t;\n      }\n\n    }\n\n    class ui {\n      constructor(t) {\n        this.specification = t;\n      }\n\n      possiblyEvaluate(t, e, r, n) {\n        return !!t.expression.evaluate(e, null, {}, r, n);\n      }\n\n      interpolate() {\n        return !1;\n      }\n\n    }\n\n    class ci {\n      constructor(t) {\n        this.properties = t, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];\n\n        for (const e in t) {\n          const r = t[e];\n          r.specification.overridable && this.overridableProperties.push(e);\n          const n = this.defaultPropertyValues[e] = new Hn(r, void 0),\n                i = this.defaultTransitionablePropertyValues[e] = new Wn(r);\n          this.defaultTransitioningPropertyValues[e] = i.untransitioned(), this.defaultPossiblyEvaluatedValues[e] = n.possiblyEvaluate({});\n        }\n      }\n\n    }\n\n    kn(\"DataDrivenProperty\", ai), kn(\"DataConstantProperty\", si), kn(\"CrossFadedDataDrivenProperty\", oi), kn(\"CrossFadedProperty\", li), kn(\"ColorRampProperty\", ui);\n    const hi = \"-transition\";\n\n    class pi extends rt {\n      constructor(t, e) {\n        if (super(), this.id = t.id, this.type = t.type, this._featureFilter = {\n          filter: () => !0,\n          needGeometry: !1\n        }, \"custom\" !== t.type && (this.metadata = (t = t).metadata, this.minzoom = t.minzoom, this.maxzoom = t.maxzoom, \"background\" !== t.type && (this.source = t.source, this.sourceLayer = t[\"source-layer\"], this.filter = t.filter), e.layout && (this._unevaluatedLayout = new ri(e.layout)), e.paint)) {\n          this._transitionablePaint = new Qn(e.paint);\n\n          for (const e in t.paint) this.setPaintProperty(e, t.paint[e], {\n            validate: !1\n          });\n\n          for (const e in t.layout) this.setLayoutProperty(e, t.layout[e], {\n            validate: !1\n          });\n\n          this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new ii(e.paint);\n        }\n      }\n\n      getCrossfadeParameters() {\n        return this._crossfadeParameters;\n      }\n\n      getLayoutProperty(t) {\n        return \"visibility\" === t ? this.visibility : this._unevaluatedLayout.getValue(t);\n      }\n\n      setLayoutProperty(t, e) {\n        let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        null != e && this._validate(bn, `layers.${this.id}.layout.${t}`, t, e, r) || (\"visibility\" !== t ? this._unevaluatedLayout.setValue(t, e) : this.visibility = e);\n      }\n\n      getPaintProperty(t) {\n        return t.endsWith(hi) ? this._transitionablePaint.getTransition(t.slice(0, -hi.length)) : this._transitionablePaint.getValue(t);\n      }\n\n      setPaintProperty(t, e) {\n        let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        if (null != e && this._validate(vn, `layers.${this.id}.paint.${t}`, t, e, r)) return !1;\n        if (t.endsWith(hi)) return this._transitionablePaint.setTransition(t.slice(0, -hi.length), e || void 0), !1;\n        {\n          const r = this._transitionablePaint._values[t],\n                n = \"cross-faded-data-driven\" === r.property.specification[\"property-type\"],\n                i = r.value.isDataDriven(),\n                s = r.value;\n          this._transitionablePaint.setValue(t, e), this._handleSpecialPaintPropertyUpdate(t);\n          const a = this._transitionablePaint._values[t].value;\n          return a.isDataDriven() || i || n || this._handleOverridablePaintPropertyUpdate(t, s, a);\n        }\n      }\n\n      _handleSpecialPaintPropertyUpdate(t) {}\n\n      _handleOverridablePaintPropertyUpdate(t, e, r) {\n        return !1;\n      }\n\n      isHidden(t) {\n        return !!(this.minzoom && t < this.minzoom) || !!(this.maxzoom && t >= this.maxzoom) || \"none\" === this.visibility;\n      }\n\n      updateTransitions(t) {\n        this._transitioningPaint = this._transitionablePaint.transitioned(t, this._transitioningPaint);\n      }\n\n      hasTransition() {\n        return this._transitioningPaint.hasTransition();\n      }\n\n      recalculate(t, e) {\n        t.getCrossfadeParameters && (this._crossfadeParameters = t.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t, void 0, e)), this.paint = this._transitioningPaint.possiblyEvaluate(t, void 0, e);\n      }\n\n      serialize() {\n        const t = {\n          id: this.id,\n          type: this.type,\n          source: this.source,\n          \"source-layer\": this.sourceLayer,\n          metadata: this.metadata,\n          minzoom: this.minzoom,\n          maxzoom: this.maxzoom,\n          filter: this.filter,\n          layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(),\n          paint: this._transitionablePaint && this._transitionablePaint.serialize()\n        };\n        return this.visibility && (t.layout = t.layout || {}, t.layout.visibility = this.visibility), h(t, (t, e) => !(void 0 === t || \"layout\" === e && !Object.keys(t).length || \"paint\" === e && !Object.keys(t).length));\n      }\n\n      _validate(t, e, r, n) {\n        let i = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n        return (!i || !1 !== i.validate) && wn(this, t.call(gn, {\n          key: e,\n          layerType: this.type,\n          objectKey: r,\n          value: n,\n          styleSpec: nt,\n          style: {\n            glyphs: !0,\n            sprite: !0\n          }\n        }));\n      }\n\n      is3D() {\n        return !1;\n      }\n\n      isTileClipped() {\n        return !1;\n      }\n\n      hasOffscreenPass() {\n        return !1;\n      }\n\n      resize() {}\n\n      isStateDependent() {\n        for (const t in this.paint._values) {\n          const e = this.paint.get(t);\n          if (e instanceof ni && xr(e.property.specification) && (\"source\" === e.value.kind || \"composite\" === e.value.kind) && e.value.isStateDependent) return !0;\n        }\n\n        return !1;\n      }\n\n    }\n\n    const fi = {\n      Int8: Int8Array,\n      Uint8: Uint8Array,\n      Int16: Int16Array,\n      Uint16: Uint16Array,\n      Int32: Int32Array,\n      Uint32: Uint32Array,\n      Float32: Float32Array\n    };\n\n    class di {\n      constructor(t, e) {\n        this._structArray = t, this._pos1 = e * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;\n      }\n\n    }\n\n    class yi {\n      constructor() {\n        this.isTransferred = !1, this.capacity = -1, this.resize(0);\n      }\n\n      static serialize(t, e) {\n        return t._trim(), e && (t.isTransferred = !0, e.push(t.arrayBuffer)), {\n          length: t.length,\n          arrayBuffer: t.arrayBuffer\n        };\n      }\n\n      static deserialize(t) {\n        const e = Object.create(this.prototype);\n        return e.arrayBuffer = t.arrayBuffer, e.length = t.length, e.capacity = t.arrayBuffer.byteLength / e.bytesPerElement, e._refreshViews(), e;\n      }\n\n      _trim() {\n        this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());\n      }\n\n      clear() {\n        this.length = 0;\n      }\n\n      resize(t) {\n        this.reserve(t), this.length = t;\n      }\n\n      reserve(t) {\n        if (t > this.capacity) {\n          this.capacity = Math.max(t, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);\n          const e = this.uint8;\n          this._refreshViews(), e && this.uint8.set(e);\n        }\n      }\n\n      _refreshViews() {\n        throw new Error(\"_refreshViews() must be implemented by each concrete StructArray layout\");\n      }\n\n    }\n\n    function mi(t) {\n      let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      let r = 0,\n          n = 0;\n      return {\n        members: t.map(t => {\n          const i = fi[t.type].BYTES_PER_ELEMENT,\n                s = r = gi(r, Math.max(e, i)),\n                a = t.components || 1;\n          return n = Math.max(n, i), r += i * a, {\n            name: t.name,\n            type: t.type,\n            components: a,\n            offset: s\n          };\n        }),\n        size: gi(r, Math.max(n, e)),\n        alignment: e\n      };\n    }\n\n    function gi(t, e) {\n      return Math.ceil(t / e) * e;\n    }\n\n    class xi extends yi {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);\n      }\n\n      emplaceBack(t, e) {\n        const r = this.length;\n        return this.resize(r + 1), this.emplace(r, t, e);\n      }\n\n      emplace(t, e, r) {\n        const n = 2 * t;\n        return this.int16[n + 0] = e, this.int16[n + 1] = r, t;\n      }\n\n    }\n\n    xi.prototype.bytesPerElement = 4, kn(\"StructArrayLayout2i4\", xi);\n\n    class vi extends yi {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);\n      }\n\n      emplaceBack(t, e, r, n) {\n        const i = this.length;\n        return this.resize(i + 1), this.emplace(i, t, e, r, n);\n      }\n\n      emplace(t, e, r, n, i) {\n        const s = 4 * t;\n        return this.int16[s + 0] = e, this.int16[s + 1] = r, this.int16[s + 2] = n, this.int16[s + 3] = i, t;\n      }\n\n    }\n\n    vi.prototype.bytesPerElement = 8, kn(\"StructArrayLayout4i8\", vi);\n\n    class bi extends yi {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);\n      }\n\n      emplaceBack(t, e, r, n, i, s) {\n        const a = this.length;\n        return this.resize(a + 1), this.emplace(a, t, e, r, n, i, s);\n      }\n\n      emplace(t, e, r, n, i, s, a) {\n        const o = 6 * t;\n        return this.int16[o + 0] = e, this.int16[o + 1] = r, this.int16[o + 2] = n, this.int16[o + 3] = i, this.int16[o + 4] = s, this.int16[o + 5] = a, t;\n      }\n\n    }\n\n    bi.prototype.bytesPerElement = 12, kn(\"StructArrayLayout2i4i12\", bi);\n\n    class wi extends yi {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);\n      }\n\n      emplaceBack(t, e, r, n, i, s) {\n        const a = this.length;\n        return this.resize(a + 1), this.emplace(a, t, e, r, n, i, s);\n      }\n\n      emplace(t, e, r, n, i, s, a) {\n        const o = 4 * t,\n              l = 8 * t;\n        return this.int16[o + 0] = e, this.int16[o + 1] = r, this.uint8[l + 4] = n, this.uint8[l + 5] = i, this.uint8[l + 6] = s, this.uint8[l + 7] = a, t;\n      }\n\n    }\n\n    wi.prototype.bytesPerElement = 8, kn(\"StructArrayLayout2i4ub8\", wi);\n\n    class _i extends yi {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }\n\n      emplaceBack(t, e) {\n        const r = this.length;\n        return this.resize(r + 1), this.emplace(r, t, e);\n      }\n\n      emplace(t, e, r) {\n        const n = 2 * t;\n        return this.float32[n + 0] = e, this.float32[n + 1] = r, t;\n      }\n\n    }\n\n    _i.prototype.bytesPerElement = 8, kn(\"StructArrayLayout2f8\", _i);\n\n    class Ai extends yi {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);\n      }\n\n      emplaceBack(t, e, r, n, i, s, a, o, l, u) {\n        const c = this.length;\n        return this.resize(c + 1), this.emplace(c, t, e, r, n, i, s, a, o, l, u);\n      }\n\n      emplace(t, e, r, n, i, s, a, o, l, u, c) {\n        const h = 10 * t;\n        return this.uint16[h + 0] = e, this.uint16[h + 1] = r, this.uint16[h + 2] = n, this.uint16[h + 3] = i, this.uint16[h + 4] = s, this.uint16[h + 5] = a, this.uint16[h + 6] = o, this.uint16[h + 7] = l, this.uint16[h + 8] = u, this.uint16[h + 9] = c, t;\n      }\n\n    }\n\n    Ai.prototype.bytesPerElement = 20, kn(\"StructArrayLayout10ui20\", Ai);\n\n    class ki extends yi {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);\n      }\n\n      emplaceBack(t, e, r, n, i, s, a, o, l, u, c, h) {\n        const p = this.length;\n        return this.resize(p + 1), this.emplace(p, t, e, r, n, i, s, a, o, l, u, c, h);\n      }\n\n      emplace(t, e, r, n, i, s, a, o, l, u, c, h, p) {\n        const f = 12 * t;\n        return this.int16[f + 0] = e, this.int16[f + 1] = r, this.int16[f + 2] = n, this.int16[f + 3] = i, this.uint16[f + 4] = s, this.uint16[f + 5] = a, this.uint16[f + 6] = o, this.uint16[f + 7] = l, this.int16[f + 8] = u, this.int16[f + 9] = c, this.int16[f + 10] = h, this.int16[f + 11] = p, t;\n      }\n\n    }\n\n    ki.prototype.bytesPerElement = 24, kn(\"StructArrayLayout4i4ui4i24\", ki);\n\n    class Si extends yi {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }\n\n      emplaceBack(t, e, r) {\n        const n = this.length;\n        return this.resize(n + 1), this.emplace(n, t, e, r);\n      }\n\n      emplace(t, e, r, n) {\n        const i = 3 * t;\n        return this.float32[i + 0] = e, this.float32[i + 1] = r, this.float32[i + 2] = n, t;\n      }\n\n    }\n\n    Si.prototype.bytesPerElement = 12, kn(\"StructArrayLayout3f12\", Si);\n\n    class zi extends yi {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);\n      }\n\n      emplaceBack(t) {\n        const e = this.length;\n        return this.resize(e + 1), this.emplace(e, t);\n      }\n\n      emplace(t, e) {\n        return this.uint32[1 * t + 0] = e, t;\n      }\n\n    }\n\n    zi.prototype.bytesPerElement = 4, kn(\"StructArrayLayout1ul4\", zi);\n\n    class Ii extends yi {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);\n      }\n\n      emplaceBack(t, e, r, n, i, s, a, o, l) {\n        const u = this.length;\n        return this.resize(u + 1), this.emplace(u, t, e, r, n, i, s, a, o, l);\n      }\n\n      emplace(t, e, r, n, i, s, a, o, l, u) {\n        const c = 10 * t,\n              h = 5 * t;\n        return this.int16[c + 0] = e, this.int16[c + 1] = r, this.int16[c + 2] = n, this.int16[c + 3] = i, this.int16[c + 4] = s, this.int16[c + 5] = a, this.uint32[h + 3] = o, this.uint16[c + 8] = l, this.uint16[c + 9] = u, t;\n      }\n\n    }\n\n    Ii.prototype.bytesPerElement = 20, kn(\"StructArrayLayout6i1ul2ui20\", Ii);\n\n    class Mi extends yi {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);\n      }\n\n      emplaceBack(t, e, r, n, i, s) {\n        const a = this.length;\n        return this.resize(a + 1), this.emplace(a, t, e, r, n, i, s);\n      }\n\n      emplace(t, e, r, n, i, s, a) {\n        const o = 6 * t;\n        return this.int16[o + 0] = e, this.int16[o + 1] = r, this.int16[o + 2] = n, this.int16[o + 3] = i, this.int16[o + 4] = s, this.int16[o + 5] = a, t;\n      }\n\n    }\n\n    Mi.prototype.bytesPerElement = 12, kn(\"StructArrayLayout2i2i2i12\", Mi);\n\n    class Bi extends yi {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);\n      }\n\n      emplaceBack(t, e, r, n, i) {\n        const s = this.length;\n        return this.resize(s + 1), this.emplace(s, t, e, r, n, i);\n      }\n\n      emplace(t, e, r, n, i, s) {\n        const a = 4 * t,\n              o = 8 * t;\n        return this.float32[a + 0] = e, this.float32[a + 1] = r, this.float32[a + 2] = n, this.int16[o + 6] = i, this.int16[o + 7] = s, t;\n      }\n\n    }\n\n    Bi.prototype.bytesPerElement = 16, kn(\"StructArrayLayout2f1f2i16\", Bi);\n\n    class Ci extends yi {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }\n\n      emplaceBack(t, e, r, n) {\n        const i = this.length;\n        return this.resize(i + 1), this.emplace(i, t, e, r, n);\n      }\n\n      emplace(t, e, r, n, i) {\n        const s = 12 * t,\n              a = 3 * t;\n        return this.uint8[s + 0] = e, this.uint8[s + 1] = r, this.float32[a + 1] = n, this.float32[a + 2] = i, t;\n      }\n\n    }\n\n    Ci.prototype.bytesPerElement = 12, kn(\"StructArrayLayout2ub2f12\", Ci);\n\n    class Pi extends yi {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);\n      }\n\n      emplaceBack(t, e, r) {\n        const n = this.length;\n        return this.resize(n + 1), this.emplace(n, t, e, r);\n      }\n\n      emplace(t, e, r, n) {\n        const i = 3 * t;\n        return this.uint16[i + 0] = e, this.uint16[i + 1] = r, this.uint16[i + 2] = n, t;\n      }\n\n    }\n\n    Pi.prototype.bytesPerElement = 6, kn(\"StructArrayLayout3ui6\", Pi);\n\n    class Vi extends yi {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }\n\n      emplaceBack(t, e, r, n, i, s, a, o, l, u, c, h, p, f, d, y, m) {\n        const g = this.length;\n        return this.resize(g + 1), this.emplace(g, t, e, r, n, i, s, a, o, l, u, c, h, p, f, d, y, m);\n      }\n\n      emplace(t, e, r, n, i, s, a, o, l, u, c, h, p, f, d, y, m, g) {\n        const x = 24 * t,\n              v = 12 * t,\n              b = 48 * t;\n        return this.int16[x + 0] = e, this.int16[x + 1] = r, this.uint16[x + 2] = n, this.uint16[x + 3] = i, this.uint32[v + 2] = s, this.uint32[v + 3] = a, this.uint32[v + 4] = o, this.uint16[x + 10] = l, this.uint16[x + 11] = u, this.uint16[x + 12] = c, this.float32[v + 7] = h, this.float32[v + 8] = p, this.uint8[b + 36] = f, this.uint8[b + 37] = d, this.uint8[b + 38] = y, this.uint32[v + 10] = m, this.int16[x + 22] = g, t;\n      }\n\n    }\n\n    Vi.prototype.bytesPerElement = 48, kn(\"StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48\", Vi);\n\n    class Ei extends yi {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }\n\n      emplaceBack(t, e, r, n, i, s, a, o, l, u, c, h, p, f, d, y, m, g, x, v, b, w, _, A, k, S, z, I) {\n        const M = this.length;\n        return this.resize(M + 1), this.emplace(M, t, e, r, n, i, s, a, o, l, u, c, h, p, f, d, y, m, g, x, v, b, w, _, A, k, S, z, I);\n      }\n\n      emplace(t, e, r, n, i, s, a, o, l, u, c, h, p, f, d, y, m, g, x, v, b, w, _, A, k, S, z, I, M) {\n        const B = 34 * t,\n              C = 17 * t;\n        return this.int16[B + 0] = e, this.int16[B + 1] = r, this.int16[B + 2] = n, this.int16[B + 3] = i, this.int16[B + 4] = s, this.int16[B + 5] = a, this.int16[B + 6] = o, this.int16[B + 7] = l, this.uint16[B + 8] = u, this.uint16[B + 9] = c, this.uint16[B + 10] = h, this.uint16[B + 11] = p, this.uint16[B + 12] = f, this.uint16[B + 13] = d, this.uint16[B + 14] = y, this.uint16[B + 15] = m, this.uint16[B + 16] = g, this.uint16[B + 17] = x, this.uint16[B + 18] = v, this.uint16[B + 19] = b, this.uint16[B + 20] = w, this.uint16[B + 21] = _, this.uint16[B + 22] = A, this.uint32[C + 12] = k, this.float32[C + 13] = S, this.float32[C + 14] = z, this.float32[C + 15] = I, this.float32[C + 16] = M, t;\n      }\n\n    }\n\n    Ei.prototype.bytesPerElement = 68, kn(\"StructArrayLayout8i15ui1ul4f68\", Ei);\n\n    class Fi extends yi {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }\n\n      emplaceBack(t) {\n        const e = this.length;\n        return this.resize(e + 1), this.emplace(e, t);\n      }\n\n      emplace(t, e) {\n        return this.float32[1 * t + 0] = e, t;\n      }\n\n    }\n\n    Fi.prototype.bytesPerElement = 4, kn(\"StructArrayLayout1f4\", Fi);\n\n    class Ti extends yi {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);\n      }\n\n      emplaceBack(t, e, r) {\n        const n = this.length;\n        return this.resize(n + 1), this.emplace(n, t, e, r);\n      }\n\n      emplace(t, e, r, n) {\n        const i = 3 * t;\n        return this.int16[i + 0] = e, this.int16[i + 1] = r, this.int16[i + 2] = n, t;\n      }\n\n    }\n\n    Ti.prototype.bytesPerElement = 6, kn(\"StructArrayLayout3i6\", Ti);\n\n    class Li extends yi {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);\n      }\n\n      emplaceBack(t, e, r) {\n        const n = this.length;\n        return this.resize(n + 1), this.emplace(n, t, e, r);\n      }\n\n      emplace(t, e, r, n) {\n        const i = 4 * t;\n        return this.uint32[2 * t + 0] = e, this.uint16[i + 2] = r, this.uint16[i + 3] = n, t;\n      }\n\n    }\n\n    Li.prototype.bytesPerElement = 8, kn(\"StructArrayLayout1ul2ui8\", Li);\n\n    class Di extends yi {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);\n      }\n\n      emplaceBack(t, e) {\n        const r = this.length;\n        return this.resize(r + 1), this.emplace(r, t, e);\n      }\n\n      emplace(t, e, r) {\n        const n = 2 * t;\n        return this.uint16[n + 0] = e, this.uint16[n + 1] = r, t;\n      }\n\n    }\n\n    Di.prototype.bytesPerElement = 4, kn(\"StructArrayLayout2ui4\", Di);\n\n    class $i extends yi {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);\n      }\n\n      emplaceBack(t) {\n        const e = this.length;\n        return this.resize(e + 1), this.emplace(e, t);\n      }\n\n      emplace(t, e) {\n        return this.uint16[1 * t + 0] = e, t;\n      }\n\n    }\n\n    $i.prototype.bytesPerElement = 2, kn(\"StructArrayLayout1ui2\", $i);\n\n    class Oi extends yi {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }\n\n      emplaceBack(t, e, r, n) {\n        const i = this.length;\n        return this.resize(i + 1), this.emplace(i, t, e, r, n);\n      }\n\n      emplace(t, e, r, n, i) {\n        const s = 4 * t;\n        return this.float32[s + 0] = e, this.float32[s + 1] = r, this.float32[s + 2] = n, this.float32[s + 3] = i, t;\n      }\n\n    }\n\n    Oi.prototype.bytesPerElement = 16, kn(\"StructArrayLayout4f16\", Oi);\n\n    class Ri extends di {\n      get anchorPointX() {\n        return this._structArray.int16[this._pos2 + 0];\n      }\n\n      get anchorPointY() {\n        return this._structArray.int16[this._pos2 + 1];\n      }\n\n      get x1() {\n        return this._structArray.int16[this._pos2 + 2];\n      }\n\n      get y1() {\n        return this._structArray.int16[this._pos2 + 3];\n      }\n\n      get x2() {\n        return this._structArray.int16[this._pos2 + 4];\n      }\n\n      get y2() {\n        return this._structArray.int16[this._pos2 + 5];\n      }\n\n      get featureIndex() {\n        return this._structArray.uint32[this._pos4 + 3];\n      }\n\n      get sourceLayerIndex() {\n        return this._structArray.uint16[this._pos2 + 8];\n      }\n\n      get bucketIndex() {\n        return this._structArray.uint16[this._pos2 + 9];\n      }\n\n      get anchorPoint() {\n        return new S(this.anchorPointX, this.anchorPointY);\n      }\n\n    }\n\n    Ri.prototype.size = 20;\n\n    class Ui extends Ii {\n      get(t) {\n        return new Ri(this, t);\n      }\n\n    }\n\n    kn(\"CollisionBoxArray\", Ui);\n\n    class qi extends di {\n      get anchorX() {\n        return this._structArray.int16[this._pos2 + 0];\n      }\n\n      get anchorY() {\n        return this._structArray.int16[this._pos2 + 1];\n      }\n\n      get glyphStartIndex() {\n        return this._structArray.uint16[this._pos2 + 2];\n      }\n\n      get numGlyphs() {\n        return this._structArray.uint16[this._pos2 + 3];\n      }\n\n      get vertexStartIndex() {\n        return this._structArray.uint32[this._pos4 + 2];\n      }\n\n      get lineStartIndex() {\n        return this._structArray.uint32[this._pos4 + 3];\n      }\n\n      get lineLength() {\n        return this._structArray.uint32[this._pos4 + 4];\n      }\n\n      get segment() {\n        return this._structArray.uint16[this._pos2 + 10];\n      }\n\n      get lowerSize() {\n        return this._structArray.uint16[this._pos2 + 11];\n      }\n\n      get upperSize() {\n        return this._structArray.uint16[this._pos2 + 12];\n      }\n\n      get lineOffsetX() {\n        return this._structArray.float32[this._pos4 + 7];\n      }\n\n      get lineOffsetY() {\n        return this._structArray.float32[this._pos4 + 8];\n      }\n\n      get writingMode() {\n        return this._structArray.uint8[this._pos1 + 36];\n      }\n\n      get placedOrientation() {\n        return this._structArray.uint8[this._pos1 + 37];\n      }\n\n      set placedOrientation(t) {\n        this._structArray.uint8[this._pos1 + 37] = t;\n      }\n\n      get hidden() {\n        return this._structArray.uint8[this._pos1 + 38];\n      }\n\n      set hidden(t) {\n        this._structArray.uint8[this._pos1 + 38] = t;\n      }\n\n      get crossTileID() {\n        return this._structArray.uint32[this._pos4 + 10];\n      }\n\n      set crossTileID(t) {\n        this._structArray.uint32[this._pos4 + 10] = t;\n      }\n\n      get associatedIconIndex() {\n        return this._structArray.int16[this._pos2 + 22];\n      }\n\n    }\n\n    qi.prototype.size = 48;\n\n    class ji extends Vi {\n      get(t) {\n        return new qi(this, t);\n      }\n\n    }\n\n    kn(\"PlacedSymbolArray\", ji);\n\n    class Ni extends di {\n      get anchorX() {\n        return this._structArray.int16[this._pos2 + 0];\n      }\n\n      get anchorY() {\n        return this._structArray.int16[this._pos2 + 1];\n      }\n\n      get rightJustifiedTextSymbolIndex() {\n        return this._structArray.int16[this._pos2 + 2];\n      }\n\n      get centerJustifiedTextSymbolIndex() {\n        return this._structArray.int16[this._pos2 + 3];\n      }\n\n      get leftJustifiedTextSymbolIndex() {\n        return this._structArray.int16[this._pos2 + 4];\n      }\n\n      get verticalPlacedTextSymbolIndex() {\n        return this._structArray.int16[this._pos2 + 5];\n      }\n\n      get placedIconSymbolIndex() {\n        return this._structArray.int16[this._pos2 + 6];\n      }\n\n      get verticalPlacedIconSymbolIndex() {\n        return this._structArray.int16[this._pos2 + 7];\n      }\n\n      get key() {\n        return this._structArray.uint16[this._pos2 + 8];\n      }\n\n      get textBoxStartIndex() {\n        return this._structArray.uint16[this._pos2 + 9];\n      }\n\n      get textBoxEndIndex() {\n        return this._structArray.uint16[this._pos2 + 10];\n      }\n\n      get verticalTextBoxStartIndex() {\n        return this._structArray.uint16[this._pos2 + 11];\n      }\n\n      get verticalTextBoxEndIndex() {\n        return this._structArray.uint16[this._pos2 + 12];\n      }\n\n      get iconBoxStartIndex() {\n        return this._structArray.uint16[this._pos2 + 13];\n      }\n\n      get iconBoxEndIndex() {\n        return this._structArray.uint16[this._pos2 + 14];\n      }\n\n      get verticalIconBoxStartIndex() {\n        return this._structArray.uint16[this._pos2 + 15];\n      }\n\n      get verticalIconBoxEndIndex() {\n        return this._structArray.uint16[this._pos2 + 16];\n      }\n\n      get featureIndex() {\n        return this._structArray.uint16[this._pos2 + 17];\n      }\n\n      get numHorizontalGlyphVertices() {\n        return this._structArray.uint16[this._pos2 + 18];\n      }\n\n      get numVerticalGlyphVertices() {\n        return this._structArray.uint16[this._pos2 + 19];\n      }\n\n      get numIconVertices() {\n        return this._structArray.uint16[this._pos2 + 20];\n      }\n\n      get numVerticalIconVertices() {\n        return this._structArray.uint16[this._pos2 + 21];\n      }\n\n      get useRuntimeCollisionCircles() {\n        return this._structArray.uint16[this._pos2 + 22];\n      }\n\n      get crossTileID() {\n        return this._structArray.uint32[this._pos4 + 12];\n      }\n\n      set crossTileID(t) {\n        this._structArray.uint32[this._pos4 + 12] = t;\n      }\n\n      get textBoxScale() {\n        return this._structArray.float32[this._pos4 + 13];\n      }\n\n      get textOffset0() {\n        return this._structArray.float32[this._pos4 + 14];\n      }\n\n      get textOffset1() {\n        return this._structArray.float32[this._pos4 + 15];\n      }\n\n      get collisionCircleDiameter() {\n        return this._structArray.float32[this._pos4 + 16];\n      }\n\n    }\n\n    Ni.prototype.size = 68;\n\n    class Ki extends Ei {\n      get(t) {\n        return new Ni(this, t);\n      }\n\n    }\n\n    kn(\"SymbolInstanceArray\", Ki);\n\n    class Zi extends Fi {\n      getoffsetX(t) {\n        return this.float32[1 * t + 0];\n      }\n\n    }\n\n    kn(\"GlyphOffsetArray\", Zi);\n\n    class Gi extends Ti {\n      getx(t) {\n        return this.int16[3 * t + 0];\n      }\n\n      gety(t) {\n        return this.int16[3 * t + 1];\n      }\n\n      gettileUnitDistanceFromAnchor(t) {\n        return this.int16[3 * t + 2];\n      }\n\n    }\n\n    kn(\"SymbolLineVertexArray\", Gi);\n\n    class Ji extends di {\n      get featureIndex() {\n        return this._structArray.uint32[this._pos4 + 0];\n      }\n\n      get sourceLayerIndex() {\n        return this._structArray.uint16[this._pos2 + 2];\n      }\n\n      get bucketIndex() {\n        return this._structArray.uint16[this._pos2 + 3];\n      }\n\n    }\n\n    Ji.prototype.size = 8;\n\n    class Xi extends Li {\n      get(t) {\n        return new Ji(this, t);\n      }\n\n    }\n\n    kn(\"FeatureIndexArray\", Xi);\n\n    class Yi extends xi {}\n\n    class Hi extends xi {}\n\n    class Wi extends bi {}\n\n    class Qi extends wi {}\n\n    class ts extends _i {}\n\n    class es extends Ai {}\n\n    class rs extends ki {}\n\n    class ns extends Si {}\n\n    class is extends zi {}\n\n    class ss extends Mi {}\n\n    class as extends Ci {}\n\n    class os extends Pi {}\n\n    class ls extends Di {}\n\n    const us = mi([{\n      name: \"a_pos\",\n      components: 2,\n      type: \"Int16\"\n    }], 4),\n          {\n      members: cs\n    } = us;\n\n    class hs {\n      constructor() {\n        let t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n        this.segments = t;\n      }\n\n      prepareSegment(t, e, r, n) {\n        let i = this.segments[this.segments.length - 1];\n        return t > hs.MAX_VERTEX_ARRAY_LENGTH && d(`Max vertices per segment is ${hs.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t}`), (!i || i.vertexLength + t > hs.MAX_VERTEX_ARRAY_LENGTH || i.sortKey !== n) && (i = {\n          vertexOffset: e.length,\n          primitiveOffset: r.length,\n          vertexLength: 0,\n          primitiveLength: 0\n        }, void 0 !== n && (i.sortKey = n), this.segments.push(i)), i;\n      }\n\n      get() {\n        return this.segments;\n      }\n\n      destroy() {\n        for (const t of this.segments) for (const e in t.vaos) t.vaos[e].destroy();\n      }\n\n      static simpleSegment(t, e, r, n) {\n        return new hs([{\n          vertexOffset: t,\n          primitiveOffset: e,\n          vertexLength: r,\n          primitiveLength: n,\n          vaos: {},\n          sortKey: 0\n        }]);\n      }\n\n    }\n\n    function ps(t, e) {\n      return 256 * (t = s(Math.floor(t), 0, 255)) + s(Math.floor(e), 0, 255);\n    }\n\n    hs.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, kn(\"SegmentVector\", hs);\n    const fs = mi([{\n      name: \"a_pattern_from\",\n      components: 4,\n      type: \"Uint16\"\n    }, {\n      name: \"a_pattern_to\",\n      components: 4,\n      type: \"Uint16\"\n    }, {\n      name: \"a_pixel_ratio_from\",\n      components: 1,\n      type: \"Uint16\"\n    }, {\n      name: \"a_pixel_ratio_to\",\n      components: 1,\n      type: \"Uint16\"\n    }]);\n    var ds = {\n      exports: {}\n    },\n        ys = {\n      exports: {}\n    };\n\n    ys.exports = function (t, e) {\n      var r, n, i, s, a, o, l, u;\n\n      for (n = t.length - (r = 3 & t.length), i = e, a = 3432918353, o = 461845907, u = 0; u < n;) l = 255 & t.charCodeAt(u) | (255 & t.charCodeAt(++u)) << 8 | (255 & t.charCodeAt(++u)) << 16 | (255 & t.charCodeAt(++u)) << 24, ++u, i = 27492 + (65535 & (s = 5 * (65535 & (i = (i ^= l = (65535 & (l = (l = (65535 & l) * a + (((l >>> 16) * a & 65535) << 16) & 4294967295) << 15 | l >>> 17)) * o + (((l >>> 16) * o & 65535) << 16) & 4294967295) << 13 | i >>> 19)) + ((5 * (i >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (s >>> 16) & 65535) << 16);\n\n      switch (l = 0, r) {\n        case 3:\n          l ^= (255 & t.charCodeAt(u + 2)) << 16;\n\n        case 2:\n          l ^= (255 & t.charCodeAt(u + 1)) << 8;\n\n        case 1:\n          i ^= l = (65535 & (l = (l = (65535 & (l ^= 255 & t.charCodeAt(u))) * a + (((l >>> 16) * a & 65535) << 16) & 4294967295) << 15 | l >>> 17)) * o + (((l >>> 16) * o & 65535) << 16) & 4294967295;\n      }\n\n      return i ^= t.length, i = 2246822507 * (65535 & (i ^= i >>> 16)) + ((2246822507 * (i >>> 16) & 65535) << 16) & 4294967295, i = 3266489909 * (65535 & (i ^= i >>> 13)) + ((3266489909 * (i >>> 16) & 65535) << 16) & 4294967295, (i ^= i >>> 16) >>> 0;\n    };\n\n    var ms = {\n      exports: {}\n    };\n\n    ms.exports = function (t, e) {\n      for (var r, n = t.length, i = e ^ n, s = 0; n >= 4;) r = 1540483477 * (65535 & (r = 255 & t.charCodeAt(s) | (255 & t.charCodeAt(++s)) << 8 | (255 & t.charCodeAt(++s)) << 16 | (255 & t.charCodeAt(++s)) << 24)) + ((1540483477 * (r >>> 16) & 65535) << 16), i = 1540483477 * (65535 & i) + ((1540483477 * (i >>> 16) & 65535) << 16) ^ (r = 1540483477 * (65535 & (r ^= r >>> 24)) + ((1540483477 * (r >>> 16) & 65535) << 16)), n -= 4, ++s;\n\n      switch (n) {\n        case 3:\n          i ^= (255 & t.charCodeAt(s + 2)) << 16;\n\n        case 2:\n          i ^= (255 & t.charCodeAt(s + 1)) << 8;\n\n        case 1:\n          i = 1540483477 * (65535 & (i ^= 255 & t.charCodeAt(s))) + ((1540483477 * (i >>> 16) & 65535) << 16);\n      }\n\n      return i = 1540483477 * (65535 & (i ^= i >>> 13)) + ((1540483477 * (i >>> 16) & 65535) << 16), (i ^= i >>> 15) >>> 0;\n    };\n\n    var gs = ys.exports,\n        xs = ms.exports;\n    ds.exports = gs, ds.exports.murmur3 = gs, ds.exports.murmur2 = xs;\n    var vs = ds.exports;\n\n    class bs {\n      constructor() {\n        this.ids = [], this.positions = [], this.indexed = !1;\n      }\n\n      add(t, e, r, n) {\n        this.ids.push(ws(t)), this.positions.push(e, r, n);\n      }\n\n      getPositions(t) {\n        const e = ws(t);\n        let r = 0,\n            n = this.ids.length - 1;\n\n        for (; r < n;) {\n          const t = r + n >> 1;\n          this.ids[t] >= e ? n = t : r = t + 1;\n        }\n\n        const i = [];\n\n        for (; this.ids[r] === e;) i.push({\n          index: this.positions[3 * r],\n          start: this.positions[3 * r + 1],\n          end: this.positions[3 * r + 2]\n        }), r++;\n\n        return i;\n      }\n\n      static serialize(t, e) {\n        const r = new Float64Array(t.ids),\n              n = new Uint32Array(t.positions);\n        return _s(r, n, 0, r.length - 1), e && e.push(r.buffer, n.buffer), {\n          ids: r,\n          positions: n\n        };\n      }\n\n      static deserialize(t) {\n        const e = new bs();\n        return e.ids = t.ids, e.positions = t.positions, e.indexed = !0, e;\n      }\n\n    }\n\n    function ws(t) {\n      const e = +t;\n      return !isNaN(e) && e <= Number.MAX_SAFE_INTEGER ? e : vs(String(t));\n    }\n\n    function _s(t, e, r, n) {\n      for (; r < n;) {\n        const i = t[r + n >> 1];\n        let s = r - 1,\n            a = n + 1;\n\n        for (;;) {\n          do {\n            s++;\n          } while (t[s] < i);\n\n          do {\n            a--;\n          } while (t[a] > i);\n\n          if (s >= a) break;\n          As(t, s, a), As(e, 3 * s, 3 * a), As(e, 3 * s + 1, 3 * a + 1), As(e, 3 * s + 2, 3 * a + 2);\n        }\n\n        a - r < n - a ? (_s(t, e, r, a), r = a + 1) : (_s(t, e, a + 1, n), n = a);\n      }\n    }\n\n    function As(t, e, r) {\n      const n = t[e];\n      t[e] = t[r], t[r] = n;\n    }\n\n    kn(\"FeaturePositionMap\", bs);\n\n    class ks {\n      constructor(t, e) {\n        this.gl = t.gl, this.location = e;\n      }\n\n    }\n\n    class Ss extends ks {\n      constructor(t, e) {\n        super(t, e), this.current = 0;\n      }\n\n      set(t) {\n        this.current !== t && (this.current = t, this.gl.uniform1f(this.location, t));\n      }\n\n    }\n\n    class zs extends ks {\n      constructor(t, e) {\n        super(t, e), this.current = [0, 0, 0, 0];\n      }\n\n      set(t) {\n        t[0] === this.current[0] && t[1] === this.current[1] && t[2] === this.current[2] && t[3] === this.current[3] || (this.current = t, this.gl.uniform4f(this.location, t[0], t[1], t[2], t[3]));\n      }\n\n    }\n\n    class Is extends ks {\n      constructor(t, e) {\n        super(t, e), this.current = Et.transparent;\n      }\n\n      set(t) {\n        t.r === this.current.r && t.g === this.current.g && t.b === this.current.b && t.a === this.current.a || (this.current = t, this.gl.uniform4f(this.location, t.r, t.g, t.b, t.a));\n      }\n\n    }\n\n    const Ms = new Float32Array(16);\n\n    function Bs(t) {\n      return [ps(255 * t.r, 255 * t.g), ps(255 * t.b, 255 * t.a)];\n    }\n\n    class Cs {\n      constructor(t, e, r) {\n        this.value = t, this.uniformNames = e.map(t => `u_${t}`), this.type = r;\n      }\n\n      setUniform(t, e, r) {\n        t.set(r.constantOr(this.value));\n      }\n\n      getBinding(t, e, r) {\n        return \"color\" === this.type ? new Is(t, e) : new Ss(t, e);\n      }\n\n    }\n\n    class Ps {\n      constructor(t, e) {\n        this.uniformNames = e.map(t => `u_${t}`), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1;\n      }\n\n      setConstantPatternPositions(t, e) {\n        this.pixelRatioFrom = e.pixelRatio, this.pixelRatioTo = t.pixelRatio, this.patternFrom = e.tlbr, this.patternTo = t.tlbr;\n      }\n\n      setUniform(t, e, r, n) {\n        const i = \"u_pattern_to\" === n ? this.patternTo : \"u_pattern_from\" === n ? this.patternFrom : \"u_pixel_ratio_to\" === n ? this.pixelRatioTo : \"u_pixel_ratio_from\" === n ? this.pixelRatioFrom : null;\n        i && t.set(i);\n      }\n\n      getBinding(t, e, r) {\n        return \"u_pattern\" === r.substr(0, 9) ? new zs(t, e) : new Ss(t, e);\n      }\n\n    }\n\n    class Vs {\n      constructor(t, e, r, n) {\n        this.expression = t, this.type = r, this.maxValue = 0, this.paintVertexAttributes = e.map(t => ({\n          name: `a_${t}`,\n          type: \"Float32\",\n          components: \"color\" === r ? 2 : 1,\n          offset: 0\n        })), this.paintVertexArray = new n();\n      }\n\n      populatePaintArray(t, e, r, n, i) {\n        const s = this.paintVertexArray.length,\n              a = this.expression.evaluate(new Yn(0), e, {}, n, [], i);\n        this.paintVertexArray.resize(t), this._setPaintValue(s, t, a);\n      }\n\n      updatePaintArray(t, e, r, n) {\n        const i = this.expression.evaluate({\n          zoom: 0\n        }, r, n);\n\n        this._setPaintValue(t, e, i);\n      }\n\n      _setPaintValue(t, e, r) {\n        if (\"color\" === this.type) {\n          const n = Bs(r);\n\n          for (let r = t; r < e; r++) this.paintVertexArray.emplace(r, n[0], n[1]);\n        } else {\n          for (let n = t; n < e; n++) this.paintVertexArray.emplace(n, r);\n\n          this.maxValue = Math.max(this.maxValue, Math.abs(r));\n        }\n      }\n\n      upload(t) {\n        this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));\n      }\n\n      destroy() {\n        this.paintVertexBuffer && this.paintVertexBuffer.destroy();\n      }\n\n    }\n\n    class Es {\n      constructor(t, e, r, n, i, s) {\n        this.expression = t, this.uniformNames = e.map(t => `u_${t}_t`), this.type = r, this.useIntegerZoom = n, this.zoom = i, this.maxValue = 0, this.paintVertexAttributes = e.map(t => ({\n          name: `a_${t}`,\n          type: \"Float32\",\n          components: \"color\" === r ? 4 : 2,\n          offset: 0\n        })), this.paintVertexArray = new s();\n      }\n\n      populatePaintArray(t, e, r, n, i) {\n        const s = this.expression.evaluate(new Yn(this.zoom), e, {}, n, [], i),\n              a = this.expression.evaluate(new Yn(this.zoom + 1), e, {}, n, [], i),\n              o = this.paintVertexArray.length;\n        this.paintVertexArray.resize(t), this._setPaintValue(o, t, s, a);\n      }\n\n      updatePaintArray(t, e, r, n) {\n        const i = this.expression.evaluate({\n          zoom: this.zoom\n        }, r, n),\n              s = this.expression.evaluate({\n          zoom: this.zoom + 1\n        }, r, n);\n\n        this._setPaintValue(t, e, i, s);\n      }\n\n      _setPaintValue(t, e, r, n) {\n        if (\"color\" === this.type) {\n          const i = Bs(r),\n                s = Bs(n);\n\n          for (let r = t; r < e; r++) this.paintVertexArray.emplace(r, i[0], i[1], s[0], s[1]);\n        } else {\n          for (let i = t; i < e; i++) this.paintVertexArray.emplace(i, r, n);\n\n          this.maxValue = Math.max(this.maxValue, Math.abs(r), Math.abs(n));\n        }\n      }\n\n      upload(t) {\n        this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));\n      }\n\n      destroy() {\n        this.paintVertexBuffer && this.paintVertexBuffer.destroy();\n      }\n\n      setUniform(t, e) {\n        const r = this.useIntegerZoom ? Math.floor(e.zoom) : e.zoom,\n              n = s(this.expression.interpolationFactor(r, this.zoom, this.zoom + 1), 0, 1);\n        t.set(n);\n      }\n\n      getBinding(t, e, r) {\n        return new Ss(t, e);\n      }\n\n    }\n\n    class Fs {\n      constructor(t, e, r, n, i, s) {\n        this.expression = t, this.type = e, this.useIntegerZoom = r, this.zoom = n, this.layerId = s, this.zoomInPaintVertexArray = new i(), this.zoomOutPaintVertexArray = new i();\n      }\n\n      populatePaintArray(t, e, r) {\n        const n = this.zoomInPaintVertexArray.length;\n        this.zoomInPaintVertexArray.resize(t), this.zoomOutPaintVertexArray.resize(t), this._setPaintValues(n, t, e.patterns && e.patterns[this.layerId], r);\n      }\n\n      updatePaintArray(t, e, r, n, i) {\n        this._setPaintValues(t, e, r.patterns && r.patterns[this.layerId], i);\n      }\n\n      _setPaintValues(t, e, r, n) {\n        if (!n || !r) return;\n        const {\n          min: i,\n          mid: s,\n          max: a\n        } = r,\n              o = n[i],\n              l = n[s],\n              u = n[a];\n        if (o && l && u) for (let r = t; r < e; r++) this.zoomInPaintVertexArray.emplace(r, l.tl[0], l.tl[1], l.br[0], l.br[1], o.tl[0], o.tl[1], o.br[0], o.br[1], l.pixelRatio, o.pixelRatio), this.zoomOutPaintVertexArray.emplace(r, l.tl[0], l.tl[1], l.br[0], l.br[1], u.tl[0], u.tl[1], u.br[0], u.br[1], l.pixelRatio, u.pixelRatio);\n      }\n\n      upload(t) {\n        this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer && (this.zoomInPaintVertexBuffer = t.createVertexBuffer(this.zoomInPaintVertexArray, fs.members, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = t.createVertexBuffer(this.zoomOutPaintVertexArray, fs.members, this.expression.isStateDependent));\n      }\n\n      destroy() {\n        this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy();\n      }\n\n    }\n\n    class Ts {\n      constructor(t, e, r) {\n        this.binders = {}, this._buffers = [];\n        const n = [];\n\n        for (const i in t.paint._values) {\n          if (!r(i)) continue;\n          const s = t.paint.get(i);\n          if (!(s instanceof ni && xr(s.property.specification))) continue;\n          const a = Ds(i, t.type),\n                o = s.value,\n                l = s.property.specification.type,\n                u = s.property.useIntegerZoom,\n                c = s.property.specification[\"property-type\"],\n                h = \"cross-faded\" === c || \"cross-faded-data-driven\" === c;\n          if (\"constant\" === o.kind) this.binders[i] = h ? new Ps(o.value, a) : new Cs(o.value, a, l), n.push(`/u_${i}`);else if (\"source\" === o.kind || h) {\n            const r = $s(i, l, \"source\");\n            this.binders[i] = h ? new Fs(o, l, u, e, r, t.id) : new Vs(o, a, l, r), n.push(`/a_${i}`);\n          } else {\n            const t = $s(i, l, \"composite\");\n            this.binders[i] = new Es(o, a, l, u, e, t), n.push(`/z_${i}`);\n          }\n        }\n\n        this.cacheKey = n.sort().join(\"\");\n      }\n\n      getMaxValue(t) {\n        const e = this.binders[t];\n        return e instanceof Vs || e instanceof Es ? e.maxValue : 0;\n      }\n\n      populatePaintArrays(t, e, r, n, i) {\n        for (const s in this.binders) {\n          const a = this.binders[s];\n          (a instanceof Vs || a instanceof Es || a instanceof Fs) && a.populatePaintArray(t, e, r, n, i);\n        }\n      }\n\n      setConstantPatternPositions(t, e) {\n        for (const r in this.binders) {\n          const n = this.binders[r];\n          n instanceof Ps && n.setConstantPatternPositions(t, e);\n        }\n      }\n\n      updatePaintArrays(t, e, r, n, i) {\n        let s = !1;\n\n        for (const a in t) {\n          const o = e.getPositions(a);\n\n          for (const e of o) {\n            const o = r.feature(e.index);\n\n            for (const r in this.binders) {\n              const l = this.binders[r];\n\n              if ((l instanceof Vs || l instanceof Es || l instanceof Fs) && !0 === l.expression.isStateDependent) {\n                const u = n.paint.get(r);\n                l.expression = u.value, l.updatePaintArray(e.start, e.end, o, t[a], i), s = !0;\n              }\n            }\n          }\n        }\n\n        return s;\n      }\n\n      defines() {\n        const t = [];\n\n        for (const e in this.binders) {\n          const r = this.binders[e];\n          (r instanceof Cs || r instanceof Ps) && t.push(...r.uniformNames.map(t => `#define HAS_UNIFORM_${t}`));\n        }\n\n        return t;\n      }\n\n      getBinderAttributes() {\n        const t = [];\n\n        for (const e in this.binders) {\n          const r = this.binders[e];\n          if (r instanceof Vs || r instanceof Es) for (let e = 0; e < r.paintVertexAttributes.length; e++) t.push(r.paintVertexAttributes[e].name);else if (r instanceof Fs) for (let e = 0; e < fs.members.length; e++) t.push(fs.members[e].name);\n        }\n\n        return t;\n      }\n\n      getBinderUniforms() {\n        const t = [];\n\n        for (const e in this.binders) {\n          const r = this.binders[e];\n          if (r instanceof Cs || r instanceof Ps || r instanceof Es) for (const e of r.uniformNames) t.push(e);\n        }\n\n        return t;\n      }\n\n      getPaintVertexBuffers() {\n        return this._buffers;\n      }\n\n      getUniforms(t, e) {\n        const r = [];\n\n        for (const n in this.binders) {\n          const i = this.binders[n];\n          if (i instanceof Cs || i instanceof Ps || i instanceof Es) for (const s of i.uniformNames) if (e[s]) {\n            const a = i.getBinding(t, e[s], s);\n            r.push({\n              name: s,\n              property: n,\n              binding: a\n            });\n          }\n        }\n\n        return r;\n      }\n\n      setUniforms(t, e, r, n) {\n        for (const {\n          name: t,\n          property: i,\n          binding: s\n        } of e) this.binders[i].setUniform(s, n, r.get(i), t);\n      }\n\n      updatePaintBuffers(t) {\n        this._buffers = [];\n\n        for (const e in this.binders) {\n          const r = this.binders[e];\n\n          if (t && r instanceof Fs) {\n            const e = 2 === t.fromScale ? r.zoomInPaintVertexBuffer : r.zoomOutPaintVertexBuffer;\n            e && this._buffers.push(e);\n          } else (r instanceof Vs || r instanceof Es) && r.paintVertexBuffer && this._buffers.push(r.paintVertexBuffer);\n        }\n      }\n\n      upload(t) {\n        for (const e in this.binders) {\n          const r = this.binders[e];\n          (r instanceof Vs || r instanceof Es || r instanceof Fs) && r.upload(t);\n        }\n\n        this.updatePaintBuffers();\n      }\n\n      destroy() {\n        for (const t in this.binders) {\n          const e = this.binders[t];\n          (e instanceof Vs || e instanceof Es || e instanceof Fs) && e.destroy();\n        }\n      }\n\n    }\n\n    class Ls {\n      constructor(t, e) {\n        let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : () => !0;\n        this.programConfigurations = {};\n\n        for (const n of t) this.programConfigurations[n.id] = new Ts(n, e, r);\n\n        this.needsUpload = !1, this._featureMap = new bs(), this._bufferOffset = 0;\n      }\n\n      populatePaintArrays(t, e, r, n, i, s) {\n        for (const r in this.programConfigurations) this.programConfigurations[r].populatePaintArrays(t, e, n, i, s);\n\n        void 0 !== e.id && this._featureMap.add(e.id, r, this._bufferOffset, t), this._bufferOffset = t, this.needsUpload = !0;\n      }\n\n      updatePaintArrays(t, e, r, n) {\n        for (const i of r) this.needsUpload = this.programConfigurations[i.id].updatePaintArrays(t, this._featureMap, e, i, n) || this.needsUpload;\n      }\n\n      get(t) {\n        return this.programConfigurations[t];\n      }\n\n      upload(t) {\n        if (this.needsUpload) {\n          for (const e in this.programConfigurations) this.programConfigurations[e].upload(t);\n\n          this.needsUpload = !1;\n        }\n      }\n\n      destroy() {\n        for (const t in this.programConfigurations) this.programConfigurations[t].destroy();\n      }\n\n    }\n\n    function Ds(t, e) {\n      return {\n        \"text-opacity\": [\"opacity\"],\n        \"icon-opacity\": [\"opacity\"],\n        \"text-color\": [\"fill_color\"],\n        \"icon-color\": [\"fill_color\"],\n        \"text-halo-color\": [\"halo_color\"],\n        \"icon-halo-color\": [\"halo_color\"],\n        \"text-halo-blur\": [\"halo_blur\"],\n        \"icon-halo-blur\": [\"halo_blur\"],\n        \"text-halo-width\": [\"halo_width\"],\n        \"icon-halo-width\": [\"halo_width\"],\n        \"line-gap-width\": [\"gapwidth\"],\n        \"line-pattern\": [\"pattern_to\", \"pattern_from\", \"pixel_ratio_to\", \"pixel_ratio_from\"],\n        \"fill-pattern\": [\"pattern_to\", \"pattern_from\", \"pixel_ratio_to\", \"pixel_ratio_from\"],\n        \"fill-extrusion-pattern\": [\"pattern_to\", \"pattern_from\", \"pixel_ratio_to\", \"pixel_ratio_from\"]\n      }[t] || [t.replace(`${e}-`, \"\").replace(/-/g, \"_\")];\n    }\n\n    function $s(t, e, r) {\n      const n = {\n        color: {\n          source: _i,\n          composite: Oi\n        },\n        number: {\n          source: Fi,\n          composite: _i\n        }\n      },\n            i = function (t) {\n        return {\n          \"line-pattern\": {\n            source: es,\n            composite: es\n          },\n          \"fill-pattern\": {\n            source: es,\n            composite: es\n          },\n          \"fill-extrusion-pattern\": {\n            source: es,\n            composite: es\n          }\n        }[t];\n      }(t);\n\n      return i && i[r] || n[e][r];\n    }\n\n    kn(\"ConstantBinder\", Cs), kn(\"CrossFadedConstantBinder\", Ps), kn(\"SourceExpressionBinder\", Vs), kn(\"CrossFadedCompositeBinder\", Fs), kn(\"CompositeExpressionBinder\", Es), kn(\"ProgramConfiguration\", Ts, {\n      omit: [\"_buffers\"]\n    }), kn(\"ProgramConfigurationSet\", Ls);\n    var Os = 8192;\n    const Rs = Math.pow(2, 14) - 1,\n          Us = -Rs - 1;\n\n    function qs(t) {\n      const e = Os / t.extent,\n            r = t.loadGeometry();\n\n      for (let t = 0; t < r.length; t++) {\n        const n = r[t];\n\n        for (let t = 0; t < n.length; t++) {\n          const r = n[t],\n                i = Math.round(r.x * e),\n                a = Math.round(r.y * e);\n          r.x = s(i, Us, Rs), r.y = s(a, Us, Rs), (i < r.x || i > r.x + 1 || a < r.y || a > r.y + 1) && d(\"Geometry exceeds allowed extent, reduce your vector tile buffer size\");\n        }\n      }\n\n      return r;\n    }\n\n    function js(t, e) {\n      return {\n        type: t.type,\n        id: t.id,\n        properties: t.properties,\n        geometry: e ? qs(t) : []\n      };\n    }\n\n    function Ns(t, e, r, n, i) {\n      t.emplaceBack(2 * e + (n + 1) / 2, 2 * r + (i + 1) / 2);\n    }\n\n    class Ks {\n      constructor(t) {\n        this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(t => t.id), this.index = t.index, this.hasPattern = !1, this.layoutVertexArray = new Yi(), this.indexArray = new os(), this.segments = new hs(), this.programConfigurations = new Ls(t.layers, t.zoom), this.stateDependentLayerIds = this.layers.filter(t => t.isStateDependent()).map(t => t.id);\n      }\n\n      populate(t, e, r) {\n        const n = this.layers[0],\n              i = [];\n        let s = null,\n            a = !1;\n        \"circle\" === n.type && (s = n.layout.get(\"circle-sort-key\"), a = !s.isConstant());\n\n        for (const {\n          feature: e,\n          id: n,\n          index: o,\n          sourceLayerIndex: l\n        } of t) {\n          const t = this.layers[0]._featureFilter.needGeometry,\n                u = js(e, t);\n          if (!this.layers[0]._featureFilter.filter(new Yn(this.zoom), u, r)) continue;\n          const c = a ? s.evaluate(u, {}, r) : void 0,\n                h = {\n            id: n,\n            properties: e.properties,\n            type: e.type,\n            sourceLayerIndex: l,\n            index: o,\n            geometry: t ? u.geometry : qs(e),\n            patterns: {},\n            sortKey: c\n          };\n          i.push(h);\n        }\n\n        a && i.sort((t, e) => t.sortKey - e.sortKey);\n\n        for (const n of i) {\n          const {\n            geometry: i,\n            index: s,\n            sourceLayerIndex: a\n          } = n,\n                o = t[s].feature;\n          this.addFeature(n, i, s, r), e.featureIndex.insert(o, i, s, a, this.index);\n        }\n      }\n\n      update(t, e, r) {\n        this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, e, this.stateDependentLayers, r);\n      }\n\n      isEmpty() {\n        return 0 === this.layoutVertexArray.length;\n      }\n\n      uploadPending() {\n        return !this.uploaded || this.programConfigurations.needsUpload;\n      }\n\n      upload(t) {\n        this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, cs), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0;\n      }\n\n      destroy() {\n        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());\n      }\n\n      addFeature(t, e, r, n) {\n        for (const r of e) for (const e of r) {\n          const r = e.x,\n                n = e.y;\n          if (r < 0 || r >= Os || n < 0 || n >= Os) continue;\n          const i = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, t.sortKey),\n                s = i.vertexLength;\n          Ns(this.layoutVertexArray, r, n, -1, -1), Ns(this.layoutVertexArray, r, n, 1, -1), Ns(this.layoutVertexArray, r, n, 1, 1), Ns(this.layoutVertexArray, r, n, -1, 1), this.indexArray.emplaceBack(s, s + 1, s + 2), this.indexArray.emplaceBack(s, s + 3, s + 2), i.vertexLength += 4, i.primitiveLength += 2;\n        }\n\n        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, r, {}, n);\n      }\n\n    }\n\n    function Zs(t, e) {\n      for (let r = 0; r < t.length; r++) if (ea(e, t[r])) return !0;\n\n      for (let r = 0; r < e.length; r++) if (ea(t, e[r])) return !0;\n\n      return !!Ys(t, e);\n    }\n\n    function Gs(t, e, r) {\n      return !!ea(t, e) || !!Ws(e, t, r);\n    }\n\n    function Js(t, e) {\n      if (1 === t.length) return ta(e, t[0]);\n\n      for (let r = 0; r < e.length; r++) {\n        const n = e[r];\n\n        for (let e = 0; e < n.length; e++) if (ea(t, n[e])) return !0;\n      }\n\n      for (let r = 0; r < t.length; r++) if (ta(e, t[r])) return !0;\n\n      for (let r = 0; r < e.length; r++) if (Ys(t, e[r])) return !0;\n\n      return !1;\n    }\n\n    function Xs(t, e, r) {\n      if (t.length > 1) {\n        if (Ys(t, e)) return !0;\n\n        for (let n = 0; n < e.length; n++) if (Ws(e[n], t, r)) return !0;\n      }\n\n      for (let n = 0; n < t.length; n++) if (Ws(t[n], e, r)) return !0;\n\n      return !1;\n    }\n\n    function Ys(t, e) {\n      if (0 === t.length || 0 === e.length) return !1;\n\n      for (let r = 0; r < t.length - 1; r++) {\n        const n = t[r],\n              i = t[r + 1];\n\n        for (let t = 0; t < e.length - 1; t++) if (Hs(n, i, e[t], e[t + 1])) return !0;\n      }\n\n      return !1;\n    }\n\n    function Hs(t, e, r, n) {\n      return y(t, r, n) !== y(e, r, n) && y(t, e, r) !== y(t, e, n);\n    }\n\n    function Ws(t, e, r) {\n      const n = r * r;\n      if (1 === e.length) return t.distSqr(e[0]) < n;\n\n      for (let r = 1; r < e.length; r++) if (Qs(t, e[r - 1], e[r]) < n) return !0;\n\n      return !1;\n    }\n\n    function Qs(t, e, r) {\n      const n = e.distSqr(r);\n      if (0 === n) return t.distSqr(e);\n      const i = ((t.x - e.x) * (r.x - e.x) + (t.y - e.y) * (r.y - e.y)) / n;\n      return t.distSqr(i < 0 ? e : i > 1 ? r : r.sub(e)._mult(i)._add(e));\n    }\n\n    function ta(t, e) {\n      let r,\n          n,\n          i,\n          s = !1;\n\n      for (let a = 0; a < t.length; a++) {\n        r = t[a];\n\n        for (let t = 0, a = r.length - 1; t < r.length; a = t++) n = r[t], i = r[a], n.y > e.y != i.y > e.y && e.x < (i.x - n.x) * (e.y - n.y) / (i.y - n.y) + n.x && (s = !s);\n      }\n\n      return s;\n    }\n\n    function ea(t, e) {\n      let r = !1;\n\n      for (let n = 0, i = t.length - 1; n < t.length; i = n++) {\n        const s = t[n],\n              a = t[i];\n        s.y > e.y != a.y > e.y && e.x < (a.x - s.x) * (e.y - s.y) / (a.y - s.y) + s.x && (r = !r);\n      }\n\n      return r;\n    }\n\n    function ra(t, e, r) {\n      const n = r[0],\n            i = r[2];\n      if (t.x < n.x && e.x < n.x || t.x > i.x && e.x > i.x || t.y < n.y && e.y < n.y || t.y > i.y && e.y > i.y) return !1;\n      const s = y(t, e, r[0]);\n      return s !== y(t, e, r[1]) || s !== y(t, e, r[2]) || s !== y(t, e, r[3]);\n    }\n\n    function na(t, e, r) {\n      const n = e.paint.get(t).value;\n      return \"constant\" === n.kind ? n.value : r.programConfigurations.get(e.id).getMaxValue(t);\n    }\n\n    function ia(t) {\n      return Math.sqrt(t[0] * t[0] + t[1] * t[1]);\n    }\n\n    function sa(t, e, r, n, i) {\n      if (!e[0] && !e[1]) return t;\n\n      const s = S.convert(e)._mult(i);\n\n      \"viewport\" === r && s._rotate(-n);\n      const a = [];\n\n      for (let e = 0; e < t.length; e++) a.push(t[e].sub(s));\n\n      return a;\n    }\n\n    kn(\"CircleBucket\", Ks, {\n      omit: [\"layers\"]\n    });\n    const aa = new ci({\n      \"circle-sort-key\": new ai(nt.layout_circle[\"circle-sort-key\"])\n    });\n    var oa = {\n      paint: new ci({\n        \"circle-radius\": new ai(nt.paint_circle[\"circle-radius\"]),\n        \"circle-color\": new ai(nt.paint_circle[\"circle-color\"]),\n        \"circle-blur\": new ai(nt.paint_circle[\"circle-blur\"]),\n        \"circle-opacity\": new ai(nt.paint_circle[\"circle-opacity\"]),\n        \"circle-translate\": new si(nt.paint_circle[\"circle-translate\"]),\n        \"circle-translate-anchor\": new si(nt.paint_circle[\"circle-translate-anchor\"]),\n        \"circle-pitch-scale\": new si(nt.paint_circle[\"circle-pitch-scale\"]),\n        \"circle-pitch-alignment\": new si(nt.paint_circle[\"circle-pitch-alignment\"]),\n        \"circle-stroke-width\": new ai(nt.paint_circle[\"circle-stroke-width\"]),\n        \"circle-stroke-color\": new ai(nt.paint_circle[\"circle-stroke-color\"]),\n        \"circle-stroke-opacity\": new ai(nt.paint_circle[\"circle-stroke-opacity\"])\n      }),\n      layout: aa\n    },\n        la = \"undefined\" != typeof Float32Array ? Float32Array : Array;\n\n    function ua(t) {\n      return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;\n    }\n\n    function ca(t, e, r) {\n      var n = e[0],\n          i = e[1],\n          s = e[2],\n          a = e[3],\n          o = e[4],\n          l = e[5],\n          u = e[6],\n          c = e[7],\n          h = e[8],\n          p = e[9],\n          f = e[10],\n          d = e[11],\n          y = e[12],\n          m = e[13],\n          g = e[14],\n          x = e[15],\n          v = r[0],\n          b = r[1],\n          w = r[2],\n          _ = r[3];\n      return t[0] = v * n + b * o + w * h + _ * y, t[1] = v * i + b * l + w * p + _ * m, t[2] = v * s + b * u + w * f + _ * g, t[3] = v * a + b * c + w * d + _ * x, t[4] = (v = r[4]) * n + (b = r[5]) * o + (w = r[6]) * h + (_ = r[7]) * y, t[5] = v * i + b * l + w * p + _ * m, t[6] = v * s + b * u + w * f + _ * g, t[7] = v * a + b * c + w * d + _ * x, t[8] = (v = r[8]) * n + (b = r[9]) * o + (w = r[10]) * h + (_ = r[11]) * y, t[9] = v * i + b * l + w * p + _ * m, t[10] = v * s + b * u + w * f + _ * g, t[11] = v * a + b * c + w * d + _ * x, t[12] = (v = r[12]) * n + (b = r[13]) * o + (w = r[14]) * h + (_ = r[15]) * y, t[13] = v * i + b * l + w * p + _ * m, t[14] = v * s + b * u + w * f + _ * g, t[15] = v * a + b * c + w * d + _ * x, t;\n    }\n\n    Math.hypot || (Math.hypot = function () {\n      for (var t = 0, e = arguments.length; e--;) t += arguments[e] * arguments[e];\n\n      return Math.sqrt(t);\n    });\n    var ha = ca;\n\n    function pa() {\n      var t = new la(4);\n      return la != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 0), t;\n    }\n\n    function fa(t, e, r, n) {\n      var i = new la(4);\n      return i[0] = t, i[1] = e, i[2] = r, i[3] = n, i;\n    }\n\n    function da(t, e, r) {\n      var n = e[0],\n          i = e[1],\n          s = e[2],\n          a = e[3];\n      return t[0] = r[0] * n + r[4] * i + r[8] * s + r[12] * a, t[1] = r[1] * n + r[5] * i + r[9] * s + r[13] * a, t[2] = r[2] * n + r[6] * i + r[10] * s + r[14] * a, t[3] = r[3] * n + r[7] * i + r[11] * s + r[15] * a, t;\n    }\n\n    function ya(t, e) {\n      const r = da(pa(), fa(t.x, t.y, 0, 1), e);\n      return new S(r[0] / r[3], r[1] / r[3]);\n    }\n\n    pa();\n\n    class ma extends Ks {}\n\n    kn(\"HeatmapBucket\", ma, {\n      omit: [\"layers\"]\n    });\n    var ga = {\n      paint: new ci({\n        \"heatmap-radius\": new ai(nt.paint_heatmap[\"heatmap-radius\"]),\n        \"heatmap-weight\": new ai(nt.paint_heatmap[\"heatmap-weight\"]),\n        \"heatmap-intensity\": new si(nt.paint_heatmap[\"heatmap-intensity\"]),\n        \"heatmap-color\": new ui(nt.paint_heatmap[\"heatmap-color\"]),\n        \"heatmap-opacity\": new si(nt.paint_heatmap[\"heatmap-opacity\"])\n      })\n    };\n\n    function xa(t, _ref58, n, i) {\n      let {\n        width: e,\n        height: r\n      } = _ref58;\n\n      if (i) {\n        if (i instanceof Uint8ClampedArray) i = new Uint8Array(i.buffer);else if (i.length !== e * r * n) throw new RangeError(`mismatched image size. expected: ${i.length} but got: ${e * r * n}`);\n      } else i = new Uint8Array(e * r * n);\n\n      return t.width = e, t.height = r, t.data = i, t;\n    }\n\n    function va(t, _ref59, n) {\n      let {\n        width: e,\n        height: r\n      } = _ref59;\n      if (e === t.width && r === t.height) return;\n      const i = xa({}, {\n        width: e,\n        height: r\n      }, n);\n      ba(t, i, {\n        x: 0,\n        y: 0\n      }, {\n        x: 0,\n        y: 0\n      }, {\n        width: Math.min(t.width, e),\n        height: Math.min(t.height, r)\n      }, n), t.width = e, t.height = r, t.data = i.data;\n    }\n\n    function ba(t, e, r, n, i, s) {\n      if (0 === i.width || 0 === i.height) return e;\n      if (i.width > t.width || i.height > t.height || r.x > t.width - i.width || r.y > t.height - i.height) throw new RangeError(\"out of range source coordinates for image copy\");\n      if (i.width > e.width || i.height > e.height || n.x > e.width - i.width || n.y > e.height - i.height) throw new RangeError(\"out of range destination coordinates for image copy\");\n      const a = t.data,\n            o = e.data;\n\n      for (let l = 0; l < i.height; l++) {\n        const u = ((r.y + l) * t.width + r.x) * s,\n              c = ((n.y + l) * e.width + n.x) * s;\n\n        for (let t = 0; t < i.width * s; t++) o[c + t] = a[u + t];\n      }\n\n      return e;\n    }\n\n    class wa {\n      constructor(t, e) {\n        xa(this, t, 1, e);\n      }\n\n      resize(t) {\n        va(this, t, 1);\n      }\n\n      clone() {\n        return new wa({\n          width: this.width,\n          height: this.height\n        }, new Uint8Array(this.data));\n      }\n\n      static copy(t, e, r, n, i) {\n        ba(t, e, r, n, i, 1);\n      }\n\n    }\n\n    class _a {\n      constructor(t, e) {\n        xa(this, t, 4, e);\n      }\n\n      resize(t) {\n        va(this, t, 4);\n      }\n\n      replace(t, e) {\n        e ? this.data.set(t) : this.data = t instanceof Uint8ClampedArray ? new Uint8Array(t.buffer) : t;\n      }\n\n      clone() {\n        return new _a({\n          width: this.width,\n          height: this.height\n        }, new Uint8Array(this.data));\n      }\n\n      static copy(t, e, r, n, i) {\n        ba(t, e, r, n, i, 4);\n      }\n\n    }\n\n    function Aa(t) {\n      const e = {},\n            r = t.resolution || 256,\n            n = t.clips ? t.clips.length : 1,\n            i = t.image || new _a({\n        width: r,\n        height: n\n      }),\n            s = (r, n, s) => {\n        e[t.evaluationKey] = s;\n        const a = t.expression.evaluate(e);\n        i.data[r + n + 0] = Math.floor(255 * a.r / a.a), i.data[r + n + 1] = Math.floor(255 * a.g / a.a), i.data[r + n + 2] = Math.floor(255 * a.b / a.a), i.data[r + n + 3] = Math.floor(255 * a.a);\n      };\n\n      if (t.clips) for (let e = 0, i = 0; e < n; ++e, i += 4 * r) for (let n = 0, a = 0; n < r; n++, a += 4) {\n        const o = n / (r - 1),\n              {\n          start: l,\n          end: u\n        } = t.clips[e];\n        s(i, a, l * (1 - o) + u * o);\n      } else for (let t = 0, e = 0; t < r; t++, e += 4) s(0, e, t / (r - 1));\n      return i;\n    }\n\n    kn(\"AlphaImage\", wa), kn(\"RGBAImage\", _a);\n    var ka = {\n      paint: new ci({\n        \"hillshade-illumination-direction\": new si(nt.paint_hillshade[\"hillshade-illumination-direction\"]),\n        \"hillshade-illumination-anchor\": new si(nt.paint_hillshade[\"hillshade-illumination-anchor\"]),\n        \"hillshade-exaggeration\": new si(nt.paint_hillshade[\"hillshade-exaggeration\"]),\n        \"hillshade-shadow-color\": new si(nt.paint_hillshade[\"hillshade-shadow-color\"]),\n        \"hillshade-highlight-color\": new si(nt.paint_hillshade[\"hillshade-highlight-color\"]),\n        \"hillshade-accent-color\": new si(nt.paint_hillshade[\"hillshade-accent-color\"])\n      })\n    };\n    const Sa = mi([{\n      name: \"a_pos\",\n      components: 2,\n      type: \"Int16\"\n    }], 4),\n          {\n      members: za\n    } = Sa;\n    var Ia = {\n      exports: {}\n    };\n\n    function Ma(t, e, r) {\n      r = r || 2;\n      var n,\n          i,\n          s,\n          a,\n          o,\n          l,\n          u,\n          c = e && e.length,\n          h = c ? e[0] * r : t.length,\n          p = Ba(t, 0, h, r, !0),\n          f = [];\n      if (!p || p.next === p.prev) return f;\n\n      if (c && (p = function (t, e, r, n) {\n        var i,\n            s,\n            a,\n            o = [];\n\n        for (i = 0, s = e.length; i < s; i++) (a = Ba(t, e[i] * n, i < s - 1 ? e[i + 1] * n : t.length, n, !1)) === a.next && (a.steiner = !0), o.push(Ra(a));\n\n        for (o.sort(La), i = 0; i < o.length; i++) r = Ca(r = Da(o[i], r), r.next);\n\n        return r;\n      }(t, e, p, r)), t.length > 80 * r) {\n        n = s = t[0], i = a = t[1];\n\n        for (var d = r; d < h; d += r) (o = t[d]) < n && (n = o), (l = t[d + 1]) < i && (i = l), o > s && (s = o), l > a && (a = l);\n\n        u = 0 !== (u = Math.max(s - n, a - i)) ? 1 / u : 0;\n      }\n\n      return Pa(p, f, r, n, i, u), f;\n    }\n\n    function Ba(t, e, r, n, i) {\n      var s, a;\n      if (i === Qa(t, e, r, n) > 0) for (s = e; s < r; s += n) a = Ya(s, t[s], t[s + 1], a);else for (s = r - n; s >= e; s -= n) a = Ya(s, t[s], t[s + 1], a);\n      return a && Na(a, a.next) && (Ha(a), a = a.next), a;\n    }\n\n    function Ca(t, e) {\n      if (!t) return t;\n      e || (e = t);\n      var r,\n          n = t;\n\n      do {\n        if (r = !1, n.steiner || !Na(n, n.next) && 0 !== ja(n.prev, n, n.next)) n = n.next;else {\n          if (Ha(n), (n = e = n.prev) === n.next) break;\n          r = !0;\n        }\n      } while (r || n !== e);\n\n      return e;\n    }\n\n    function Pa(t, e, r, n, i, s, a) {\n      if (t) {\n        !a && s && function (t, e, r, n) {\n          var i = t;\n\n          do {\n            null === i.z && (i.z = Oa(i.x, i.y, e, r, n)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next;\n          } while (i !== t);\n\n          i.prevZ.nextZ = null, i.prevZ = null, function (t) {\n            var e,\n                r,\n                n,\n                i,\n                s,\n                a,\n                o,\n                l,\n                u = 1;\n\n            do {\n              for (r = t, t = null, s = null, a = 0; r;) {\n                for (a++, n = r, o = 0, e = 0; e < u && (o++, n = n.nextZ); e++);\n\n                for (l = u; o > 0 || l > 0 && n;) 0 !== o && (0 === l || !n || r.z <= n.z) ? (i = r, r = r.nextZ, o--) : (i = n, n = n.nextZ, l--), s ? s.nextZ = i : t = i, i.prevZ = s, s = i;\n\n                r = n;\n              }\n\n              s.nextZ = null, u *= 2;\n            } while (a > 1);\n          }(i);\n        }(t, n, i, s);\n\n        for (var o, l, u = t; t.prev !== t.next;) if (o = t.prev, l = t.next, s ? Ea(t, n, i, s) : Va(t)) e.push(o.i / r), e.push(t.i / r), e.push(l.i / r), Ha(t), t = l.next, u = l.next;else if ((t = l) === u) {\n          a ? 1 === a ? Pa(t = Fa(Ca(t), e, r), e, r, n, i, s, 2) : 2 === a && Ta(t, e, r, n, i, s) : Pa(Ca(t), e, r, n, i, s, 1);\n          break;\n        }\n      }\n    }\n\n    function Va(t) {\n      var e = t.prev,\n          r = t,\n          n = t.next;\n      if (ja(e, r, n) >= 0) return !1;\n\n      for (var i = t.next.next; i !== t.prev;) {\n        if (Ua(e.x, e.y, r.x, r.y, n.x, n.y, i.x, i.y) && ja(i.prev, i, i.next) >= 0) return !1;\n        i = i.next;\n      }\n\n      return !0;\n    }\n\n    function Ea(t, e, r, n) {\n      var i = t.prev,\n          s = t,\n          a = t.next;\n      if (ja(i, s, a) >= 0) return !1;\n\n      for (var o = i.x > s.x ? i.x > a.x ? i.x : a.x : s.x > a.x ? s.x : a.x, l = i.y > s.y ? i.y > a.y ? i.y : a.y : s.y > a.y ? s.y : a.y, u = Oa(i.x < s.x ? i.x < a.x ? i.x : a.x : s.x < a.x ? s.x : a.x, i.y < s.y ? i.y < a.y ? i.y : a.y : s.y < a.y ? s.y : a.y, e, r, n), c = Oa(o, l, e, r, n), h = t.prevZ, p = t.nextZ; h && h.z >= u && p && p.z <= c;) {\n        if (h !== t.prev && h !== t.next && Ua(i.x, i.y, s.x, s.y, a.x, a.y, h.x, h.y) && ja(h.prev, h, h.next) >= 0) return !1;\n        if (h = h.prevZ, p !== t.prev && p !== t.next && Ua(i.x, i.y, s.x, s.y, a.x, a.y, p.x, p.y) && ja(p.prev, p, p.next) >= 0) return !1;\n        p = p.nextZ;\n      }\n\n      for (; h && h.z >= u;) {\n        if (h !== t.prev && h !== t.next && Ua(i.x, i.y, s.x, s.y, a.x, a.y, h.x, h.y) && ja(h.prev, h, h.next) >= 0) return !1;\n        h = h.prevZ;\n      }\n\n      for (; p && p.z <= c;) {\n        if (p !== t.prev && p !== t.next && Ua(i.x, i.y, s.x, s.y, a.x, a.y, p.x, p.y) && ja(p.prev, p, p.next) >= 0) return !1;\n        p = p.nextZ;\n      }\n\n      return !0;\n    }\n\n    function Fa(t, e, r) {\n      var n = t;\n\n      do {\n        var i = n.prev,\n            s = n.next.next;\n        !Na(i, s) && Ka(i, n, n.next, s) && Ja(i, s) && Ja(s, i) && (e.push(i.i / r), e.push(n.i / r), e.push(s.i / r), Ha(n), Ha(n.next), n = t = s), n = n.next;\n      } while (n !== t);\n\n      return Ca(n);\n    }\n\n    function Ta(t, e, r, n, i, s) {\n      var a = t;\n\n      do {\n        for (var o = a.next.next; o !== a.prev;) {\n          if (a.i !== o.i && qa(a, o)) {\n            var l = Xa(a, o);\n            return a = Ca(a, a.next), l = Ca(l, l.next), Pa(a, e, r, n, i, s), void Pa(l, e, r, n, i, s);\n          }\n\n          o = o.next;\n        }\n\n        a = a.next;\n      } while (a !== t);\n    }\n\n    function La(t, e) {\n      return t.x - e.x;\n    }\n\n    function Da(t, e) {\n      var r = function (t, e) {\n        var r,\n            n = e,\n            i = t.x,\n            s = t.y,\n            a = -1 / 0;\n\n        do {\n          if (s <= n.y && s >= n.next.y && n.next.y !== n.y) {\n            var o = n.x + (s - n.y) * (n.next.x - n.x) / (n.next.y - n.y);\n\n            if (o <= i && o > a) {\n              if (a = o, o === i) {\n                if (s === n.y) return n;\n                if (s === n.next.y) return n.next;\n              }\n\n              r = n.x < n.next.x ? n : n.next;\n            }\n          }\n\n          n = n.next;\n        } while (n !== e);\n\n        if (!r) return null;\n        if (i === a) return r;\n        var l,\n            u = r,\n            c = r.x,\n            h = r.y,\n            p = 1 / 0;\n        n = r;\n\n        do {\n          i >= n.x && n.x >= c && i !== n.x && Ua(s < h ? i : a, s, c, h, s < h ? a : i, s, n.x, n.y) && (l = Math.abs(s - n.y) / (i - n.x), Ja(n, t) && (l < p || l === p && (n.x > r.x || n.x === r.x && $a(r, n))) && (r = n, p = l)), n = n.next;\n        } while (n !== u);\n\n        return r;\n      }(t, e);\n\n      if (!r) return e;\n      var n = Xa(r, t),\n          i = Ca(r, r.next);\n      return Ca(n, n.next), e === r ? i : e;\n    }\n\n    function $a(t, e) {\n      return ja(t.prev, t, e.prev) < 0 && ja(e.next, t, t.next) < 0;\n    }\n\n    function Oa(t, e, r, n, i) {\n      return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - r) * i) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - n) * i) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1;\n    }\n\n    function Ra(t) {\n      var e = t,\n          r = t;\n\n      do {\n        (e.x < r.x || e.x === r.x && e.y < r.y) && (r = e), e = e.next;\n      } while (e !== t);\n\n      return r;\n    }\n\n    function Ua(t, e, r, n, i, s, a, o) {\n      return (i - a) * (e - o) - (t - a) * (s - o) >= 0 && (t - a) * (n - o) - (r - a) * (e - o) >= 0 && (r - a) * (s - o) - (i - a) * (n - o) >= 0;\n    }\n\n    function qa(t, e) {\n      return t.next.i !== e.i && t.prev.i !== e.i && !function (t, e) {\n        var r = t;\n\n        do {\n          if (r.i !== t.i && r.next.i !== t.i && r.i !== e.i && r.next.i !== e.i && Ka(r, r.next, t, e)) return !0;\n          r = r.next;\n        } while (r !== t);\n\n        return !1;\n      }(t, e) && (Ja(t, e) && Ja(e, t) && function (t, e) {\n        var r = t,\n            n = !1,\n            i = (t.x + e.x) / 2,\n            s = (t.y + e.y) / 2;\n\n        do {\n          r.y > s != r.next.y > s && r.next.y !== r.y && i < (r.next.x - r.x) * (s - r.y) / (r.next.y - r.y) + r.x && (n = !n), r = r.next;\n        } while (r !== t);\n\n        return n;\n      }(t, e) && (ja(t.prev, t, e.prev) || ja(t, e.prev, e)) || Na(t, e) && ja(t.prev, t, t.next) > 0 && ja(e.prev, e, e.next) > 0);\n    }\n\n    function ja(t, e, r) {\n      return (e.y - t.y) * (r.x - e.x) - (e.x - t.x) * (r.y - e.y);\n    }\n\n    function Na(t, e) {\n      return t.x === e.x && t.y === e.y;\n    }\n\n    function Ka(t, e, r, n) {\n      var i = Ga(ja(t, e, r)),\n          s = Ga(ja(t, e, n)),\n          a = Ga(ja(r, n, t)),\n          o = Ga(ja(r, n, e));\n      return i !== s && a !== o || !(0 !== i || !Za(t, r, e)) || !(0 !== s || !Za(t, n, e)) || !(0 !== a || !Za(r, t, n)) || !(0 !== o || !Za(r, e, n));\n    }\n\n    function Za(t, e, r) {\n      return e.x <= Math.max(t.x, r.x) && e.x >= Math.min(t.x, r.x) && e.y <= Math.max(t.y, r.y) && e.y >= Math.min(t.y, r.y);\n    }\n\n    function Ga(t) {\n      return t > 0 ? 1 : t < 0 ? -1 : 0;\n    }\n\n    function Ja(t, e) {\n      return ja(t.prev, t, t.next) < 0 ? ja(t, e, t.next) >= 0 && ja(t, t.prev, e) >= 0 : ja(t, e, t.prev) < 0 || ja(t, t.next, e) < 0;\n    }\n\n    function Xa(t, e) {\n      var r = new Wa(t.i, t.x, t.y),\n          n = new Wa(e.i, e.x, e.y),\n          i = t.next,\n          s = e.prev;\n      return t.next = e, e.prev = t, r.next = i, i.prev = r, n.next = r, r.prev = n, s.next = n, n.prev = s, n;\n    }\n\n    function Ya(t, e, r, n) {\n      var i = new Wa(t, e, r);\n      return n ? (i.next = n.next, i.prev = n, n.next.prev = i, n.next = i) : (i.prev = i, i.next = i), i;\n    }\n\n    function Ha(t) {\n      t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ);\n    }\n\n    function Wa(t, e, r) {\n      this.i = t, this.x = e, this.y = r, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1;\n    }\n\n    function Qa(t, e, r, n) {\n      for (var i = 0, s = e, a = r - n; s < r; s += n) i += (t[a] - t[s]) * (t[s + 1] + t[a + 1]), a = s;\n\n      return i;\n    }\n\n    Ia.exports = Ma, Ia.exports.default = Ma, Ma.deviation = function (t, e, r, n) {\n      var i = e && e.length,\n          s = Math.abs(Qa(t, 0, i ? e[0] * r : t.length, r));\n      if (i) for (var a = 0, o = e.length; a < o; a++) s -= Math.abs(Qa(t, e[a] * r, a < o - 1 ? e[a + 1] * r : t.length, r));\n      var l = 0;\n\n      for (a = 0; a < n.length; a += 3) {\n        var u = n[a] * r,\n            c = n[a + 1] * r,\n            h = n[a + 2] * r;\n        l += Math.abs((t[u] - t[h]) * (t[c + 1] - t[u + 1]) - (t[u] - t[c]) * (t[h + 1] - t[u + 1]));\n      }\n\n      return 0 === s && 0 === l ? 0 : Math.abs((l - s) / s);\n    }, Ma.flatten = function (t) {\n      for (var e = t[0][0].length, r = {\n        vertices: [],\n        holes: [],\n        dimensions: e\n      }, n = 0, i = 0; i < t.length; i++) {\n        for (var s = 0; s < t[i].length; s++) for (var a = 0; a < e; a++) r.vertices.push(t[i][s][a]);\n\n        i > 0 && r.holes.push(n += t[i - 1].length);\n      }\n\n      return r;\n    };\n    var to = Ia.exports;\n\n    function eo(t, e, r, n, i) {\n      ro(t, e, r || 0, n || t.length - 1, i || io);\n    }\n\n    function ro(t, e, r, n, i) {\n      for (; n > r;) {\n        if (n - r > 600) {\n          var s = n - r + 1,\n              a = e - r + 1,\n              o = Math.log(s),\n              l = .5 * Math.exp(2 * o / 3),\n              u = .5 * Math.sqrt(o * l * (s - l) / s) * (a - s / 2 < 0 ? -1 : 1);\n          ro(t, e, Math.max(r, Math.floor(e - a * l / s + u)), Math.min(n, Math.floor(e + (s - a) * l / s + u)), i);\n        }\n\n        var c = t[e],\n            h = r,\n            p = n;\n\n        for (no(t, r, e), i(t[n], c) > 0 && no(t, r, n); h < p;) {\n          for (no(t, h, p), h++, p--; i(t[h], c) < 0;) h++;\n\n          for (; i(t[p], c) > 0;) p--;\n        }\n\n        0 === i(t[r], c) ? no(t, r, p) : no(t, ++p, n), p <= e && (r = p + 1), e <= p && (n = p - 1);\n      }\n    }\n\n    function no(t, e, r) {\n      var n = t[e];\n      t[e] = t[r], t[r] = n;\n    }\n\n    function io(t, e) {\n      return t < e ? -1 : t > e ? 1 : 0;\n    }\n\n    function so(t, e) {\n      const r = t.length;\n      if (r <= 1) return [t];\n      const n = [];\n      let i, s;\n\n      for (let e = 0; e < r; e++) {\n        const r = m(t[e]);\n        0 !== r && (t[e].area = Math.abs(r), void 0 === s && (s = r < 0), s === r < 0 ? (i && n.push(i), i = [t[e]]) : i.push(t[e]));\n      }\n\n      if (i && n.push(i), e > 1) for (let t = 0; t < n.length; t++) n[t].length <= e || (eo(n[t], e, 1, n[t].length - 1, ao), n[t] = n[t].slice(0, e));\n      return n;\n    }\n\n    function ao(t, e) {\n      return e.area - t.area;\n    }\n\n    function oo(t, e, r) {\n      const n = r.patternDependencies;\n      let i = !1;\n\n      for (const r of e) {\n        const e = r.paint.get(`${t}-pattern`);\n        e.isConstant() || (i = !0);\n        const s = e.constantOr(null);\n        s && (i = !0, n[s.to] = !0, n[s.from] = !0);\n      }\n\n      return i;\n    }\n\n    function lo(t, e, r, n, i) {\n      const s = i.patternDependencies;\n\n      for (const a of e) {\n        const e = a.paint.get(`${t}-pattern`).value;\n\n        if (\"constant\" !== e.kind) {\n          let t = e.evaluate({\n            zoom: n - 1\n          }, r, {}, i.availableImages),\n              o = e.evaluate({\n            zoom: n\n          }, r, {}, i.availableImages),\n              l = e.evaluate({\n            zoom: n + 1\n          }, r, {}, i.availableImages);\n          t = t && t.name ? t.name : t, o = o && o.name ? o.name : o, l = l && l.name ? l.name : l, s[t] = !0, s[o] = !0, s[l] = !0, r.patterns[a.id] = {\n            min: t,\n            mid: o,\n            max: l\n          };\n        }\n      }\n\n      return r;\n    }\n\n    class uo {\n      constructor(t) {\n        this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(t => t.id), this.index = t.index, this.hasPattern = !1, this.patternFeatures = [], this.layoutVertexArray = new Hi(), this.indexArray = new os(), this.indexArray2 = new ls(), this.programConfigurations = new Ls(t.layers, t.zoom), this.segments = new hs(), this.segments2 = new hs(), this.stateDependentLayerIds = this.layers.filter(t => t.isStateDependent()).map(t => t.id);\n      }\n\n      populate(t, e, r) {\n        this.hasPattern = oo(\"fill\", this.layers, e);\n        const n = this.layers[0].layout.get(\"fill-sort-key\"),\n              i = !n.isConstant(),\n              s = [];\n\n        for (const {\n          feature: a,\n          id: o,\n          index: l,\n          sourceLayerIndex: u\n        } of t) {\n          const t = this.layers[0]._featureFilter.needGeometry,\n                c = js(a, t);\n          if (!this.layers[0]._featureFilter.filter(new Yn(this.zoom), c, r)) continue;\n          const h = i ? n.evaluate(c, {}, r, e.availableImages) : void 0,\n                p = {\n            id: o,\n            properties: a.properties,\n            type: a.type,\n            sourceLayerIndex: u,\n            index: l,\n            geometry: t ? c.geometry : qs(a),\n            patterns: {},\n            sortKey: h\n          };\n          s.push(p);\n        }\n\n        i && s.sort((t, e) => t.sortKey - e.sortKey);\n\n        for (const n of s) {\n          const {\n            geometry: i,\n            index: s,\n            sourceLayerIndex: a\n          } = n;\n\n          if (this.hasPattern) {\n            const t = lo(\"fill\", this.layers, n, this.zoom, e);\n            this.patternFeatures.push(t);\n          } else this.addFeature(n, i, s, r, {});\n\n          e.featureIndex.insert(t[s].feature, i, s, a, this.index);\n        }\n      }\n\n      update(t, e, r) {\n        this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, e, this.stateDependentLayers, r);\n      }\n\n      addFeatures(t, e, r) {\n        for (const t of this.patternFeatures) this.addFeature(t, t.geometry, t.index, e, r);\n      }\n\n      isEmpty() {\n        return 0 === this.layoutVertexArray.length;\n      }\n\n      uploadPending() {\n        return !this.uploaded || this.programConfigurations.needsUpload;\n      }\n\n      upload(t) {\n        this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, za), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.indexBuffer2 = t.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t), this.uploaded = !0;\n      }\n\n      destroy() {\n        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());\n      }\n\n      addFeature(t, e, r, n, i) {\n        for (const t of so(e, 500)) {\n          let e = 0;\n\n          for (const r of t) e += r.length;\n\n          const r = this.segments.prepareSegment(e, this.layoutVertexArray, this.indexArray),\n                n = r.vertexLength,\n                i = [],\n                s = [];\n\n          for (const e of t) {\n            if (0 === e.length) continue;\n            e !== t[0] && s.push(i.length / 2);\n            const r = this.segments2.prepareSegment(e.length, this.layoutVertexArray, this.indexArray2),\n                  n = r.vertexLength;\n            this.layoutVertexArray.emplaceBack(e[0].x, e[0].y), this.indexArray2.emplaceBack(n + e.length - 1, n), i.push(e[0].x), i.push(e[0].y);\n\n            for (let t = 1; t < e.length; t++) this.layoutVertexArray.emplaceBack(e[t].x, e[t].y), this.indexArray2.emplaceBack(n + t - 1, n + t), i.push(e[t].x), i.push(e[t].y);\n\n            r.vertexLength += e.length, r.primitiveLength += e.length;\n          }\n\n          const a = to(i, s);\n\n          for (let t = 0; t < a.length; t += 3) this.indexArray.emplaceBack(n + a[t], n + a[t + 1], n + a[t + 2]);\n\n          r.vertexLength += e, r.primitiveLength += a.length / 3;\n        }\n\n        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, r, i, n);\n      }\n\n    }\n\n    kn(\"FillBucket\", uo, {\n      omit: [\"layers\", \"patternFeatures\"]\n    });\n    const co = new ci({\n      \"fill-sort-key\": new ai(nt.layout_fill[\"fill-sort-key\"])\n    });\n    var ho = {\n      paint: new ci({\n        \"fill-antialias\": new si(nt.paint_fill[\"fill-antialias\"]),\n        \"fill-opacity\": new ai(nt.paint_fill[\"fill-opacity\"]),\n        \"fill-color\": new ai(nt.paint_fill[\"fill-color\"]),\n        \"fill-outline-color\": new ai(nt.paint_fill[\"fill-outline-color\"]),\n        \"fill-translate\": new si(nt.paint_fill[\"fill-translate\"]),\n        \"fill-translate-anchor\": new si(nt.paint_fill[\"fill-translate-anchor\"]),\n        \"fill-pattern\": new oi(nt.paint_fill[\"fill-pattern\"])\n      }),\n      layout: co\n    };\n    const po = mi([{\n      name: \"a_pos\",\n      components: 2,\n      type: \"Int16\"\n    }, {\n      name: \"a_normal_ed\",\n      components: 4,\n      type: \"Int16\"\n    }], 4),\n          {\n      members: fo\n    } = po;\n    var yo = {},\n        mo = S,\n        go = xo;\n\n    function xo(t, e, r, n, i) {\n      this.properties = {}, this.extent = r, this.type = 0, this._pbf = t, this._geometry = -1, this._keys = n, this._values = i, t.readFields(vo, this, e);\n    }\n\n    function vo(t, e, r) {\n      1 == t ? e.id = r.readVarint() : 2 == t ? function (t, e) {\n        for (var r = t.readVarint() + t.pos; t.pos < r;) {\n          var n = e._keys[t.readVarint()],\n              i = e._values[t.readVarint()];\n\n          e.properties[n] = i;\n        }\n      }(r, e) : 3 == t ? e.type = r.readVarint() : 4 == t && (e._geometry = r.pos);\n    }\n\n    function bo(t) {\n      for (var e, r, n = 0, i = 0, s = t.length, a = s - 1; i < s; a = i++) n += ((r = t[a]).x - (e = t[i]).x) * (e.y + r.y);\n\n      return n;\n    }\n\n    xo.types = [\"Unknown\", \"Point\", \"LineString\", \"Polygon\"], xo.prototype.loadGeometry = function () {\n      var t = this._pbf;\n      t.pos = this._geometry;\n\n      for (var e, r = t.readVarint() + t.pos, n = 1, i = 0, s = 0, a = 0, o = []; t.pos < r;) {\n        if (i <= 0) {\n          var l = t.readVarint();\n          n = 7 & l, i = l >> 3;\n        }\n\n        if (i--, 1 === n || 2 === n) s += t.readSVarint(), a += t.readSVarint(), 1 === n && (e && o.push(e), e = []), e.push(new mo(s, a));else {\n          if (7 !== n) throw new Error(\"unknown command \" + n);\n          e && e.push(e[0].clone());\n        }\n      }\n\n      return e && o.push(e), o;\n    }, xo.prototype.bbox = function () {\n      var t = this._pbf;\n      t.pos = this._geometry;\n\n      for (var e = t.readVarint() + t.pos, r = 1, n = 0, i = 0, s = 0, a = 1 / 0, o = -1 / 0, l = 1 / 0, u = -1 / 0; t.pos < e;) {\n        if (n <= 0) {\n          var c = t.readVarint();\n          r = 7 & c, n = c >> 3;\n        }\n\n        if (n--, 1 === r || 2 === r) (i += t.readSVarint()) < a && (a = i), i > o && (o = i), (s += t.readSVarint()) < l && (l = s), s > u && (u = s);else if (7 !== r) throw new Error(\"unknown command \" + r);\n      }\n\n      return [a, l, o, u];\n    }, xo.prototype.toGeoJSON = function (t, e, r) {\n      var n,\n          i,\n          s = this.extent * Math.pow(2, r),\n          a = this.extent * t,\n          o = this.extent * e,\n          l = this.loadGeometry(),\n          u = xo.types[this.type];\n\n      function c(t) {\n        for (var e = 0; e < t.length; e++) {\n          var r = t[e];\n          t[e] = [360 * (r.x + a) / s - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (r.y + o) / s) * Math.PI / 180)) - 90];\n        }\n      }\n\n      switch (this.type) {\n        case 1:\n          var h = [];\n\n          for (n = 0; n < l.length; n++) h[n] = l[n][0];\n\n          c(l = h);\n          break;\n\n        case 2:\n          for (n = 0; n < l.length; n++) c(l[n]);\n\n          break;\n\n        case 3:\n          for (l = function (t) {\n            var e = t.length;\n            if (e <= 1) return [t];\n\n            for (var r, n, i = [], s = 0; s < e; s++) {\n              var a = bo(t[s]);\n              0 !== a && (void 0 === n && (n = a < 0), n === a < 0 ? (r && i.push(r), r = [t[s]]) : r.push(t[s]));\n            }\n\n            return r && i.push(r), i;\n          }(l), n = 0; n < l.length; n++) for (i = 0; i < l[n].length; i++) c(l[n][i]);\n\n      }\n\n      1 === l.length ? l = l[0] : u = \"Multi\" + u;\n      var p = {\n        type: \"Feature\",\n        geometry: {\n          type: u,\n          coordinates: l\n        },\n        properties: this.properties\n      };\n      return \"id\" in this && (p.id = this.id), p;\n    };\n    var wo = go,\n        _o = Ao;\n\n    function Ao(t, e) {\n      this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = t, this._keys = [], this._values = [], this._features = [], t.readFields(ko, this, e), this.length = this._features.length;\n    }\n\n    function ko(t, e, r) {\n      15 === t ? e.version = r.readVarint() : 1 === t ? e.name = r.readString() : 5 === t ? e.extent = r.readVarint() : 2 === t ? e._features.push(r.pos) : 3 === t ? e._keys.push(r.readString()) : 4 === t && e._values.push(function (t) {\n        for (var e = null, r = t.readVarint() + t.pos; t.pos < r;) {\n          var n = t.readVarint() >> 3;\n          e = 1 === n ? t.readString() : 2 === n ? t.readFloat() : 3 === n ? t.readDouble() : 4 === n ? t.readVarint64() : 5 === n ? t.readVarint() : 6 === n ? t.readSVarint() : 7 === n ? t.readBoolean() : null;\n        }\n\n        return e;\n      }(r));\n    }\n\n    Ao.prototype.feature = function (t) {\n      if (t < 0 || t >= this._features.length) throw new Error(\"feature index out of bounds\");\n      this._pbf.pos = this._features[t];\n\n      var e = this._pbf.readVarint() + this._pbf.pos;\n\n      return new wo(this._pbf, e, this.extent, this._keys, this._values);\n    };\n\n    var So = _o;\n\n    function zo(t, e, r) {\n      if (3 === t) {\n        var n = new So(r, r.readVarint() + r.pos);\n        n.length && (e[n.name] = n);\n      }\n    }\n\n    yo.VectorTile = function (t, e) {\n      this.layers = t.readFields(zo, {}, e);\n    }, yo.VectorTileFeature = go, yo.VectorTileLayer = _o;\n    const Io = yo.VectorTileFeature.types,\n          Mo = Math.pow(2, 13);\n\n    function Bo(t, e, r, n, i, s, a, o) {\n      t.emplaceBack(e, r, 2 * Math.floor(n * Mo) + a, i * Mo * 2, s * Mo * 2, Math.round(o));\n    }\n\n    class Co {\n      constructor(t) {\n        this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(t => t.id), this.index = t.index, this.hasPattern = !1, this.layoutVertexArray = new Wi(), this.indexArray = new os(), this.programConfigurations = new Ls(t.layers, t.zoom), this.segments = new hs(), this.stateDependentLayerIds = this.layers.filter(t => t.isStateDependent()).map(t => t.id);\n      }\n\n      populate(t, e, r) {\n        this.features = [], this.hasPattern = oo(\"fill-extrusion\", this.layers, e);\n\n        for (const {\n          feature: n,\n          id: i,\n          index: s,\n          sourceLayerIndex: a\n        } of t) {\n          const t = this.layers[0]._featureFilter.needGeometry,\n                o = js(n, t);\n          if (!this.layers[0]._featureFilter.filter(new Yn(this.zoom), o, r)) continue;\n          const l = {\n            id: i,\n            sourceLayerIndex: a,\n            index: s,\n            geometry: t ? o.geometry : qs(n),\n            properties: n.properties,\n            type: n.type,\n            patterns: {}\n          };\n          this.hasPattern ? this.features.push(lo(\"fill-extrusion\", this.layers, l, this.zoom, e)) : this.addFeature(l, l.geometry, s, r, {}), e.featureIndex.insert(n, l.geometry, s, a, this.index, !0);\n        }\n      }\n\n      addFeatures(t, e, r) {\n        for (const t of this.features) {\n          const {\n            geometry: n\n          } = t;\n          this.addFeature(t, n, t.index, e, r);\n        }\n      }\n\n      update(t, e, r) {\n        this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, e, this.stateDependentLayers, r);\n      }\n\n      isEmpty() {\n        return 0 === this.layoutVertexArray.length;\n      }\n\n      uploadPending() {\n        return !this.uploaded || this.programConfigurations.needsUpload;\n      }\n\n      upload(t) {\n        this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, fo), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0;\n      }\n\n      destroy() {\n        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());\n      }\n\n      addFeature(t, e, r, n, i) {\n        for (const r of so(e, 500)) {\n          let e = 0;\n\n          for (const t of r) e += t.length;\n\n          let n = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray);\n\n          for (const t of r) {\n            if (0 === t.length) continue;\n            if (Vo(t)) continue;\n            let e = 0;\n\n            for (let r = 0; r < t.length; r++) {\n              const i = t[r];\n\n              if (r >= 1) {\n                const s = t[r - 1];\n\n                if (!Po(i, s)) {\n                  n.vertexLength + 4 > hs.MAX_VERTEX_ARRAY_LENGTH && (n = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));\n\n                  const t = i.sub(s)._perp()._unit(),\n                        r = s.dist(i);\n\n                  e + r > 32768 && (e = 0), Bo(this.layoutVertexArray, i.x, i.y, t.x, t.y, 0, 0, e), Bo(this.layoutVertexArray, i.x, i.y, t.x, t.y, 0, 1, e), e += r, Bo(this.layoutVertexArray, s.x, s.y, t.x, t.y, 0, 0, e), Bo(this.layoutVertexArray, s.x, s.y, t.x, t.y, 0, 1, e);\n                  const a = n.vertexLength;\n                  this.indexArray.emplaceBack(a, a + 2, a + 1), this.indexArray.emplaceBack(a + 1, a + 2, a + 3), n.vertexLength += 4, n.primitiveLength += 2;\n                }\n              }\n            }\n          }\n\n          if (n.vertexLength + e > hs.MAX_VERTEX_ARRAY_LENGTH && (n = this.segments.prepareSegment(e, this.layoutVertexArray, this.indexArray)), \"Polygon\" !== Io[t.type]) continue;\n          const i = [],\n                s = [],\n                a = n.vertexLength;\n\n          for (const t of r) if (0 !== t.length) {\n            t !== r[0] && s.push(i.length / 2);\n\n            for (let e = 0; e < t.length; e++) {\n              const r = t[e];\n              Bo(this.layoutVertexArray, r.x, r.y, 0, 0, 1, 1, 0), i.push(r.x), i.push(r.y);\n            }\n          }\n\n          const o = to(i, s);\n\n          for (let t = 0; t < o.length; t += 3) this.indexArray.emplaceBack(a + o[t], a + o[t + 2], a + o[t + 1]);\n\n          n.primitiveLength += o.length / 3, n.vertexLength += e;\n        }\n\n        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, r, i, n);\n      }\n\n    }\n\n    function Po(t, e) {\n      return t.x === e.x && (t.x < 0 || t.x > Os) || t.y === e.y && (t.y < 0 || t.y > Os);\n    }\n\n    function Vo(t) {\n      return t.every(t => t.x < 0) || t.every(t => t.x > Os) || t.every(t => t.y < 0) || t.every(t => t.y > Os);\n    }\n\n    kn(\"FillExtrusionBucket\", Co, {\n      omit: [\"layers\", \"features\"]\n    });\n    var Eo = {\n      paint: new ci({\n        \"fill-extrusion-opacity\": new si(nt[\"paint_fill-extrusion\"][\"fill-extrusion-opacity\"]),\n        \"fill-extrusion-color\": new ai(nt[\"paint_fill-extrusion\"][\"fill-extrusion-color\"]),\n        \"fill-extrusion-translate\": new si(nt[\"paint_fill-extrusion\"][\"fill-extrusion-translate\"]),\n        \"fill-extrusion-translate-anchor\": new si(nt[\"paint_fill-extrusion\"][\"fill-extrusion-translate-anchor\"]),\n        \"fill-extrusion-pattern\": new oi(nt[\"paint_fill-extrusion\"][\"fill-extrusion-pattern\"]),\n        \"fill-extrusion-height\": new ai(nt[\"paint_fill-extrusion\"][\"fill-extrusion-height\"]),\n        \"fill-extrusion-base\": new ai(nt[\"paint_fill-extrusion\"][\"fill-extrusion-base\"]),\n        \"fill-extrusion-vertical-gradient\": new si(nt[\"paint_fill-extrusion\"][\"fill-extrusion-vertical-gradient\"])\n      })\n    };\n\n    function Fo(t, e) {\n      return t.x * e.x + t.y * e.y;\n    }\n\n    function To(t, e) {\n      if (1 === t.length) {\n        let r = 0;\n        const n = e[r++];\n        let i;\n\n        for (; !i || n.equals(i);) if (i = e[r++], !i) return 1 / 0;\n\n        for (; r < e.length; r++) {\n          const s = e[r],\n                a = t[0],\n                o = i.sub(n),\n                l = s.sub(n),\n                u = a.sub(n),\n                c = Fo(o, o),\n                h = Fo(o, l),\n                p = Fo(l, l),\n                f = Fo(u, o),\n                d = Fo(u, l),\n                y = c * p - h * h,\n                m = (p * f - h * d) / y,\n                g = (c * d - h * f) / y,\n                x = n.z * (1 - m - g) + i.z * m + s.z * g;\n          if (isFinite(x)) return x;\n        }\n\n        return 1 / 0;\n      }\n\n      {\n        let t = 1 / 0;\n\n        for (const r of e) t = Math.min(t, r.z);\n\n        return t;\n      }\n    }\n\n    const Lo = mi([{\n      name: \"a_pos_normal\",\n      components: 2,\n      type: \"Int16\"\n    }, {\n      name: \"a_data\",\n      components: 4,\n      type: \"Uint8\"\n    }], 4),\n          {\n      members: Do\n    } = Lo,\n          $o = mi([{\n      name: \"a_uv_x\",\n      components: 1,\n      type: \"Float32\"\n    }, {\n      name: \"a_split_index\",\n      components: 1,\n      type: \"Float32\"\n    }]),\n          {\n      members: Oo\n    } = $o,\n          Ro = yo.VectorTileFeature.types,\n          Uo = Math.cos(Math.PI / 180 * 37.5),\n          qo = Math.pow(2, 14) / .5;\n\n    class jo {\n      constructor(t) {\n        this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(t => t.id), this.index = t.index, this.hasPattern = !1, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach(t => {\n          this.gradients[t.id] = {};\n        }), this.layoutVertexArray = new Qi(), this.layoutVertexArray2 = new ts(), this.indexArray = new os(), this.programConfigurations = new Ls(t.layers, t.zoom), this.segments = new hs(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter(t => t.isStateDependent()).map(t => t.id);\n      }\n\n      populate(t, e, r) {\n        this.hasPattern = oo(\"line\", this.layers, e);\n        const n = this.layers[0].layout.get(\"line-sort-key\"),\n              i = !n.isConstant(),\n              s = [];\n\n        for (const {\n          feature: e,\n          id: a,\n          index: o,\n          sourceLayerIndex: l\n        } of t) {\n          const t = this.layers[0]._featureFilter.needGeometry,\n                u = js(e, t);\n          if (!this.layers[0]._featureFilter.filter(new Yn(this.zoom), u, r)) continue;\n          const c = i ? n.evaluate(u, {}, r) : void 0,\n                h = {\n            id: a,\n            properties: e.properties,\n            type: e.type,\n            sourceLayerIndex: l,\n            index: o,\n            geometry: t ? u.geometry : qs(e),\n            patterns: {},\n            sortKey: c\n          };\n          s.push(h);\n        }\n\n        i && s.sort((t, e) => t.sortKey - e.sortKey);\n\n        for (const n of s) {\n          const {\n            geometry: i,\n            index: s,\n            sourceLayerIndex: a\n          } = n;\n\n          if (this.hasPattern) {\n            const t = lo(\"line\", this.layers, n, this.zoom, e);\n            this.patternFeatures.push(t);\n          } else this.addFeature(n, i, s, r, {});\n\n          e.featureIndex.insert(t[s].feature, i, s, a, this.index);\n        }\n      }\n\n      update(t, e, r) {\n        this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, e, this.stateDependentLayers, r);\n      }\n\n      addFeatures(t, e, r) {\n        for (const t of this.patternFeatures) this.addFeature(t, t.geometry, t.index, e, r);\n      }\n\n      isEmpty() {\n        return 0 === this.layoutVertexArray.length;\n      }\n\n      uploadPending() {\n        return !this.uploaded || this.programConfigurations.needsUpload;\n      }\n\n      upload(t) {\n        this.uploaded || (0 !== this.layoutVertexArray2.length && (this.layoutVertexBuffer2 = t.createVertexBuffer(this.layoutVertexArray2, Oo)), this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Do), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0;\n      }\n\n      destroy() {\n        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());\n      }\n\n      lineFeatureClips(t) {\n        if (t.properties && Object.prototype.hasOwnProperty.call(t.properties, \"mapbox_clip_start\") && Object.prototype.hasOwnProperty.call(t.properties, \"mapbox_clip_end\")) return {\n          start: +t.properties.mapbox_clip_start,\n          end: +t.properties.mapbox_clip_end\n        };\n      }\n\n      addFeature(t, e, r, n, i) {\n        const s = this.layers[0].layout,\n              a = s.get(\"line-join\").evaluate(t, {}),\n              o = s.get(\"line-cap\"),\n              l = s.get(\"line-miter-limit\"),\n              u = s.get(\"line-round-limit\");\n        this.lineClips = this.lineFeatureClips(t);\n\n        for (const r of e) this.addLine(r, t, a, o, l, u);\n\n        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, r, i, n);\n      }\n\n      addLine(t, e, r, n, i, s) {\n        if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.lineClips) {\n          this.lineClipsArray.push(this.lineClips);\n\n          for (let e = 0; e < t.length - 1; e++) this.totalDistance += t[e].dist(t[e + 1]);\n\n          this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);\n        }\n\n        const a = \"Polygon\" === Ro[e.type];\n        let o = t.length;\n\n        for (; o >= 2 && t[o - 1].equals(t[o - 2]);) o--;\n\n        let l = 0;\n\n        for (; l < o - 1 && t[l].equals(t[l + 1]);) l++;\n\n        if (o < (a ? 3 : 2)) return;\n        \"bevel\" === r && (i = 1.05);\n        const u = this.overscaling <= 16 ? 122880 / (512 * this.overscaling) : 0,\n              c = this.segments.prepareSegment(10 * o, this.layoutVertexArray, this.indexArray);\n        let h, p, f, d, y;\n        this.e1 = this.e2 = -1, a && (h = t[o - 2], y = t[l].sub(h)._unit()._perp());\n\n        for (let e = l; e < o; e++) {\n          if (f = e === o - 1 ? a ? t[l + 1] : void 0 : t[e + 1], f && t[e].equals(f)) continue;\n          y && (d = y), h && (p = h), h = t[e], y = f ? f.sub(h)._unit()._perp() : d, d = d || y;\n          let m = d.add(y);\n          0 === m.x && 0 === m.y || m._unit();\n\n          const g = d.x * y.x + d.y * y.y,\n                x = m.x * y.x + m.y * y.y,\n                v = 0 !== x ? 1 / x : 1 / 0,\n                b = 2 * Math.sqrt(2 - 2 * x),\n                w = x < Uo && p && f,\n                _ = d.x * y.y - d.y * y.x > 0;\n\n          if (w && e > l) {\n            const t = h.dist(p);\n\n            if (t > 2 * u) {\n              const e = h.sub(h.sub(p)._mult(u / t)._round());\n              this.updateDistance(p, e), this.addCurrentVertex(e, d, 0, 0, c), p = e;\n            }\n          }\n\n          const A = p && f;\n          let k = A ? r : a ? \"butt\" : n;\n          if (A && \"round\" === k && (v < s ? k = \"miter\" : v <= 2 && (k = \"fakeround\")), \"miter\" === k && v > i && (k = \"bevel\"), \"bevel\" === k && (v > 2 && (k = \"flipbevel\"), v < i && (k = \"miter\")), p && this.updateDistance(p, h), \"miter\" === k) m._mult(v), this.addCurrentVertex(h, m, 0, 0, c);else if (\"flipbevel\" === k) {\n            if (v > 100) m = y.mult(-1);else {\n              const t = v * d.add(y).mag() / d.sub(y).mag();\n\n              m._perp()._mult(t * (_ ? -1 : 1));\n            }\n            this.addCurrentVertex(h, m, 0, 0, c), this.addCurrentVertex(h, m.mult(-1), 0, 0, c);\n          } else if (\"bevel\" === k || \"fakeround\" === k) {\n            const t = -Math.sqrt(v * v - 1),\n                  e = _ ? t : 0,\n                  r = _ ? 0 : t;\n\n            if (p && this.addCurrentVertex(h, d, e, r, c), \"fakeround\" === k) {\n              const t = Math.round(180 * b / Math.PI / 20);\n\n              for (let e = 1; e < t; e++) {\n                let r = e / t;\n\n                if (.5 !== r) {\n                  const t = r - .5;\n                  r += r * t * (r - 1) * ((1.0904 + g * (g * (3.55645 - 1.43519 * g) - 3.2452)) * t * t + (.848013 + g * (.215638 * g - 1.06021)));\n                }\n\n                const n = y.sub(d)._mult(r)._add(d)._unit()._mult(_ ? -1 : 1);\n\n                this.addHalfVertex(h, n.x, n.y, !1, _, 0, c);\n              }\n            }\n\n            f && this.addCurrentVertex(h, y, -e, -r, c);\n          } else if (\"butt\" === k) this.addCurrentVertex(h, m, 0, 0, c);else if (\"square\" === k) {\n            const t = p ? 1 : -1;\n            this.addCurrentVertex(h, m, t, t, c);\n          } else \"round\" === k && (p && (this.addCurrentVertex(h, d, 0, 0, c), this.addCurrentVertex(h, d, 1, 1, c, !0)), f && (this.addCurrentVertex(h, y, -1, -1, c, !0), this.addCurrentVertex(h, y, 0, 0, c)));\n\n          if (w && e < o - 1) {\n            const t = h.dist(f);\n\n            if (t > 2 * u) {\n              const e = h.add(f.sub(h)._mult(u / t)._round());\n              this.updateDistance(h, e), this.addCurrentVertex(e, y, 0, 0, c), h = e;\n            }\n          }\n        }\n      }\n\n      addCurrentVertex(t, e, r, n, i) {\n        let s = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : !1;\n        const a = e.y * n - e.x,\n              o = -e.y - e.x * n;\n        this.addHalfVertex(t, e.x + e.y * r, e.y - e.x * r, s, !1, r, i), this.addHalfVertex(t, a, o, s, !0, -n, i), this.distance > qo / 2 && 0 === this.totalDistance && (this.distance = 0, this.addCurrentVertex(t, e, r, n, i, s));\n      }\n\n      addHalfVertex(_ref60, r, n, i, s, a, o) {\n        let {\n          x: t,\n          y: e\n        } = _ref60;\n        const l = .5 * (this.lineClips ? this.scaledDistance * (qo - 1) : this.scaledDistance);\n        this.layoutVertexArray.emplaceBack((t << 1) + (i ? 1 : 0), (e << 1) + (s ? 1 : 0), Math.round(63 * r) + 128, Math.round(63 * n) + 128, 1 + (0 === a ? 0 : a < 0 ? -1 : 1) | (63 & l) << 2, l >> 6), this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length);\n        const u = o.vertexLength++;\n        this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, u), o.primitiveLength++), s ? this.e2 = u : this.e1 = u;\n      }\n\n      updateScaledDistance() {\n        this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance;\n      }\n\n      updateDistance(t, e) {\n        this.distance += t.dist(e), this.updateScaledDistance();\n      }\n\n    }\n\n    kn(\"LineBucket\", jo, {\n      omit: [\"layers\", \"patternFeatures\"]\n    });\n    const No = new ci({\n      \"line-cap\": new si(nt.layout_line[\"line-cap\"]),\n      \"line-join\": new ai(nt.layout_line[\"line-join\"]),\n      \"line-miter-limit\": new si(nt.layout_line[\"line-miter-limit\"]),\n      \"line-round-limit\": new si(nt.layout_line[\"line-round-limit\"]),\n      \"line-sort-key\": new ai(nt.layout_line[\"line-sort-key\"])\n    });\n    var Ko = {\n      paint: new ci({\n        \"line-opacity\": new ai(nt.paint_line[\"line-opacity\"]),\n        \"line-color\": new ai(nt.paint_line[\"line-color\"]),\n        \"line-translate\": new si(nt.paint_line[\"line-translate\"]),\n        \"line-translate-anchor\": new si(nt.paint_line[\"line-translate-anchor\"]),\n        \"line-width\": new ai(nt.paint_line[\"line-width\"]),\n        \"line-gap-width\": new ai(nt.paint_line[\"line-gap-width\"]),\n        \"line-offset\": new ai(nt.paint_line[\"line-offset\"]),\n        \"line-blur\": new ai(nt.paint_line[\"line-blur\"]),\n        \"line-dasharray\": new li(nt.paint_line[\"line-dasharray\"]),\n        \"line-pattern\": new oi(nt.paint_line[\"line-pattern\"]),\n        \"line-gradient\": new ui(nt.paint_line[\"line-gradient\"])\n      }),\n      layout: No\n    };\n    const Zo = new class extends ai {\n      possiblyEvaluate(t, e) {\n        return e = new Yn(Math.floor(e.zoom), {\n          now: e.now,\n          fadeDuration: e.fadeDuration,\n          zoomHistory: e.zoomHistory,\n          transition: e.transition\n        }), super.possiblyEvaluate(t, e);\n      }\n\n      evaluate(t, e, r, n) {\n        return e = o({}, e, {\n          zoom: Math.floor(e.zoom)\n        }), super.evaluate(t, e, r, n);\n      }\n\n    }(Ko.paint.properties[\"line-width\"].specification);\n\n    function Go(t, e) {\n      return e > 0 ? e + 2 * t : t;\n    }\n\n    Zo.useIntegerZoom = !0;\n    const Jo = mi([{\n      name: \"a_pos_offset\",\n      components: 4,\n      type: \"Int16\"\n    }, {\n      name: \"a_data\",\n      components: 4,\n      type: \"Uint16\"\n    }, {\n      name: \"a_pixeloffset\",\n      components: 4,\n      type: \"Int16\"\n    }], 4),\n          Xo = mi([{\n      name: \"a_projected_pos\",\n      components: 3,\n      type: \"Float32\"\n    }], 4);\n    mi([{\n      name: \"a_fade_opacity\",\n      components: 1,\n      type: \"Uint32\"\n    }], 4);\n    const Yo = mi([{\n      name: \"a_placed\",\n      components: 2,\n      type: \"Uint8\"\n    }, {\n      name: \"a_shift\",\n      components: 2,\n      type: \"Float32\"\n    }]);\n    mi([{\n      type: \"Int16\",\n      name: \"anchorPointX\"\n    }, {\n      type: \"Int16\",\n      name: \"anchorPointY\"\n    }, {\n      type: \"Int16\",\n      name: \"x1\"\n    }, {\n      type: \"Int16\",\n      name: \"y1\"\n    }, {\n      type: \"Int16\",\n      name: \"x2\"\n    }, {\n      type: \"Int16\",\n      name: \"y2\"\n    }, {\n      type: \"Uint32\",\n      name: \"featureIndex\"\n    }, {\n      type: \"Uint16\",\n      name: \"sourceLayerIndex\"\n    }, {\n      type: \"Uint16\",\n      name: \"bucketIndex\"\n    }]);\n    const Ho = mi([{\n      name: \"a_pos\",\n      components: 2,\n      type: \"Int16\"\n    }, {\n      name: \"a_anchor_pos\",\n      components: 2,\n      type: \"Int16\"\n    }, {\n      name: \"a_extrude\",\n      components: 2,\n      type: \"Int16\"\n    }], 4),\n          Wo = mi([{\n      name: \"a_pos\",\n      components: 2,\n      type: \"Float32\"\n    }, {\n      name: \"a_radius\",\n      components: 1,\n      type: \"Float32\"\n    }, {\n      name: \"a_flags\",\n      components: 2,\n      type: \"Int16\"\n    }], 4);\n\n    function Qo(t, e, r) {\n      return t.sections.forEach(t => {\n        t.text = function (t, e, r) {\n          const n = e.layout.get(\"text-transform\").evaluate(r, {});\n          return \"uppercase\" === n ? t = t.toLocaleUpperCase() : \"lowercase\" === n && (t = t.toLocaleLowerCase()), Xn.applyArabicShaping && (t = Xn.applyArabicShaping(t)), t;\n        }(t.text, e, r);\n      }), t;\n    }\n\n    mi([{\n      name: \"triangle\",\n      components: 3,\n      type: \"Uint16\"\n    }]), mi([{\n      type: \"Int16\",\n      name: \"anchorX\"\n    }, {\n      type: \"Int16\",\n      name: \"anchorY\"\n    }, {\n      type: \"Uint16\",\n      name: \"glyphStartIndex\"\n    }, {\n      type: \"Uint16\",\n      name: \"numGlyphs\"\n    }, {\n      type: \"Uint32\",\n      name: \"vertexStartIndex\"\n    }, {\n      type: \"Uint32\",\n      name: \"lineStartIndex\"\n    }, {\n      type: \"Uint32\",\n      name: \"lineLength\"\n    }, {\n      type: \"Uint16\",\n      name: \"segment\"\n    }, {\n      type: \"Uint16\",\n      name: \"lowerSize\"\n    }, {\n      type: \"Uint16\",\n      name: \"upperSize\"\n    }, {\n      type: \"Float32\",\n      name: \"lineOffsetX\"\n    }, {\n      type: \"Float32\",\n      name: \"lineOffsetY\"\n    }, {\n      type: \"Uint8\",\n      name: \"writingMode\"\n    }, {\n      type: \"Uint8\",\n      name: \"placedOrientation\"\n    }, {\n      type: \"Uint8\",\n      name: \"hidden\"\n    }, {\n      type: \"Uint32\",\n      name: \"crossTileID\"\n    }, {\n      type: \"Int16\",\n      name: \"associatedIconIndex\"\n    }]), mi([{\n      type: \"Int16\",\n      name: \"anchorX\"\n    }, {\n      type: \"Int16\",\n      name: \"anchorY\"\n    }, {\n      type: \"Int16\",\n      name: \"rightJustifiedTextSymbolIndex\"\n    }, {\n      type: \"Int16\",\n      name: \"centerJustifiedTextSymbolIndex\"\n    }, {\n      type: \"Int16\",\n      name: \"leftJustifiedTextSymbolIndex\"\n    }, {\n      type: \"Int16\",\n      name: \"verticalPlacedTextSymbolIndex\"\n    }, {\n      type: \"Int16\",\n      name: \"placedIconSymbolIndex\"\n    }, {\n      type: \"Int16\",\n      name: \"verticalPlacedIconSymbolIndex\"\n    }, {\n      type: \"Uint16\",\n      name: \"key\"\n    }, {\n      type: \"Uint16\",\n      name: \"textBoxStartIndex\"\n    }, {\n      type: \"Uint16\",\n      name: \"textBoxEndIndex\"\n    }, {\n      type: \"Uint16\",\n      name: \"verticalTextBoxStartIndex\"\n    }, {\n      type: \"Uint16\",\n      name: \"verticalTextBoxEndIndex\"\n    }, {\n      type: \"Uint16\",\n      name: \"iconBoxStartIndex\"\n    }, {\n      type: \"Uint16\",\n      name: \"iconBoxEndIndex\"\n    }, {\n      type: \"Uint16\",\n      name: \"verticalIconBoxStartIndex\"\n    }, {\n      type: \"Uint16\",\n      name: \"verticalIconBoxEndIndex\"\n    }, {\n      type: \"Uint16\",\n      name: \"featureIndex\"\n    }, {\n      type: \"Uint16\",\n      name: \"numHorizontalGlyphVertices\"\n    }, {\n      type: \"Uint16\",\n      name: \"numVerticalGlyphVertices\"\n    }, {\n      type: \"Uint16\",\n      name: \"numIconVertices\"\n    }, {\n      type: \"Uint16\",\n      name: \"numVerticalIconVertices\"\n    }, {\n      type: \"Uint16\",\n      name: \"useRuntimeCollisionCircles\"\n    }, {\n      type: \"Uint32\",\n      name: \"crossTileID\"\n    }, {\n      type: \"Float32\",\n      name: \"textBoxScale\"\n    }, {\n      type: \"Float32\",\n      components: 2,\n      name: \"textOffset\"\n    }, {\n      type: \"Float32\",\n      name: \"collisionCircleDiameter\"\n    }]), mi([{\n      type: \"Float32\",\n      name: \"offsetX\"\n    }]), mi([{\n      type: \"Int16\",\n      name: \"x\"\n    }, {\n      type: \"Int16\",\n      name: \"y\"\n    }, {\n      type: \"Int16\",\n      name: \"tileUnitDistanceFromAnchor\"\n    }]);\n    const tl = {\n      \"!\": \"︕\",\n      \"#\": \"＃\",\n      $: \"＄\",\n      \"%\": \"％\",\n      \"&\": \"＆\",\n      \"(\": \"︵\",\n      \")\": \"︶\",\n      \"*\": \"＊\",\n      \"+\": \"＋\",\n      \",\": \"︐\",\n      \"-\": \"︲\",\n      \".\": \"・\",\n      \"/\": \"／\",\n      \":\": \"︓\",\n      \";\": \"︔\",\n      \"<\": \"︿\",\n      \"=\": \"＝\",\n      \">\": \"﹀\",\n      \"?\": \"︖\",\n      \"@\": \"＠\",\n      \"[\": \"﹇\",\n      \"\\\\\": \"＼\",\n      \"]\": \"﹈\",\n      \"^\": \"＾\",\n      _: \"︳\",\n      \"`\": \"｀\",\n      \"{\": \"︷\",\n      \"|\": \"―\",\n      \"}\": \"︸\",\n      \"~\": \"～\",\n      \"¢\": \"￠\",\n      \"£\": \"￡\",\n      \"¥\": \"￥\",\n      \"¦\": \"￤\",\n      \"¬\": \"￢\",\n      \"¯\": \"￣\",\n      \"–\": \"︲\",\n      \"—\": \"︱\",\n      \"‘\": \"﹃\",\n      \"’\": \"﹄\",\n      \"“\": \"﹁\",\n      \"”\": \"﹂\",\n      \"…\": \"︙\",\n      \"‧\": \"・\",\n      \"₩\": \"￦\",\n      \"、\": \"︑\",\n      \"。\": \"︒\",\n      \"〈\": \"︿\",\n      \"〉\": \"﹀\",\n      \"《\": \"︽\",\n      \"》\": \"︾\",\n      \"「\": \"﹁\",\n      \"」\": \"﹂\",\n      \"『\": \"﹃\",\n      \"』\": \"﹄\",\n      \"【\": \"︻\",\n      \"】\": \"︼\",\n      \"〔\": \"︹\",\n      \"〕\": \"︺\",\n      \"〖\": \"︗\",\n      \"〗\": \"︘\",\n      \"！\": \"︕\",\n      \"（\": \"︵\",\n      \"）\": \"︶\",\n      \"，\": \"︐\",\n      \"－\": \"︲\",\n      \"．\": \"・\",\n      \"：\": \"︓\",\n      \"；\": \"︔\",\n      \"＜\": \"︿\",\n      \"＞\": \"﹀\",\n      \"？\": \"︖\",\n      \"［\": \"﹇\",\n      \"］\": \"﹈\",\n      \"＿\": \"︳\",\n      \"｛\": \"︷\",\n      \"｜\": \"―\",\n      \"｝\": \"︸\",\n      \"｟\": \"︵\",\n      \"｠\": \"︶\",\n      \"｡\": \"︒\",\n      \"｢\": \"﹁\",\n      \"｣\": \"﹂\"\n    };\n\n    var el = 24,\n        rl = sl,\n        nl = function (t, e, r, n, i) {\n      var s,\n          a,\n          o = 8 * i - n - 1,\n          l = (1 << o) - 1,\n          u = l >> 1,\n          c = -7,\n          h = r ? i - 1 : 0,\n          p = r ? -1 : 1,\n          f = t[e + h];\n\n      for (h += p, s = f & (1 << -c) - 1, f >>= -c, c += o; c > 0; s = 256 * s + t[e + h], h += p, c -= 8);\n\n      for (a = s & (1 << -c) - 1, s >>= -c, c += n; c > 0; a = 256 * a + t[e + h], h += p, c -= 8);\n\n      if (0 === s) s = 1 - u;else {\n        if (s === l) return a ? NaN : 1 / 0 * (f ? -1 : 1);\n        a += Math.pow(2, n), s -= u;\n      }\n      return (f ? -1 : 1) * a * Math.pow(2, s - n);\n    },\n        il = function (t, e, r, n, i, s) {\n      var a,\n          o,\n          l,\n          u = 8 * s - i - 1,\n          c = (1 << u) - 1,\n          h = c >> 1,\n          p = 23 === i ? Math.pow(2, -24) - Math.pow(2, -77) : 0,\n          f = n ? 0 : s - 1,\n          d = n ? 1 : -1,\n          y = e < 0 || 0 === e && 1 / e < 0 ? 1 : 0;\n\n      for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (o = isNaN(e) ? 1 : 0, a = c) : (a = Math.floor(Math.log(e) / Math.LN2), e * (l = Math.pow(2, -a)) < 1 && (a--, l *= 2), (e += a + h >= 1 ? p / l : p * Math.pow(2, 1 - h)) * l >= 2 && (a++, l /= 2), a + h >= c ? (o = 0, a = c) : a + h >= 1 ? (o = (e * l - 1) * Math.pow(2, i), a += h) : (o = e * Math.pow(2, h - 1) * Math.pow(2, i), a = 0)); i >= 8; t[r + f] = 255 & o, f += d, o /= 256, i -= 8);\n\n      for (a = a << i | o, u += i; u > 0; t[r + f] = 255 & a, f += d, a /= 256, u -= 8);\n\n      t[r + f - d] |= 128 * y;\n    };\n\n    function sl(t) {\n      this.buf = ArrayBuffer.isView && ArrayBuffer.isView(t) ? t : new Uint8Array(t || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;\n    }\n\n    sl.Varint = 0, sl.Fixed64 = 1, sl.Bytes = 2, sl.Fixed32 = 5;\n    var al,\n        ol = 4294967296,\n        ll = 1 / ol,\n        ul = \"undefined\" == typeof TextDecoder ? null : new TextDecoder(\"utf8\");\n\n    function cl(t) {\n      return t.type === sl.Bytes ? t.readVarint() + t.pos : t.pos + 1;\n    }\n\n    function hl(t, e, r) {\n      return r ? 4294967296 * e + (t >>> 0) : 4294967296 * (e >>> 0) + (t >>> 0);\n    }\n\n    function pl(t, e, r) {\n      var n = e <= 16383 ? 1 : e <= 2097151 ? 2 : e <= 268435455 ? 3 : Math.floor(Math.log(e) / (7 * Math.LN2));\n      r.realloc(n);\n\n      for (var i = r.pos - 1; i >= t; i--) r.buf[i + n] = r.buf[i];\n    }\n\n    function fl(t, e) {\n      for (var r = 0; r < t.length; r++) e.writeVarint(t[r]);\n    }\n\n    function dl(t, e) {\n      for (var r = 0; r < t.length; r++) e.writeSVarint(t[r]);\n    }\n\n    function yl(t, e) {\n      for (var r = 0; r < t.length; r++) e.writeFloat(t[r]);\n    }\n\n    function ml(t, e) {\n      for (var r = 0; r < t.length; r++) e.writeDouble(t[r]);\n    }\n\n    function gl(t, e) {\n      for (var r = 0; r < t.length; r++) e.writeBoolean(t[r]);\n    }\n\n    function xl(t, e) {\n      for (var r = 0; r < t.length; r++) e.writeFixed32(t[r]);\n    }\n\n    function vl(t, e) {\n      for (var r = 0; r < t.length; r++) e.writeSFixed32(t[r]);\n    }\n\n    function bl(t, e) {\n      for (var r = 0; r < t.length; r++) e.writeFixed64(t[r]);\n    }\n\n    function wl(t, e) {\n      for (var r = 0; r < t.length; r++) e.writeSFixed64(t[r]);\n    }\n\n    function _l(t, e) {\n      return (t[e] | t[e + 1] << 8 | t[e + 2] << 16) + 16777216 * t[e + 3];\n    }\n\n    function Al(t, e, r) {\n      t[r] = e, t[r + 1] = e >>> 8, t[r + 2] = e >>> 16, t[r + 3] = e >>> 24;\n    }\n\n    function kl(t, e) {\n      return (t[e] | t[e + 1] << 8 | t[e + 2] << 16) + (t[e + 3] << 24);\n    }\n\n    function Sl(t, e, r) {\n      1 === t && r.readMessage(zl, e);\n    }\n\n    function zl(t, e, r) {\n      if (3 === t) {\n        const {\n          id: t,\n          bitmap: n,\n          width: i,\n          height: s,\n          left: a,\n          top: o,\n          advance: l\n        } = r.readMessage(Il, {});\n        e.push({\n          id: t,\n          bitmap: new wa({\n            width: i + 6,\n            height: s + 6\n          }, n),\n          metrics: {\n            width: i,\n            height: s,\n            left: a,\n            top: o,\n            advance: l\n          }\n        });\n      }\n    }\n\n    function Il(t, e, r) {\n      1 === t ? e.id = r.readVarint() : 2 === t ? e.bitmap = r.readBytes() : 3 === t ? e.width = r.readVarint() : 4 === t ? e.height = r.readVarint() : 5 === t ? e.left = r.readSVarint() : 6 === t ? e.top = r.readSVarint() : 7 === t && (e.advance = r.readVarint());\n    }\n\n    function Ml(t) {\n      let e = 0,\n          r = 0;\n\n      for (const n of t) e += n.w * n.h, r = Math.max(r, n.w);\n\n      t.sort((t, e) => e.h - t.h);\n      const n = [{\n        x: 0,\n        y: 0,\n        w: Math.max(Math.ceil(Math.sqrt(e / .95)), r),\n        h: 1 / 0\n      }];\n      let i = 0,\n          s = 0;\n\n      for (const e of t) for (let t = n.length - 1; t >= 0; t--) {\n        const r = n[t];\n\n        if (!(e.w > r.w || e.h > r.h)) {\n          if (e.x = r.x, e.y = r.y, s = Math.max(s, e.y + e.h), i = Math.max(i, e.x + e.w), e.w === r.w && e.h === r.h) {\n            const e = n.pop();\n            t < n.length && (n[t] = e);\n          } else e.h === r.h ? (r.x += e.w, r.w -= e.w) : e.w === r.w ? (r.y += e.h, r.h -= e.h) : (n.push({\n            x: r.x + e.w,\n            y: r.y,\n            w: r.w - e.w,\n            h: e.h\n          }), r.y += e.h, r.h -= e.h);\n\n          break;\n        }\n      }\n\n      return {\n        w: i,\n        h: s,\n        fill: e / (i * s) || 0\n      };\n    }\n\n    sl.prototype = {\n      destroy: function () {\n        this.buf = null;\n      },\n      readFields: function (t, e, r) {\n        for (r = r || this.length; this.pos < r;) {\n          var n = this.readVarint(),\n              i = n >> 3,\n              s = this.pos;\n          this.type = 7 & n, t(i, e, this), this.pos === s && this.skip(n);\n        }\n\n        return e;\n      },\n      readMessage: function (t, e) {\n        return this.readFields(t, e, this.readVarint() + this.pos);\n      },\n      readFixed32: function () {\n        var t = _l(this.buf, this.pos);\n\n        return this.pos += 4, t;\n      },\n      readSFixed32: function () {\n        var t = kl(this.buf, this.pos);\n        return this.pos += 4, t;\n      },\n      readFixed64: function () {\n        var t = _l(this.buf, this.pos) + _l(this.buf, this.pos + 4) * ol;\n        return this.pos += 8, t;\n      },\n      readSFixed64: function () {\n        var t = _l(this.buf, this.pos) + kl(this.buf, this.pos + 4) * ol;\n        return this.pos += 8, t;\n      },\n      readFloat: function () {\n        var t = nl(this.buf, this.pos, !0, 23, 4);\n        return this.pos += 4, t;\n      },\n      readDouble: function () {\n        var t = nl(this.buf, this.pos, !0, 52, 8);\n        return this.pos += 8, t;\n      },\n      readVarint: function (t) {\n        var e,\n            r,\n            n = this.buf;\n        return e = 127 & (r = n[this.pos++]), r < 128 ? e : (e |= (127 & (r = n[this.pos++])) << 7, r < 128 ? e : (e |= (127 & (r = n[this.pos++])) << 14, r < 128 ? e : (e |= (127 & (r = n[this.pos++])) << 21, r < 128 ? e : function (t, e, r) {\n          var n,\n              i,\n              s = r.buf;\n          if (n = (112 & (i = s[r.pos++])) >> 4, i < 128) return hl(t, n, e);\n          if (n |= (127 & (i = s[r.pos++])) << 3, i < 128) return hl(t, n, e);\n          if (n |= (127 & (i = s[r.pos++])) << 10, i < 128) return hl(t, n, e);\n          if (n |= (127 & (i = s[r.pos++])) << 17, i < 128) return hl(t, n, e);\n          if (n |= (127 & (i = s[r.pos++])) << 24, i < 128) return hl(t, n, e);\n          if (n |= (1 & (i = s[r.pos++])) << 31, i < 128) return hl(t, n, e);\n          throw new Error(\"Expected varint not more than 10 bytes\");\n        }(e |= (15 & (r = n[this.pos])) << 28, t, this))));\n      },\n      readVarint64: function () {\n        return this.readVarint(!0);\n      },\n      readSVarint: function () {\n        var t = this.readVarint();\n        return t % 2 == 1 ? (t + 1) / -2 : t / 2;\n      },\n      readBoolean: function () {\n        return Boolean(this.readVarint());\n      },\n      readString: function () {\n        var t = this.readVarint() + this.pos,\n            e = this.pos;\n        return this.pos = t, t - e >= 12 && ul ? function (t, e, r) {\n          return ul.decode(t.subarray(e, r));\n        }(this.buf, e, t) : function (t, e, r) {\n          for (var n = \"\", i = e; i < r;) {\n            var s,\n                a,\n                o,\n                l = t[i],\n                u = null,\n                c = l > 239 ? 4 : l > 223 ? 3 : l > 191 ? 2 : 1;\n            if (i + c > r) break;\n            1 === c ? l < 128 && (u = l) : 2 === c ? 128 == (192 & (s = t[i + 1])) && (u = (31 & l) << 6 | 63 & s) <= 127 && (u = null) : 3 === c ? (a = t[i + 2], 128 == (192 & (s = t[i + 1])) && 128 == (192 & a) && ((u = (15 & l) << 12 | (63 & s) << 6 | 63 & a) <= 2047 || u >= 55296 && u <= 57343) && (u = null)) : 4 === c && (a = t[i + 2], o = t[i + 3], 128 == (192 & (s = t[i + 1])) && 128 == (192 & a) && 128 == (192 & o) && ((u = (15 & l) << 18 | (63 & s) << 12 | (63 & a) << 6 | 63 & o) <= 65535 || u >= 1114112) && (u = null)), null === u ? (u = 65533, c = 1) : u > 65535 && (u -= 65536, n += String.fromCharCode(u >>> 10 & 1023 | 55296), u = 56320 | 1023 & u), n += String.fromCharCode(u), i += c;\n          }\n\n          return n;\n        }(this.buf, e, t);\n      },\n      readBytes: function () {\n        var t = this.readVarint() + this.pos,\n            e = this.buf.subarray(this.pos, t);\n        return this.pos = t, e;\n      },\n      readPackedVarint: function (t, e) {\n        if (this.type !== sl.Bytes) return t.push(this.readVarint(e));\n        var r = cl(this);\n\n        for (t = t || []; this.pos < r;) t.push(this.readVarint(e));\n\n        return t;\n      },\n      readPackedSVarint: function (t) {\n        if (this.type !== sl.Bytes) return t.push(this.readSVarint());\n        var e = cl(this);\n\n        for (t = t || []; this.pos < e;) t.push(this.readSVarint());\n\n        return t;\n      },\n      readPackedBoolean: function (t) {\n        if (this.type !== sl.Bytes) return t.push(this.readBoolean());\n        var e = cl(this);\n\n        for (t = t || []; this.pos < e;) t.push(this.readBoolean());\n\n        return t;\n      },\n      readPackedFloat: function (t) {\n        if (this.type !== sl.Bytes) return t.push(this.readFloat());\n        var e = cl(this);\n\n        for (t = t || []; this.pos < e;) t.push(this.readFloat());\n\n        return t;\n      },\n      readPackedDouble: function (t) {\n        if (this.type !== sl.Bytes) return t.push(this.readDouble());\n        var e = cl(this);\n\n        for (t = t || []; this.pos < e;) t.push(this.readDouble());\n\n        return t;\n      },\n      readPackedFixed32: function (t) {\n        if (this.type !== sl.Bytes) return t.push(this.readFixed32());\n        var e = cl(this);\n\n        for (t = t || []; this.pos < e;) t.push(this.readFixed32());\n\n        return t;\n      },\n      readPackedSFixed32: function (t) {\n        if (this.type !== sl.Bytes) return t.push(this.readSFixed32());\n        var e = cl(this);\n\n        for (t = t || []; this.pos < e;) t.push(this.readSFixed32());\n\n        return t;\n      },\n      readPackedFixed64: function (t) {\n        if (this.type !== sl.Bytes) return t.push(this.readFixed64());\n        var e = cl(this);\n\n        for (t = t || []; this.pos < e;) t.push(this.readFixed64());\n\n        return t;\n      },\n      readPackedSFixed64: function (t) {\n        if (this.type !== sl.Bytes) return t.push(this.readSFixed64());\n        var e = cl(this);\n\n        for (t = t || []; this.pos < e;) t.push(this.readSFixed64());\n\n        return t;\n      },\n      skip: function (t) {\n        var e = 7 & t;\n        if (e === sl.Varint) for (; this.buf[this.pos++] > 127;);else if (e === sl.Bytes) this.pos = this.readVarint() + this.pos;else if (e === sl.Fixed32) this.pos += 4;else {\n          if (e !== sl.Fixed64) throw new Error(\"Unimplemented type: \" + e);\n          this.pos += 8;\n        }\n      },\n      writeTag: function (t, e) {\n        this.writeVarint(t << 3 | e);\n      },\n      realloc: function (t) {\n        for (var e = this.length || 16; e < this.pos + t;) e *= 2;\n\n        if (e !== this.length) {\n          var r = new Uint8Array(e);\n          r.set(this.buf), this.buf = r, this.length = e;\n        }\n      },\n      finish: function () {\n        return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);\n      },\n      writeFixed32: function (t) {\n        this.realloc(4), Al(this.buf, t, this.pos), this.pos += 4;\n      },\n      writeSFixed32: function (t) {\n        this.realloc(4), Al(this.buf, t, this.pos), this.pos += 4;\n      },\n      writeFixed64: function (t) {\n        this.realloc(8), Al(this.buf, -1 & t, this.pos), Al(this.buf, Math.floor(t * ll), this.pos + 4), this.pos += 8;\n      },\n      writeSFixed64: function (t) {\n        this.realloc(8), Al(this.buf, -1 & t, this.pos), Al(this.buf, Math.floor(t * ll), this.pos + 4), this.pos += 8;\n      },\n      writeVarint: function (t) {\n        (t = +t || 0) > 268435455 || t < 0 ? function (t, e) {\n          var r, n;\n          if (t >= 0 ? (r = t % 4294967296 | 0, n = t / 4294967296 | 0) : (n = ~(-t / 4294967296), 4294967295 ^ (r = ~(-t % 4294967296)) ? r = r + 1 | 0 : (r = 0, n = n + 1 | 0)), t >= 0x10000000000000000 || t < -0x10000000000000000) throw new Error(\"Given varint doesn't fit into 10 bytes\");\n          e.realloc(10), function (t, e, r) {\n            r.buf[r.pos++] = 127 & t | 128, t >>>= 7, r.buf[r.pos++] = 127 & t | 128, t >>>= 7, r.buf[r.pos++] = 127 & t | 128, t >>>= 7, r.buf[r.pos++] = 127 & t | 128, r.buf[r.pos] = 127 & (t >>>= 7);\n          }(r, 0, e), function (t, e) {\n            var r = (7 & t) << 4;\n            e.buf[e.pos++] |= r | ((t >>>= 3) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t)))));\n          }(n, e);\n        }(t, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = 127 & (t >>>= 7) | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = 127 & (t >>>= 7) | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = t >>> 7 & 127))));\n      },\n      writeSVarint: function (t) {\n        this.writeVarint(t < 0 ? 2 * -t - 1 : 2 * t);\n      },\n      writeBoolean: function (t) {\n        this.writeVarint(Boolean(t));\n      },\n      writeString: function (t) {\n        t = String(t), this.realloc(4 * t.length), this.pos++;\n        var e = this.pos;\n\n        this.pos = function (t, e, r) {\n          for (var n, i, s = 0; s < e.length; s++) {\n            if ((n = e.charCodeAt(s)) > 55295 && n < 57344) {\n              if (!i) {\n                n > 56319 || s + 1 === e.length ? (t[r++] = 239, t[r++] = 191, t[r++] = 189) : i = n;\n                continue;\n              }\n\n              if (n < 56320) {\n                t[r++] = 239, t[r++] = 191, t[r++] = 189, i = n;\n                continue;\n              }\n\n              n = i - 55296 << 10 | n - 56320 | 65536, i = null;\n            } else i && (t[r++] = 239, t[r++] = 191, t[r++] = 189, i = null);\n\n            n < 128 ? t[r++] = n : (n < 2048 ? t[r++] = n >> 6 | 192 : (n < 65536 ? t[r++] = n >> 12 | 224 : (t[r++] = n >> 18 | 240, t[r++] = n >> 12 & 63 | 128), t[r++] = n >> 6 & 63 | 128), t[r++] = 63 & n | 128);\n          }\n\n          return r;\n        }(this.buf, t, this.pos);\n\n        var r = this.pos - e;\n        r >= 128 && pl(e, r, this), this.pos = e - 1, this.writeVarint(r), this.pos += r;\n      },\n      writeFloat: function (t) {\n        this.realloc(4), il(this.buf, t, this.pos, !0, 23, 4), this.pos += 4;\n      },\n      writeDouble: function (t) {\n        this.realloc(8), il(this.buf, t, this.pos, !0, 52, 8), this.pos += 8;\n      },\n      writeBytes: function (t) {\n        var e = t.length;\n        this.writeVarint(e), this.realloc(e);\n\n        for (var r = 0; r < e; r++) this.buf[this.pos++] = t[r];\n      },\n      writeRawMessage: function (t, e) {\n        this.pos++;\n        var r = this.pos;\n        t(e, this);\n        var n = this.pos - r;\n        n >= 128 && pl(r, n, this), this.pos = r - 1, this.writeVarint(n), this.pos += n;\n      },\n      writeMessage: function (t, e, r) {\n        this.writeTag(t, sl.Bytes), this.writeRawMessage(e, r);\n      },\n      writePackedVarint: function (t, e) {\n        e.length && this.writeMessage(t, fl, e);\n      },\n      writePackedSVarint: function (t, e) {\n        e.length && this.writeMessage(t, dl, e);\n      },\n      writePackedBoolean: function (t, e) {\n        e.length && this.writeMessage(t, gl, e);\n      },\n      writePackedFloat: function (t, e) {\n        e.length && this.writeMessage(t, yl, e);\n      },\n      writePackedDouble: function (t, e) {\n        e.length && this.writeMessage(t, ml, e);\n      },\n      writePackedFixed32: function (t, e) {\n        e.length && this.writeMessage(t, xl, e);\n      },\n      writePackedSFixed32: function (t, e) {\n        e.length && this.writeMessage(t, vl, e);\n      },\n      writePackedFixed64: function (t, e) {\n        e.length && this.writeMessage(t, bl, e);\n      },\n      writePackedSFixed64: function (t, e) {\n        e.length && this.writeMessage(t, wl, e);\n      },\n      writeBytesField: function (t, e) {\n        this.writeTag(t, sl.Bytes), this.writeBytes(e);\n      },\n      writeFixed32Field: function (t, e) {\n        this.writeTag(t, sl.Fixed32), this.writeFixed32(e);\n      },\n      writeSFixed32Field: function (t, e) {\n        this.writeTag(t, sl.Fixed32), this.writeSFixed32(e);\n      },\n      writeFixed64Field: function (t, e) {\n        this.writeTag(t, sl.Fixed64), this.writeFixed64(e);\n      },\n      writeSFixed64Field: function (t, e) {\n        this.writeTag(t, sl.Fixed64), this.writeSFixed64(e);\n      },\n      writeVarintField: function (t, e) {\n        this.writeTag(t, sl.Varint), this.writeVarint(e);\n      },\n      writeSVarintField: function (t, e) {\n        this.writeTag(t, sl.Varint), this.writeSVarint(e);\n      },\n      writeStringField: function (t, e) {\n        this.writeTag(t, sl.Bytes), this.writeString(e);\n      },\n      writeFloatField: function (t, e) {\n        this.writeTag(t, sl.Fixed32), this.writeFloat(e);\n      },\n      writeDoubleField: function (t, e) {\n        this.writeTag(t, sl.Fixed64), this.writeDouble(e);\n      },\n      writeBooleanField: function (t, e) {\n        this.writeVarintField(t, Boolean(e));\n      }\n    };\n\n    class Bl {\n      constructor(t, _ref61) {\n        let {\n          pixelRatio: e,\n          version: r,\n          stretchX: n,\n          stretchY: i,\n          content: s\n        } = _ref61;\n        this.paddedRect = t, this.pixelRatio = e, this.stretchX = n, this.stretchY = i, this.content = s, this.version = r;\n      }\n\n      get tl() {\n        return [this.paddedRect.x + 1, this.paddedRect.y + 1];\n      }\n\n      get br() {\n        return [this.paddedRect.x + this.paddedRect.w - 1, this.paddedRect.y + this.paddedRect.h - 1];\n      }\n\n      get tlbr() {\n        return this.tl.concat(this.br);\n      }\n\n      get displaySize() {\n        return [(this.paddedRect.w - 2) / this.pixelRatio, (this.paddedRect.h - 2) / this.pixelRatio];\n      }\n\n    }\n\n    class Cl {\n      constructor(t, e) {\n        const r = {},\n              n = {};\n        this.haveRenderCallbacks = [];\n        const i = [];\n        this.addImages(t, r, i), this.addImages(e, n, i);\n        const {\n          w: s,\n          h: a\n        } = Ml(i),\n              o = new _a({\n          width: s || 1,\n          height: a || 1\n        });\n\n        for (const e in t) {\n          const n = t[e],\n                i = r[e].paddedRect;\n\n          _a.copy(n.data, o, {\n            x: 0,\n            y: 0\n          }, {\n            x: i.x + 1,\n            y: i.y + 1\n          }, n.data);\n        }\n\n        for (const t in e) {\n          const r = e[t],\n                i = n[t].paddedRect,\n                s = i.x + 1,\n                a = i.y + 1,\n                l = r.data.width,\n                u = r.data.height;\n          _a.copy(r.data, o, {\n            x: 0,\n            y: 0\n          }, {\n            x: s,\n            y: a\n          }, r.data), _a.copy(r.data, o, {\n            x: 0,\n            y: u - 1\n          }, {\n            x: s,\n            y: a - 1\n          }, {\n            width: l,\n            height: 1\n          }), _a.copy(r.data, o, {\n            x: 0,\n            y: 0\n          }, {\n            x: s,\n            y: a + u\n          }, {\n            width: l,\n            height: 1\n          }), _a.copy(r.data, o, {\n            x: l - 1,\n            y: 0\n          }, {\n            x: s - 1,\n            y: a\n          }, {\n            width: 1,\n            height: u\n          }), _a.copy(r.data, o, {\n            x: 0,\n            y: 0\n          }, {\n            x: s + l,\n            y: a\n          }, {\n            width: 1,\n            height: u\n          });\n        }\n\n        this.image = o, this.iconPositions = r, this.patternPositions = n;\n      }\n\n      addImages(t, e, r) {\n        for (const n in t) {\n          const i = t[n],\n                s = {\n            x: 0,\n            y: 0,\n            w: i.data.width + 2,\n            h: i.data.height + 2\n          };\n          r.push(s), e[n] = new Bl(s, i), i.hasRenderCallback && this.haveRenderCallbacks.push(n);\n        }\n      }\n\n      patchUpdatedImages(t, e) {\n        t.dispatchRenderCallbacks(this.haveRenderCallbacks);\n\n        for (const r in t.updatedImages) this.patchUpdatedImage(this.iconPositions[r], t.getImage(r), e), this.patchUpdatedImage(this.patternPositions[r], t.getImage(r), e);\n      }\n\n      patchUpdatedImage(t, e, r) {\n        if (!t || !e) return;\n        if (t.version === e.version) return;\n        t.version = e.version;\n        const [n, i] = t.tl;\n        r.update(e.data, void 0, {\n          x: n,\n          y: i\n        });\n      }\n\n    }\n\n    kn(\"ImagePosition\", Bl), kn(\"ImageAtlas\", Cl), t.WritingMode = void 0, (al = t.WritingMode || (t.WritingMode = {}))[al.none = 0] = \"none\", al[al.horizontal = 1] = \"horizontal\", al[al.vertical = 2] = \"vertical\", al[al.horizontalOnly = 3] = \"horizontalOnly\";\n    const Pl = -17;\n\n    class Vl {\n      constructor() {\n        this.scale = 1, this.fontStack = \"\", this.imageName = null;\n      }\n\n      static forText(t, e) {\n        const r = new Vl();\n        return r.scale = t || 1, r.fontStack = e, r;\n      }\n\n      static forImage(t) {\n        const e = new Vl();\n        return e.imageName = t, e;\n      }\n\n    }\n\n    class El {\n      constructor() {\n        this.text = \"\", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;\n      }\n\n      static fromFeature(t, e) {\n        const r = new El();\n\n        for (let n = 0; n < t.sections.length; n++) {\n          const i = t.sections[n];\n          i.image ? r.addImageSection(i) : r.addTextSection(i, e);\n        }\n\n        return r;\n      }\n\n      length() {\n        return this.text.length;\n      }\n\n      getSection(t) {\n        return this.sections[this.sectionIndex[t]];\n      }\n\n      getSectionIndex(t) {\n        return this.sectionIndex[t];\n      }\n\n      getCharCode(t) {\n        return this.text.charCodeAt(t);\n      }\n\n      verticalizePunctuation() {\n        this.text = function (t) {\n          let e = \"\";\n\n          for (let r = 0; r < t.length; r++) {\n            const n = t.charCodeAt(r + 1) || null,\n                  i = t.charCodeAt(r - 1) || null;\n            e += n && Fn(n) && !tl[t[r + 1]] || i && Fn(i) && !tl[t[r - 1]] || !tl[t[r]] ? t[r] : tl[t[r]];\n          }\n\n          return e;\n        }(this.text);\n      }\n\n      trim() {\n        let t = 0;\n\n        for (let e = 0; e < this.text.length && Tl[this.text.charCodeAt(e)]; e++) t++;\n\n        let e = this.text.length;\n\n        for (let r = this.text.length - 1; r >= 0 && r >= t && Tl[this.text.charCodeAt(r)]; r--) e--;\n\n        this.text = this.text.substring(t, e), this.sectionIndex = this.sectionIndex.slice(t, e);\n      }\n\n      substring(t, e) {\n        const r = new El();\n        return r.text = this.text.substring(t, e), r.sectionIndex = this.sectionIndex.slice(t, e), r.sections = this.sections, r;\n      }\n\n      toString() {\n        return this.text;\n      }\n\n      getMaxScale() {\n        return this.sectionIndex.reduce((t, e) => Math.max(t, this.sections[e].scale), 0);\n      }\n\n      addTextSection(t, e) {\n        this.text += t.text, this.sections.push(Vl.forText(t.scale, t.fontStack || e));\n        const r = this.sections.length - 1;\n\n        for (let e = 0; e < t.text.length; ++e) this.sectionIndex.push(r);\n      }\n\n      addImageSection(t) {\n        const e = t.image ? t.image.name : \"\";\n        if (0 === e.length) return void d(\"Can't add FormattedSection with an empty image.\");\n        const r = this.getNextImageSectionCharCode();\n        r ? (this.text += String.fromCharCode(r), this.sections.push(Vl.forImage(e)), this.sectionIndex.push(this.sections.length - 1)) : d(\"Reached maximum number of images 6401\");\n      }\n\n      getNextImageSectionCharCode() {\n        return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);\n      }\n\n    }\n\n    function Fl(e, r, n, i, s, a, o, l, u, c, h, p, f, d, y, m) {\n      const g = El.fromFeature(e, s);\n      let x;\n      p === t.WritingMode.vertical && g.verticalizePunctuation();\n      const {\n        processBidirectionalText: v,\n        processStyledBidirectionalText: b\n      } = Xn;\n\n      if (v && 1 === g.sections.length) {\n        x = [];\n        const t = v(g.toString(), ql(g, c, a, r, i, d, y));\n\n        for (const e of t) {\n          const t = new El();\n          t.text = e, t.sections = g.sections;\n\n          for (let r = 0; r < e.length; r++) t.sectionIndex.push(0);\n\n          x.push(t);\n        }\n      } else if (b) {\n        x = [];\n        const t = b(g.text, g.sectionIndex, ql(g, c, a, r, i, d, y));\n\n        for (const e of t) {\n          const t = new El();\n          t.text = e[0], t.sectionIndex = e[1], t.sections = g.sections, x.push(t);\n        }\n      } else x = function (t, e) {\n        const r = [],\n              n = t.text;\n        let i = 0;\n\n        for (const n of e) r.push(t.substring(i, n)), i = n;\n\n        return i < n.length && r.push(t.substring(i, n.length)), r;\n      }(g, ql(g, c, a, r, i, d, y));\n\n      const w = [],\n            _ = {\n        positionedLines: w,\n        text: g.toString(),\n        top: h[1],\n        bottom: h[1],\n        left: h[0],\n        right: h[0],\n        writingMode: p,\n        iconsInText: !1,\n        verticalizable: !1\n      };\n      return function (e, r, n, i, s, a, o, l, u, c, h, p) {\n        let f = 0,\n            d = Pl,\n            y = 0,\n            m = 0;\n        const g = \"right\" === l ? 1 : \"left\" === l ? 0 : .5;\n        let x = 0;\n\n        for (const o of s) {\n          o.trim();\n          const s = o.getMaxScale(),\n                l = (s - 1) * el,\n                b = {\n            positionedGlyphs: [],\n            lineOffset: 0\n          };\n          e.positionedLines[x] = b;\n          const w = b.positionedGlyphs;\n          let _ = 0;\n\n          if (!o.length()) {\n            d += a, ++x;\n            continue;\n          }\n\n          for (let a = 0; a < o.length(); a++) {\n            const y = o.getSection(a),\n                  m = o.getSectionIndex(a),\n                  g = o.getCharCode(a);\n            let x = 0,\n                b = null,\n                A = null,\n                k = null,\n                S = el;\n            const z = !(u === t.WritingMode.horizontal || !h && !En(g) || h && (Tl[g] || (v = g, Bn.Arabic(v) || Bn[\"Arabic Supplement\"](v) || Bn[\"Arabic Extended-A\"](v) || Bn[\"Arabic Presentation Forms-A\"](v) || Bn[\"Arabic Presentation Forms-B\"](v))));\n\n            if (y.imageName) {\n              const t = i[y.imageName];\n              if (!t) continue;\n              k = y.imageName, e.iconsInText = e.iconsInText || !0, A = t.paddedRect;\n              const r = t.displaySize;\n              y.scale = y.scale * el / p, b = {\n                width: r[0],\n                height: r[1],\n                left: 1,\n                top: -3,\n                advance: z ? r[1] : r[0]\n              }, x = l + (el - r[1] * y.scale), S = b.advance;\n              const n = z ? r[0] * y.scale - el * s : r[1] * y.scale - el * s;\n              n > 0 && n > _ && (_ = n);\n            } else {\n              const t = n[y.fontStack],\n                    e = t && t[g];\n              if (e && e.rect) A = e.rect, b = e.metrics;else {\n                const t = r[y.fontStack],\n                      e = t && t[g];\n                if (!e) continue;\n                b = e.metrics;\n              }\n              x = (s - y.scale) * el;\n            }\n\n            z ? (e.verticalizable = !0, w.push({\n              glyph: g,\n              imageName: k,\n              x: f,\n              y: d + x,\n              vertical: z,\n              scale: y.scale,\n              fontStack: y.fontStack,\n              sectionIndex: m,\n              metrics: b,\n              rect: A\n            }), f += S * y.scale + c) : (w.push({\n              glyph: g,\n              imageName: k,\n              x: f,\n              y: d + x,\n              vertical: z,\n              scale: y.scale,\n              fontStack: y.fontStack,\n              sectionIndex: m,\n              metrics: b,\n              rect: A\n            }), f += b.advance * y.scale + c);\n          }\n\n          0 !== w.length && (y = Math.max(f - c, y), Nl(w, 0, w.length - 1, g, _)), f = 0;\n          const A = a * s + _;\n          b.lineOffset = Math.max(_, l), d += A, m = Math.max(A, m), ++x;\n        }\n\n        var v;\n        const b = d - Pl,\n              {\n          horizontalAlign: w,\n          verticalAlign: _\n        } = jl(o);\n        (function (t, e, r, n, i, s, a, o, l) {\n          const u = (e - r) * i;\n          let c = 0;\n          c = s !== a ? -o * n - Pl : (-n * l + .5) * a;\n\n          for (const e of t) for (const t of e.positionedGlyphs) t.x += u, t.y += c;\n        })(e.positionedLines, g, w, _, y, m, a, b, s.length), e.top += -_ * b, e.bottom = e.top + b, e.left += -w * y, e.right = e.left + y;\n      }(_, r, n, i, x, o, l, u, p, c, f, m), !function (t) {\n        for (const e of t) if (0 !== e.positionedGlyphs.length) return !1;\n\n        return !0;\n      }(w) && _;\n    }\n\n    const Tl = {\n      9: !0,\n      10: !0,\n      11: !0,\n      12: !0,\n      13: !0,\n      32: !0\n    },\n          Ll = {\n      10: !0,\n      32: !0,\n      38: !0,\n      40: !0,\n      41: !0,\n      43: !0,\n      45: !0,\n      47: !0,\n      173: !0,\n      183: !0,\n      8203: !0,\n      8208: !0,\n      8211: !0,\n      8231: !0\n    };\n\n    function Dl(t, e, r, n, i, s) {\n      if (e.imageName) {\n        const t = n[e.imageName];\n        return t ? t.displaySize[0] * e.scale * el / s + i : 0;\n      }\n\n      {\n        const n = r[e.fontStack],\n              s = n && n[t];\n        return s ? s.metrics.advance * e.scale + i : 0;\n      }\n    }\n\n    function $l(t, e, r, n) {\n      const i = Math.pow(t - e, 2);\n      return n ? t < e ? i / 2 : 2 * i : i + Math.abs(r) * r;\n    }\n\n    function Ol(t, e, r) {\n      let n = 0;\n      return 10 === t && (n -= 1e4), r && (n += 150), 40 !== t && 65288 !== t || (n += 50), 41 !== e && 65289 !== e || (n += 50), n;\n    }\n\n    function Rl(t, e, r, n, i, s) {\n      let a = null,\n          o = $l(e, r, i, s);\n\n      for (const t of n) {\n        const n = $l(e - t.x, r, i, s) + t.badness;\n        n <= o && (a = t, o = n);\n      }\n\n      return {\n        index: t,\n        x: e,\n        priorBreak: a,\n        badness: o\n      };\n    }\n\n    function Ul(t) {\n      return t ? Ul(t.priorBreak).concat(t.index) : [];\n    }\n\n    function ql(t, e, r, n, i, s, a) {\n      if (\"point\" !== s) return [];\n      if (!t) return [];\n\n      const o = [],\n            l = function (t, e, r, n, i, s) {\n        let a = 0;\n\n        for (let r = 0; r < t.length(); r++) {\n          const o = t.getSection(r);\n          a += Dl(t.getCharCode(r), o, n, i, e, s);\n        }\n\n        return a / Math.max(1, Math.ceil(a / r));\n      }(t, e, r, n, i, a),\n            u = t.text.indexOf(\"​\") >= 0;\n\n      let c = 0;\n\n      for (let r = 0; r < t.length(); r++) {\n        const s = t.getSection(r),\n              p = t.getCharCode(r);\n\n        if (Tl[p] || (c += Dl(p, s, n, i, e, a)), r < t.length() - 1) {\n          const e = !((h = p) < 11904 || !(Bn[\"Bopomofo Extended\"](h) || Bn.Bopomofo(h) || Bn[\"CJK Compatibility Forms\"](h) || Bn[\"CJK Compatibility Ideographs\"](h) || Bn[\"CJK Compatibility\"](h) || Bn[\"CJK Radicals Supplement\"](h) || Bn[\"CJK Strokes\"](h) || Bn[\"CJK Symbols and Punctuation\"](h) || Bn[\"CJK Unified Ideographs Extension A\"](h) || Bn[\"CJK Unified Ideographs\"](h) || Bn[\"Enclosed CJK Letters and Months\"](h) || Bn[\"Halfwidth and Fullwidth Forms\"](h) || Bn.Hiragana(h) || Bn[\"Ideographic Description Characters\"](h) || Bn[\"Kangxi Radicals\"](h) || Bn[\"Katakana Phonetic Extensions\"](h) || Bn.Katakana(h) || Bn[\"Vertical Forms\"](h) || Bn[\"Yi Radicals\"](h) || Bn[\"Yi Syllables\"](h)));\n          (Ll[p] || e || s.imageName) && o.push(Rl(r + 1, c, l, o, Ol(p, t.getCharCode(r + 1), e && u), !1));\n        }\n      }\n\n      var h;\n      return Ul(Rl(t.length(), c, l, o, 0, !0));\n    }\n\n    function jl(t) {\n      let e = .5,\n          r = .5;\n\n      switch (t) {\n        case \"right\":\n        case \"top-right\":\n        case \"bottom-right\":\n          e = 1;\n          break;\n\n        case \"left\":\n        case \"top-left\":\n        case \"bottom-left\":\n          e = 0;\n      }\n\n      switch (t) {\n        case \"bottom\":\n        case \"bottom-right\":\n        case \"bottom-left\":\n          r = 1;\n          break;\n\n        case \"top\":\n        case \"top-right\":\n        case \"top-left\":\n          r = 0;\n      }\n\n      return {\n        horizontalAlign: e,\n        verticalAlign: r\n      };\n    }\n\n    function Nl(t, e, r, n, i) {\n      if (!n && !i) return;\n      const s = t[r],\n            a = (t[r].x + s.metrics.advance * s.scale) * n;\n\n      for (let n = e; n <= r; n++) t[n].x -= a, t[n].y += i;\n    }\n\n    function Kl(t, e, r) {\n      const {\n        horizontalAlign: n,\n        verticalAlign: i\n      } = jl(r),\n            s = e[0] - t.displaySize[0] * n,\n            a = e[1] - t.displaySize[1] * i;\n      return {\n        image: t,\n        top: a,\n        bottom: a + t.displaySize[1],\n        left: s,\n        right: s + t.displaySize[0]\n      };\n    }\n\n    function Zl(t, e, r, n, i, s) {\n      const a = t.image;\n      let o;\n\n      if (a.content) {\n        const t = a.content,\n              e = a.pixelRatio || 1;\n        o = [t[0] / e, t[1] / e, a.displaySize[0] - t[2] / e, a.displaySize[1] - t[3] / e];\n      }\n\n      const l = e.left * s,\n            u = e.right * s;\n      let c, h, p, f;\n      \"width\" === r || \"both\" === r ? (f = i[0] + l - n[3], h = i[0] + u + n[1]) : (f = i[0] + (l + u - a.displaySize[0]) / 2, h = f + a.displaySize[0]);\n      const d = e.top * s,\n            y = e.bottom * s;\n      return \"height\" === r || \"both\" === r ? (c = i[1] + d - n[0], p = i[1] + y + n[2]) : (c = i[1] + (d + y - a.displaySize[1]) / 2, p = c + a.displaySize[1]), {\n        image: a,\n        top: c,\n        right: h,\n        bottom: p,\n        left: f,\n        collisionPadding: o\n      };\n    }\n\n    const Gl = 128;\n\n    function Jl(t, e) {\n      const {\n        expression: r\n      } = e;\n      if (\"constant\" === r.kind) return {\n        kind: \"constant\",\n        layoutSize: r.evaluate(new Yn(t + 1))\n      };\n      if (\"source\" === r.kind) return {\n        kind: \"source\"\n      };\n      {\n        const {\n          zoomStops: e,\n          interpolationType: n\n        } = r;\n        let i = 0;\n\n        for (; i < e.length && e[i] <= t;) i++;\n\n        i = Math.max(0, i - 1);\n        let s = i;\n\n        for (; s < e.length && e[s] < t + 1;) s++;\n\n        s = Math.min(e.length - 1, s);\n        const a = e[i],\n              o = e[s];\n        return \"composite\" === r.kind ? {\n          kind: \"composite\",\n          minZoom: a,\n          maxZoom: o,\n          interpolationType: n\n        } : {\n          kind: \"camera\",\n          minZoom: a,\n          maxZoom: o,\n          minSize: r.evaluate(new Yn(a)),\n          maxSize: r.evaluate(new Yn(o)),\n          interpolationType: n\n        };\n      }\n    }\n\n    function Xl(t, _ref62, _ref63) {\n      let {\n        uSize: e,\n        uSizeT: r\n      } = _ref62;\n      let {\n        lowerSize: n,\n        upperSize: i\n      } = _ref63;\n      return \"source\" === t.kind ? n / Gl : \"composite\" === t.kind ? Se(n / Gl, i / Gl, r) : e;\n    }\n\n    function Yl(t, e) {\n      let r = 0,\n          n = 0;\n      if (\"constant\" === t.kind) n = t.layoutSize;else if (\"source\" !== t.kind) {\n        const {\n          interpolationType: i,\n          minZoom: a,\n          maxZoom: o\n        } = t,\n              l = i ? s(Ne.interpolationFactor(i, e, a, o), 0, 1) : 0;\n        \"camera\" === t.kind ? n = Se(t.minSize, t.maxSize, l) : r = l;\n      }\n      return {\n        uSizeT: r,\n        uSize: n\n      };\n    }\n\n    var Hl = Object.freeze({\n      __proto__: null,\n      getSizeData: Jl,\n      evaluateSizeForFeature: Xl,\n      evaluateSizeForZoom: Yl,\n      SIZE_PACK_FACTOR: Gl\n    });\n\n    class Wl extends S {\n      constructor(t, e, r, n) {\n        super(t, e), this.angle = r, void 0 !== n && (this.segment = n);\n      }\n\n      clone() {\n        return new Wl(this.x, this.y, this.angle, this.segment);\n      }\n\n    }\n\n    function Ql(t, e, r, n, i) {\n      if (void 0 === e.segment) return !0;\n      let s = e,\n          a = e.segment + 1,\n          o = 0;\n\n      for (; o > -r / 2;) {\n        if (a--, a < 0) return !1;\n        o -= t[a].dist(s), s = t[a];\n      }\n\n      o += t[a].dist(t[a + 1]), a++;\n      const l = [];\n      let u = 0;\n\n      for (; o < r / 2;) {\n        const e = t[a],\n              r = t[a + 1];\n        if (!r) return !1;\n        let s = t[a - 1].angleTo(e) - e.angleTo(r);\n\n        for (s = Math.abs((s + 3 * Math.PI) % (2 * Math.PI) - Math.PI), l.push({\n          distance: o,\n          angleDelta: s\n        }), u += s; o - l[0].distance > n;) u -= l.shift().angleDelta;\n\n        if (u > i) return !1;\n        a++, o += e.dist(r);\n      }\n\n      return !0;\n    }\n\n    function tu(t) {\n      let e = 0;\n\n      for (let r = 0; r < t.length - 1; r++) e += t[r].dist(t[r + 1]);\n\n      return e;\n    }\n\n    function eu(t, e, r) {\n      return t ? .6 * e * r : 0;\n    }\n\n    function ru(t, e) {\n      return Math.max(t ? t.right - t.left : 0, e ? e.right - e.left : 0);\n    }\n\n    function nu(t, e, r, n, i, s) {\n      const a = eu(r, i, s),\n            o = ru(r, n) * s;\n      let l = 0;\n      const u = tu(t) / 2;\n\n      for (let r = 0; r < t.length - 1; r++) {\n        const n = t[r],\n              i = t[r + 1],\n              s = n.dist(i);\n\n        if (l + s > u) {\n          const c = (u - l) / s,\n                h = Se(n.x, i.x, c),\n                p = Se(n.y, i.y, c),\n                f = new Wl(h, p, i.angleTo(n), r);\n          return f._round(), !a || Ql(t, f, o, a, e) ? f : void 0;\n        }\n\n        l += s;\n      }\n    }\n\n    function iu(t, e, r, n, i, s, a, o, l) {\n      const u = eu(n, s, a),\n            c = ru(n, i),\n            h = c * a,\n            p = 0 === t[0].x || t[0].x === l || 0 === t[0].y || t[0].y === l;\n      return e - h < e / 4 && (e = h + e / 4), su(t, p ? e / 2 * o % e : (c / 2 + 2 * s) * a * o % e, e, u, r, h, p, !1, l);\n    }\n\n    function su(t, e, r, n, i, s, a, o, l) {\n      const u = s / 2,\n            c = tu(t);\n      let h = 0,\n          p = e - r,\n          f = [];\n\n      for (let e = 0; e < t.length - 1; e++) {\n        const a = t[e],\n              o = t[e + 1],\n              d = a.dist(o),\n              y = o.angleTo(a);\n\n        for (; p + r < h + d;) {\n          p += r;\n          const m = (p - h) / d,\n                g = Se(a.x, o.x, m),\n                x = Se(a.y, o.y, m);\n\n          if (g >= 0 && g < l && x >= 0 && x < l && p - u >= 0 && p + u <= c) {\n            const r = new Wl(g, x, y, e);\n            r._round(), n && !Ql(t, r, s, n, i) || f.push(r);\n          }\n        }\n\n        h += d;\n      }\n\n      return o || f.length || a || (f = su(t, h / 2, r, n, i, s, a, !0, l)), f;\n    }\n\n    function au(t, e, r, n, i) {\n      const s = [];\n\n      for (let a = 0; a < t.length; a++) {\n        const o = t[a];\n        let l;\n\n        for (let t = 0; t < o.length - 1; t++) {\n          let a = o[t],\n              u = o[t + 1];\n          a.x < e && u.x < e || (a.x < e ? a = new S(e, a.y + (e - a.x) / (u.x - a.x) * (u.y - a.y))._round() : u.x < e && (u = new S(e, a.y + (e - a.x) / (u.x - a.x) * (u.y - a.y))._round()), a.y < r && u.y < r || (a.y < r ? a = new S(a.x + (r - a.y) / (u.y - a.y) * (u.x - a.x), r)._round() : u.y < r && (u = new S(a.x + (r - a.y) / (u.y - a.y) * (u.x - a.x), r)._round()), a.x >= n && u.x >= n || (a.x >= n ? a = new S(n, a.y + (n - a.x) / (u.x - a.x) * (u.y - a.y))._round() : u.x >= n && (u = new S(n, a.y + (n - a.x) / (u.x - a.x) * (u.y - a.y))._round()), a.y >= i && u.y >= i || (a.y >= i ? a = new S(a.x + (i - a.y) / (u.y - a.y) * (u.x - a.x), i)._round() : u.y >= i && (u = new S(a.x + (i - a.y) / (u.y - a.y) * (u.x - a.x), i)._round()), l && a.equals(l[l.length - 1]) || (l = [a], s.push(l)), l.push(u)))));\n        }\n      }\n\n      return s;\n    }\n\n    function ou(t, e, r, n) {\n      const i = [],\n            s = t.image,\n            a = s.pixelRatio,\n            o = s.paddedRect.w - 2,\n            l = s.paddedRect.h - 2,\n            u = t.right - t.left,\n            c = t.bottom - t.top,\n            h = s.stretchX || [[0, o]],\n            p = s.stretchY || [[0, l]],\n            f = (t, e) => t + e[1] - e[0],\n            d = h.reduce(f, 0),\n            y = p.reduce(f, 0),\n            m = o - d,\n            g = l - y;\n\n      let x = 0,\n          v = d,\n          b = 0,\n          w = y,\n          _ = 0,\n          A = m,\n          k = 0,\n          z = g;\n\n      if (s.content && n) {\n        const t = s.content;\n        x = lu(h, 0, t[0]), b = lu(p, 0, t[1]), v = lu(h, t[0], t[2]), w = lu(p, t[1], t[3]), _ = t[0] - x, k = t[1] - b, A = t[2] - t[0] - v, z = t[3] - t[1] - w;\n      }\n\n      const I = (n, i, o, l) => {\n        const h = cu(n.stretch - x, v, u, t.left),\n              p = hu(n.fixed - _, A, n.stretch, d),\n              f = cu(i.stretch - b, w, c, t.top),\n              m = hu(i.fixed - k, z, i.stretch, y),\n              g = cu(o.stretch - x, v, u, t.left),\n              I = hu(o.fixed - _, A, o.stretch, d),\n              M = cu(l.stretch - b, w, c, t.top),\n              B = hu(l.fixed - k, z, l.stretch, y),\n              C = new S(h, f),\n              P = new S(g, f),\n              V = new S(g, M),\n              E = new S(h, M),\n              F = new S(p / a, m / a),\n              T = new S(I / a, B / a),\n              L = e * Math.PI / 180;\n\n        if (L) {\n          const t = Math.sin(L),\n                e = Math.cos(L),\n                r = [e, -t, t, e];\n          C._matMult(r), P._matMult(r), E._matMult(r), V._matMult(r);\n        }\n\n        const D = n.stretch + n.fixed,\n              $ = i.stretch + i.fixed;\n        return {\n          tl: C,\n          tr: P,\n          bl: E,\n          br: V,\n          tex: {\n            x: s.paddedRect.x + 1 + D,\n            y: s.paddedRect.y + 1 + $,\n            w: o.stretch + o.fixed - D,\n            h: l.stretch + l.fixed - $\n          },\n          writingMode: void 0,\n          glyphOffset: [0, 0],\n          sectionIndex: 0,\n          pixelOffsetTL: F,\n          pixelOffsetBR: T,\n          minFontScaleX: A / a / u,\n          minFontScaleY: z / a / c,\n          isSDF: r\n        };\n      };\n\n      if (n && (s.stretchX || s.stretchY)) {\n        const t = uu(h, m, d),\n              e = uu(p, g, y);\n\n        for (let r = 0; r < t.length - 1; r++) {\n          const n = t[r],\n                s = t[r + 1];\n\n          for (let t = 0; t < e.length - 1; t++) i.push(I(n, e[t], s, e[t + 1]));\n        }\n      } else i.push(I({\n        fixed: 0,\n        stretch: -1\n      }, {\n        fixed: 0,\n        stretch: -1\n      }, {\n        fixed: 0,\n        stretch: o + 1\n      }, {\n        fixed: 0,\n        stretch: l + 1\n      }));\n\n      return i;\n    }\n\n    function lu(t, e, r) {\n      let n = 0;\n\n      for (const i of t) n += Math.max(e, Math.min(r, i[1])) - Math.max(e, Math.min(r, i[0]));\n\n      return n;\n    }\n\n    function uu(t, e, r) {\n      const n = [{\n        fixed: -1,\n        stretch: 0\n      }];\n\n      for (const [e, r] of t) {\n        const t = n[n.length - 1];\n        n.push({\n          fixed: e - t.stretch,\n          stretch: t.stretch\n        }), n.push({\n          fixed: e - t.stretch,\n          stretch: t.stretch + (r - e)\n        });\n      }\n\n      return n.push({\n        fixed: e + 1,\n        stretch: r\n      }), n;\n    }\n\n    function cu(t, e, r, n) {\n      return t / e * r + n;\n    }\n\n    function hu(t, e, r, n) {\n      return t - e * r / n;\n    }\n\n    kn(\"Anchor\", Wl);\n\n    class pu {\n      constructor(t, e, r, n, i, s, a, o, l, u) {\n        if (this.boxStartIndex = t.length, l) {\n          let t = s.top,\n              e = s.bottom;\n          const r = s.collisionPadding;\n          r && (t -= r[1], e += r[3]);\n          let n = e - t;\n          n > 0 && (n = Math.max(10, n), this.circleDiameter = n);\n        } else {\n          let l = s.top * a - o,\n              c = s.bottom * a + o,\n              h = s.left * a - o,\n              p = s.right * a + o;\n          const f = s.collisionPadding;\n\n          if (f && (h -= f[0] * a, l -= f[1] * a, p += f[2] * a, c += f[3] * a), u) {\n            const t = new S(h, l),\n                  e = new S(p, l),\n                  r = new S(h, c),\n                  n = new S(p, c),\n                  i = u * Math.PI / 180;\n            t._rotate(i), e._rotate(i), r._rotate(i), n._rotate(i), h = Math.min(t.x, e.x, r.x, n.x), p = Math.max(t.x, e.x, r.x, n.x), l = Math.min(t.y, e.y, r.y, n.y), c = Math.max(t.y, e.y, r.y, n.y);\n          }\n\n          t.emplaceBack(e.x, e.y, h, l, p, c, r, n, i);\n        }\n\n        this.boxEndIndex = t.length;\n      }\n\n    }\n\n    class fu {\n      constructor() {\n        let t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n        let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : du;\n        if (this.data = t, this.length = this.data.length, this.compare = e, this.length > 0) for (let t = (this.length >> 1) - 1; t >= 0; t--) this._down(t);\n      }\n\n      push(t) {\n        this.data.push(t), this.length++, this._up(this.length - 1);\n      }\n\n      pop() {\n        if (0 === this.length) return;\n        const t = this.data[0],\n              e = this.data.pop();\n        return this.length--, this.length > 0 && (this.data[0] = e, this._down(0)), t;\n      }\n\n      peek() {\n        return this.data[0];\n      }\n\n      _up(t) {\n        const {\n          data: e,\n          compare: r\n        } = this,\n              n = e[t];\n\n        for (; t > 0;) {\n          const i = t - 1 >> 1,\n                s = e[i];\n          if (r(n, s) >= 0) break;\n          e[t] = s, t = i;\n        }\n\n        e[t] = n;\n      }\n\n      _down(t) {\n        const {\n          data: e,\n          compare: r\n        } = this,\n              n = this.length >> 1,\n              i = e[t];\n\n        for (; t < n;) {\n          let n = 1 + (t << 1),\n              s = e[n];\n          const a = n + 1;\n          if (a < this.length && r(e[a], s) < 0 && (n = a, s = e[a]), r(s, i) >= 0) break;\n          e[t] = s, t = n;\n        }\n\n        e[t] = i;\n      }\n\n    }\n\n    function du(t, e) {\n      return t < e ? -1 : t > e ? 1 : 0;\n    }\n\n    function yu(t) {\n      let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;\n      let n = 1 / 0,\n          i = 1 / 0,\n          s = -1 / 0,\n          a = -1 / 0;\n      const o = t[0];\n\n      for (let t = 0; t < o.length; t++) {\n        const e = o[t];\n        (!t || e.x < n) && (n = e.x), (!t || e.y < i) && (i = e.y), (!t || e.x > s) && (s = e.x), (!t || e.y > a) && (a = e.y);\n      }\n\n      const l = Math.min(s - n, a - i);\n      let u = l / 2;\n      const c = new fu([], mu);\n      if (0 === l) return new S(n, i);\n\n      for (let e = n; e < s; e += l) for (let r = i; r < a; r += l) c.push(new gu(e + u, r + u, u, t));\n\n      let h = function (t) {\n        let e = 0,\n            r = 0,\n            n = 0;\n        const i = t[0];\n\n        for (let t = 0, s = i.length, a = s - 1; t < s; a = t++) {\n          const s = i[t],\n                o = i[a],\n                l = s.x * o.y - o.x * s.y;\n          r += (s.x + o.x) * l, n += (s.y + o.y) * l, e += 3 * l;\n        }\n\n        return new gu(r / e, n / e, 0, t);\n      }(t),\n          p = c.length;\n\n      for (; c.length;) {\n        const n = c.pop();\n        (n.d > h.d || !h.d) && (h = n, r && console.log(\"found best %d after %d probes\", Math.round(1e4 * n.d) / 1e4, p)), n.max - h.d <= e || (u = n.h / 2, c.push(new gu(n.p.x - u, n.p.y - u, u, t)), c.push(new gu(n.p.x + u, n.p.y - u, u, t)), c.push(new gu(n.p.x - u, n.p.y + u, u, t)), c.push(new gu(n.p.x + u, n.p.y + u, u, t)), p += 4);\n      }\n\n      return r && (console.log(`num probes: ${p}`), console.log(`best distance: ${h.d}`)), h.p;\n    }\n\n    function mu(t, e) {\n      return e.max - t.max;\n    }\n\n    function gu(t, e, r, n) {\n      this.p = new S(t, e), this.h = r, this.d = function (t, e) {\n        let r = !1,\n            n = 1 / 0;\n\n        for (let i = 0; i < e.length; i++) {\n          const s = e[i];\n\n          for (let e = 0, i = s.length, a = i - 1; e < i; a = e++) {\n            const i = s[e],\n                  o = s[a];\n            i.y > t.y != o.y > t.y && t.x < (o.x - i.x) * (t.y - i.y) / (o.y - i.y) + i.x && (r = !r), n = Math.min(n, Qs(t, i, o));\n          }\n        }\n\n        return (r ? 1 : -1) * Math.sqrt(n);\n      }(this.p, n), this.max = this.d + this.h * Math.SQRT2;\n    }\n\n    const xu = Number.POSITIVE_INFINITY;\n\n    function vu(t, e) {\n      return e[1] !== xu ? function (t, e, r) {\n        let n = 0,\n            i = 0;\n\n        switch (e = Math.abs(e), r = Math.abs(r), t) {\n          case \"top-right\":\n          case \"top-left\":\n          case \"top\":\n            i = r - 7;\n            break;\n\n          case \"bottom-right\":\n          case \"bottom-left\":\n          case \"bottom\":\n            i = 7 - r;\n        }\n\n        switch (t) {\n          case \"top-right\":\n          case \"bottom-right\":\n          case \"right\":\n            n = -e;\n            break;\n\n          case \"top-left\":\n          case \"bottom-left\":\n          case \"left\":\n            n = e;\n        }\n\n        return [n, i];\n      }(t, e[0], e[1]) : function (t, e) {\n        let r = 0,\n            n = 0;\n        e < 0 && (e = 0);\n        const i = e / Math.sqrt(2);\n\n        switch (t) {\n          case \"top-right\":\n          case \"top-left\":\n            n = i - 7;\n            break;\n\n          case \"bottom-right\":\n          case \"bottom-left\":\n            n = 7 - i;\n            break;\n\n          case \"bottom\":\n            n = 7 - e;\n            break;\n\n          case \"top\":\n            n = e - 7;\n        }\n\n        switch (t) {\n          case \"top-right\":\n          case \"bottom-right\":\n            r = -i;\n            break;\n\n          case \"top-left\":\n          case \"bottom-left\":\n            r = i;\n            break;\n\n          case \"left\":\n            r = e;\n            break;\n\n          case \"right\":\n            r = -e;\n        }\n\n        return [r, n];\n      }(t, e[0]);\n    }\n\n    function bu(t) {\n      switch (t) {\n        case \"right\":\n        case \"top-right\":\n        case \"bottom-right\":\n          return \"right\";\n\n        case \"left\":\n        case \"top-left\":\n        case \"bottom-left\":\n          return \"left\";\n      }\n\n      return \"center\";\n    }\n\n    function wu(e, r, n, i, s, a, o, l, u, c, h) {\n      let p = a.textMaxSize.evaluate(r, {});\n      void 0 === p && (p = o);\n\n      const f = e.layers[0].layout,\n            y = f.get(\"icon-offset\").evaluate(r, {}, h),\n            m = ku(n.horizontal),\n            g = o / 24,\n            x = e.tilePixelRatio * g,\n            v = e.tilePixelRatio * p / 24,\n            b = e.tilePixelRatio * l,\n            w = e.tilePixelRatio * f.get(\"symbol-spacing\"),\n            _ = f.get(\"text-padding\") * e.tilePixelRatio,\n            A = f.get(\"icon-padding\") * e.tilePixelRatio,\n            k = f.get(\"text-max-angle\") / 180 * Math.PI,\n            S = \"map\" === f.get(\"text-rotation-alignment\") && \"point\" !== f.get(\"symbol-placement\"),\n            z = \"map\" === f.get(\"icon-rotation-alignment\") && \"point\" !== f.get(\"symbol-placement\"),\n            I = f.get(\"symbol-placement\"),\n            M = w / 2,\n            B = f.get(\"icon-text-fit\");\n\n      let C;\n      i && \"none\" !== B && (e.allowVerticalPlacement && n.vertical && (C = Zl(i, n.vertical, B, f.get(\"icon-text-fit-padding\"), y, g)), m && (i = Zl(i, m, B, f.get(\"icon-text-fit-padding\"), y, g)));\n\n      const P = (l, p) => {\n        p.x < 0 || p.x >= Os || p.y < 0 || p.y >= Os || function (e, r, n, i, s, a, o, l, u, c, h, p, f, y, m, g, x, v, b, w, _, A, k, S, z) {\n          const I = e.addToLineVertexArray(r, n);\n          let M,\n              B,\n              C,\n              P,\n              V = 0,\n              E = 0,\n              F = 0,\n              T = 0,\n              L = -1,\n              D = -1;\n          const $ = {};\n          let O = vs(\"\"),\n              R = 0,\n              U = 0;\n\n          if (void 0 === l._unevaluatedLayout.getValue(\"text-radial-offset\") ? [R, U] = l.layout.get(\"text-offset\").evaluate(_, {}, S).map(t => t * el) : (R = l.layout.get(\"text-radial-offset\").evaluate(_, {}, S) * el, U = xu), e.allowVerticalPlacement && i.vertical) {\n            const t = l.layout.get(\"text-rotate\").evaluate(_, {}, S) + 90;\n            C = new pu(u, r, c, h, p, i.vertical, f, y, m, t), o && (P = new pu(u, r, c, h, p, o, x, v, m, t));\n          }\n\n          if (s) {\n            const n = l.layout.get(\"icon-rotate\").evaluate(_, {}),\n                  i = \"none\" !== l.layout.get(\"icon-text-fit\"),\n                  a = ou(s, n, k, i),\n                  f = o ? ou(o, n, k, i) : void 0;\n            B = new pu(u, r, c, h, p, s, x, v, !1, n), V = 4 * a.length;\n            const y = e.iconSizeData;\n            let m = null;\n            \"source\" === y.kind ? (m = [Gl * l.layout.get(\"icon-size\").evaluate(_, {})], m[0] > _u && d(`${e.layerIds[0]}: Value for \"icon-size\" is >= 255. Reduce your \"icon-size\".`)) : \"composite\" === y.kind && (m = [Gl * A.compositeIconSizes[0].evaluate(_, {}, S), Gl * A.compositeIconSizes[1].evaluate(_, {}, S)], (m[0] > _u || m[1] > _u) && d(`${e.layerIds[0]}: Value for \"icon-size\" is >= 255. Reduce your \"icon-size\".`)), e.addSymbols(e.icon, a, m, w, b, _, t.WritingMode.none, r, I.lineStartIndex, I.lineLength, -1, S), L = e.icon.placedSymbolArray.length - 1, f && (E = 4 * f.length, e.addSymbols(e.icon, f, m, w, b, _, t.WritingMode.vertical, r, I.lineStartIndex, I.lineLength, -1, S), D = e.icon.placedSymbolArray.length - 1);\n          }\n\n          const q = Object.keys(i.horizontal);\n\n          for (const n of q) {\n            const s = i.horizontal[n];\n\n            if (!M) {\n              O = vs(s.text);\n              const t = l.layout.get(\"text-rotate\").evaluate(_, {}, S);\n              M = new pu(u, r, c, h, p, s, f, y, m, t);\n            }\n\n            const o = 1 === s.positionedLines.length;\n            if (F += Au(e, r, s, a, l, m, _, g, I, i.vertical ? t.WritingMode.horizontal : t.WritingMode.horizontalOnly, o ? q : [n], $, L, A, S), o) break;\n          }\n\n          i.vertical && (T += Au(e, r, i.vertical, a, l, m, _, g, I, t.WritingMode.vertical, [\"vertical\"], $, D, A, S));\n          const j = M ? M.boxStartIndex : e.collisionBoxArray.length,\n                N = M ? M.boxEndIndex : e.collisionBoxArray.length,\n                K = C ? C.boxStartIndex : e.collisionBoxArray.length,\n                Z = C ? C.boxEndIndex : e.collisionBoxArray.length,\n                G = B ? B.boxStartIndex : e.collisionBoxArray.length,\n                J = B ? B.boxEndIndex : e.collisionBoxArray.length,\n                X = P ? P.boxStartIndex : e.collisionBoxArray.length,\n                Y = P ? P.boxEndIndex : e.collisionBoxArray.length;\n          let H = -1;\n\n          const W = (t, e) => t && t.circleDiameter ? Math.max(t.circleDiameter, e) : e;\n\n          H = W(M, H), H = W(C, H), H = W(B, H), H = W(P, H);\n          const Q = H > -1 ? 1 : 0;\n          Q && (H *= z / el), e.glyphOffsetArray.length >= Eu.MAX_GLYPHS && d(\"Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907\"), void 0 !== _.sortKey && e.addToSortKeyRanges(e.symbolInstances.length, _.sortKey), e.symbolInstances.emplaceBack(r.x, r.y, $.right >= 0 ? $.right : -1, $.center >= 0 ? $.center : -1, $.left >= 0 ? $.left : -1, $.vertical || -1, L, D, O, j, N, K, Z, G, J, X, Y, c, F, T, V, E, Q, 0, f, R, U, H);\n        }(e, p, l, n, i, s, C, e.layers[0], e.collisionBoxArray, r.index, r.sourceLayerIndex, e.index, x, _, S, u, b, A, z, y, r, a, c, h, o);\n      };\n\n      if (\"line\" === I) for (const t of au(r.geometry, 0, 0, Os, Os)) {\n        const r = iu(t, w, k, n.vertical || m, i, 24, v, e.overscaling, Os);\n\n        for (const n of r) {\n          const r = m;\n          r && Su(e, r.text, M, n) || P(t, n);\n        }\n      } else if (\"line-center\" === I) {\n        for (const t of r.geometry) if (t.length > 1) {\n          const e = nu(t, k, n.vertical || m, i, 24, v);\n          e && P(t, e);\n        }\n      } else if (\"Polygon\" === r.type) for (const t of so(r.geometry, 0)) {\n        const e = yu(t, 16);\n        P(t[0], new Wl(e.x, e.y, 0));\n      } else if (\"LineString\" === r.type) for (const t of r.geometry) P(t, new Wl(t[0].x, t[0].y, 0));else if (\"Point\" === r.type) for (const t of r.geometry) for (const e of t) P([e], new Wl(e.x, e.y, 0));\n    }\n\n    const _u = 32640;\n\n    function Au(t, e, r, n, i, s, a, o, l, u, c, h, p, f, y) {\n      const m = function (t, e, r, n, i, s, a, o) {\n        const l = n.layout.get(\"text-rotate\").evaluate(s, {}) * Math.PI / 180,\n              u = [];\n\n        for (const t of e.positionedLines) for (const n of t.positionedGlyphs) {\n          if (!n.rect) continue;\n          const s = n.rect || {};\n          let c = 4,\n              h = !0,\n              p = 1,\n              f = 0;\n          const d = (i || o) && n.vertical,\n                y = n.metrics.advance * n.scale / 2;\n\n          if (o && e.verticalizable) {\n            const e = (n.scale - 1) * el,\n                  r = (el - n.metrics.width * n.scale) / 2;\n            f = t.lineOffset / 2 - (n.imageName ? -r : e);\n          }\n\n          if (n.imageName) {\n            const t = a[n.imageName];\n            h = t.sdf, p = t.pixelRatio, c = 1 / p;\n          }\n\n          const m = i ? [n.x + y, n.y] : [0, 0];\n          let g = i ? [0, 0] : [n.x + y + r[0], n.y + r[1] - f],\n              x = [0, 0];\n          d && (x = g, g = [0, 0]);\n\n          const v = (n.metrics.left - c) * n.scale - y + g[0],\n                b = (-n.metrics.top - c) * n.scale + g[1],\n                w = v + s.w * n.scale / p,\n                _ = b + s.h * n.scale / p,\n                A = new S(v, b),\n                k = new S(w, b),\n                z = new S(v, _),\n                I = new S(w, _);\n\n          if (d) {\n            const t = new S(-y, y - Pl),\n                  e = -Math.PI / 2,\n                  r = 12 - y,\n                  i = new S(22 - r, -(n.imageName ? r : 0)),\n                  s = new S(...x);\n            A._rotateAround(e, t)._add(i)._add(s), k._rotateAround(e, t)._add(i)._add(s), z._rotateAround(e, t)._add(i)._add(s), I._rotateAround(e, t)._add(i)._add(s);\n          }\n\n          if (l) {\n            const t = Math.sin(l),\n                  e = Math.cos(l),\n                  r = [e, -t, t, e];\n            A._matMult(r), k._matMult(r), z._matMult(r), I._matMult(r);\n          }\n\n          const M = new S(0, 0),\n                B = new S(0, 0);\n          u.push({\n            tl: A,\n            tr: k,\n            bl: z,\n            br: I,\n            tex: s,\n            writingMode: e.writingMode,\n            glyphOffset: m,\n            sectionIndex: n.sectionIndex,\n            isSDF: h,\n            pixelOffsetTL: M,\n            pixelOffsetBR: B,\n            minFontScaleX: 0,\n            minFontScaleY: 0\n          });\n        }\n\n        return u;\n      }(0, r, o, i, s, a, n, t.allowVerticalPlacement),\n            g = t.textSizeData;\n\n      let x = null;\n      \"source\" === g.kind ? (x = [Gl * i.layout.get(\"text-size\").evaluate(a, {})], x[0] > _u && d(`${t.layerIds[0]}: Value for \"text-size\" is >= 255. Reduce your \"text-size\".`)) : \"composite\" === g.kind && (x = [Gl * f.compositeTextSizes[0].evaluate(a, {}, y), Gl * f.compositeTextSizes[1].evaluate(a, {}, y)], (x[0] > _u || x[1] > _u) && d(`${t.layerIds[0]}: Value for \"text-size\" is >= 255. Reduce your \"text-size\".`)), t.addSymbols(t.text, m, x, o, s, a, u, e, l.lineStartIndex, l.lineLength, p, y);\n\n      for (const e of c) h[e] = t.text.placedSymbolArray.length - 1;\n\n      return 4 * m.length;\n    }\n\n    function ku(t) {\n      for (const e in t) return t[e];\n\n      return null;\n    }\n\n    function Su(t, e, r, n) {\n      const i = t.compareText;\n\n      if (e in i) {\n        const t = i[e];\n\n        for (let e = t.length - 1; e >= 0; e--) if (n.dist(t[e]) < r) return !0;\n      } else i[e] = [];\n\n      return i[e].push(n), !1;\n    }\n\n    const zu = yo.VectorTileFeature.types,\n          Iu = [{\n      name: \"a_fade_opacity\",\n      components: 1,\n      type: \"Uint8\",\n      offset: 0\n    }];\n\n    function Mu(t, e, r, n, i, s, a, o, l, u, c, h, p) {\n      const f = o ? Math.min(_u, Math.round(o[0])) : 0,\n            d = o ? Math.min(_u, Math.round(o[1])) : 0;\n      t.emplaceBack(e, r, Math.round(32 * n), Math.round(32 * i), s, a, (f << 1) + (l ? 1 : 0), d, 16 * u, 16 * c, 256 * h, 256 * p);\n    }\n\n    function Bu(t, e, r) {\n      t.emplaceBack(e.x, e.y, r), t.emplaceBack(e.x, e.y, r), t.emplaceBack(e.x, e.y, r), t.emplaceBack(e.x, e.y, r);\n    }\n\n    function Cu(t) {\n      for (const e of t.sections) if (Dn(e.text)) return !0;\n\n      return !1;\n    }\n\n    class Pu {\n      constructor(t) {\n        this.layoutVertexArray = new rs(), this.indexArray = new os(), this.programConfigurations = t, this.segments = new hs(), this.dynamicLayoutVertexArray = new ns(), this.opacityVertexArray = new is(), this.placedSymbolArray = new ji();\n      }\n\n      isEmpty() {\n        return 0 === this.layoutVertexArray.length && 0 === this.indexArray.length && 0 === this.dynamicLayoutVertexArray.length && 0 === this.opacityVertexArray.length;\n      }\n\n      upload(t, e, r, n) {\n        this.isEmpty() || (r && (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Jo.members), this.indexBuffer = t.createIndexBuffer(this.indexArray, e), this.dynamicLayoutVertexBuffer = t.createVertexBuffer(this.dynamicLayoutVertexArray, Xo.members, !0), this.opacityVertexBuffer = t.createVertexBuffer(this.opacityVertexArray, Iu, !0), this.opacityVertexBuffer.itemSize = 1), (r || n) && this.programConfigurations.upload(t));\n      }\n\n      destroy() {\n        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy());\n      }\n\n    }\n\n    kn(\"SymbolBuffers\", Pu);\n\n    class Vu {\n      constructor(t, e, r) {\n        this.layoutVertexArray = new t(), this.layoutAttributes = e, this.indexArray = new r(), this.segments = new hs(), this.collisionVertexArray = new as();\n      }\n\n      upload(t) {\n        this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t.createVertexBuffer(this.collisionVertexArray, Yo.members, !0);\n      }\n\n      destroy() {\n        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy());\n      }\n\n    }\n\n    kn(\"CollisionBuffers\", Vu);\n\n    class Eu {\n      constructor(e) {\n        this.collisionBoxArray = e.collisionBoxArray, this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map(t => t.id), this.index = e.index, this.pixelRatio = e.pixelRatio, this.sourceLayerIndex = e.sourceLayerIndex, this.hasPattern = !1, this.hasRTLText = !1, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = ua([]), this.placementViewportMatrix = ua([]);\n        const r = this.layers[0]._unevaluatedLayout._values;\n        this.textSizeData = Jl(this.zoom, r[\"text-size\"]), this.iconSizeData = Jl(this.zoom, r[\"icon-size\"]);\n        const n = this.layers[0].layout,\n              i = n.get(\"symbol-sort-key\"),\n              s = n.get(\"symbol-z-order\");\n        this.canOverlap = \"never\" !== $u(n, \"text-overlap\", \"text-allow-overlap\") || \"never\" !== $u(n, \"icon-overlap\", \"icon-allow-overlap\") || n.get(\"text-ignore-placement\") || n.get(\"icon-ignore-placement\"), this.sortFeaturesByKey = \"viewport-y\" !== s && !i.isConstant(), this.sortFeaturesByY = (\"viewport-y\" === s || \"auto\" === s && !this.sortFeaturesByKey) && this.canOverlap, \"point\" === n.get(\"symbol-placement\") && (this.writingModes = n.get(\"text-writing-mode\").map(e => t.WritingMode[e])), this.stateDependentLayerIds = this.layers.filter(t => t.isStateDependent()).map(t => t.id), this.sourceID = e.sourceID;\n      }\n\n      createArrays() {\n        this.text = new Pu(new Ls(this.layers, this.zoom, t => /^text/.test(t))), this.icon = new Pu(new Ls(this.layers, this.zoom, t => /^icon/.test(t))), this.glyphOffsetArray = new Zi(), this.lineVertexArray = new Gi(), this.symbolInstances = new Ki();\n      }\n\n      calculateGlyphDependencies(t, e, r, n, i) {\n        for (let s = 0; s < t.length; s++) if (e[t.charCodeAt(s)] = !0, (r || n) && i) {\n          const r = tl[t.charAt(s)];\n          r && (e[r.charCodeAt(0)] = !0);\n        }\n      }\n\n      populate(e, r, n) {\n        const i = this.layers[0],\n              s = i.layout,\n              a = s.get(\"text-font\"),\n              o = s.get(\"text-field\"),\n              l = s.get(\"icon-image\"),\n              u = (\"constant\" !== o.value.kind || o.value.value instanceof Lt && !o.value.value.isEmpty() || o.value.value.toString().length > 0) && (\"constant\" !== a.value.kind || a.value.value.length > 0),\n              c = \"constant\" !== l.value.kind || !!l.value.value || Object.keys(l.parameters).length > 0,\n              h = s.get(\"symbol-sort-key\");\n        if (this.features = [], !u && !c) return;\n        const p = r.iconDependencies,\n              f = r.glyphDependencies,\n              d = r.availableImages,\n              y = new Yn(this.zoom);\n\n        for (const {\n          feature: r,\n          id: o,\n          index: l,\n          sourceLayerIndex: m\n        } of e) {\n          const e = i._featureFilter.needGeometry,\n                g = js(r, e);\n          if (!i._featureFilter.filter(y, g, n)) continue;\n          let x, v;\n\n          if (e || (g.geometry = qs(r)), u) {\n            const t = i.getValueAndResolveTokens(\"text-field\", g, n, d),\n                  e = Lt.factory(t);\n            Cu(e) && (this.hasRTLText = !0), (!this.hasRTLText || \"unavailable\" === Gn() || this.hasRTLText && Xn.isParsed()) && (x = Qo(e, i, g));\n          }\n\n          if (c) {\n            const t = i.getValueAndResolveTokens(\"icon-image\", g, n, d);\n            v = t instanceof Dt ? t : Dt.fromString(t);\n          }\n\n          if (!x && !v) continue;\n          const b = this.sortFeaturesByKey ? h.evaluate(g, {}, n) : void 0;\n\n          if (this.features.push({\n            id: o,\n            text: x,\n            icon: v,\n            index: l,\n            sourceLayerIndex: m,\n            geometry: g.geometry,\n            properties: r.properties,\n            type: zu[r.type],\n            sortKey: b\n          }), v && (p[v.name] = !0), x) {\n            const e = a.evaluate(g, {}, n).join(\",\"),\n                  r = \"map\" === s.get(\"text-rotation-alignment\") && \"point\" !== s.get(\"symbol-placement\");\n            this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(t.WritingMode.vertical) >= 0;\n\n            for (const t of x.sections) if (t.image) p[t.image.name] = !0;else {\n              const n = Cn(x.toString()),\n                    i = t.fontStack || e,\n                    s = f[i] = f[i] || {};\n              this.calculateGlyphDependencies(t.text, s, r, this.allowVerticalPlacement, n);\n            }\n          }\n        }\n\n        \"line\" === s.get(\"symbol-placement\") && (this.features = function (t) {\n          const e = {},\n                r = {},\n                n = [];\n          let i = 0;\n\n          function s(e) {\n            n.push(t[e]), i++;\n          }\n\n          function a(t, e, i) {\n            const s = r[t];\n            return delete r[t], r[e] = s, n[s].geometry[0].pop(), n[s].geometry[0] = n[s].geometry[0].concat(i[0]), s;\n          }\n\n          function o(t, r, i) {\n            const s = e[r];\n            return delete e[r], e[t] = s, n[s].geometry[0].shift(), n[s].geometry[0] = i[0].concat(n[s].geometry[0]), s;\n          }\n\n          function l(t, e, r) {\n            const n = r ? e[0][e[0].length - 1] : e[0][0];\n            return `${t}:${n.x}:${n.y}`;\n          }\n\n          for (let u = 0; u < t.length; u++) {\n            const c = t[u],\n                  h = c.geometry,\n                  p = c.text ? c.text.toString() : null;\n\n            if (!p) {\n              s(u);\n              continue;\n            }\n\n            const f = l(p, h),\n                  d = l(p, h, !0);\n\n            if (f in r && d in e && r[f] !== e[d]) {\n              const t = o(f, d, h),\n                    i = a(f, d, n[t].geometry);\n              delete e[f], delete r[d], r[l(p, n[i].geometry, !0)] = i, n[t].geometry = null;\n            } else f in r ? a(f, d, h) : d in e ? o(f, d, h) : (s(u), e[f] = i - 1, r[d] = i - 1);\n          }\n\n          return n.filter(t => t.geometry);\n        }(this.features)), this.sortFeaturesByKey && this.features.sort((t, e) => t.sortKey - e.sortKey);\n      }\n\n      update(t, e, r) {\n        this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(t, e, this.layers, r), this.icon.programConfigurations.updatePaintArrays(t, e, this.layers, r));\n      }\n\n      isEmpty() {\n        return 0 === this.symbolInstances.length && !this.hasRTLText;\n      }\n\n      uploadPending() {\n        return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;\n      }\n\n      upload(t) {\n        !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t), this.iconCollisionBox.upload(t)), this.text.upload(t, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(t, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = !0;\n      }\n\n      destroyDebugData() {\n        this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();\n      }\n\n      destroy() {\n        this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();\n      }\n\n      addToLineVertexArray(t, e) {\n        const r = this.lineVertexArray.length;\n\n        if (void 0 !== t.segment) {\n          let r = t.dist(e[t.segment + 1]),\n              n = t.dist(e[t.segment]);\n          const i = {};\n\n          for (let n = t.segment + 1; n < e.length; n++) i[n] = {\n            x: e[n].x,\n            y: e[n].y,\n            tileUnitDistanceFromAnchor: r\n          }, n < e.length - 1 && (r += e[n + 1].dist(e[n]));\n\n          for (let r = t.segment || 0; r >= 0; r--) i[r] = {\n            x: e[r].x,\n            y: e[r].y,\n            tileUnitDistanceFromAnchor: n\n          }, r > 0 && (n += e[r - 1].dist(e[r]));\n\n          for (let t = 0; t < e.length; t++) {\n            const e = i[t];\n            this.lineVertexArray.emplaceBack(e.x, e.y, e.tileUnitDistanceFromAnchor);\n          }\n        }\n\n        return {\n          lineStartIndex: r,\n          lineLength: this.lineVertexArray.length - r\n        };\n      }\n\n      addSymbols(e, r, n, i, s, a, o, l, u, c, h, p) {\n        const f = e.indexArray,\n              d = e.layoutVertexArray,\n              y = e.segments.prepareSegment(4 * r.length, d, f, this.canOverlap ? a.sortKey : void 0),\n              m = this.glyphOffsetArray.length,\n              g = y.vertexLength,\n              x = this.allowVerticalPlacement && o === t.WritingMode.vertical ? Math.PI / 2 : 0,\n              v = a.text && a.text.sections;\n\n        for (let t = 0; t < r.length; t++) {\n          const {\n            tl: i,\n            tr: s,\n            bl: o,\n            br: u,\n            tex: c,\n            pixelOffsetTL: h,\n            pixelOffsetBR: m,\n            minFontScaleX: g,\n            minFontScaleY: b,\n            glyphOffset: w,\n            isSDF: _,\n            sectionIndex: A\n          } = r[t],\n                k = y.vertexLength,\n                S = w[1];\n          Mu(d, l.x, l.y, i.x, S + i.y, c.x, c.y, n, _, h.x, h.y, g, b), Mu(d, l.x, l.y, s.x, S + s.y, c.x + c.w, c.y, n, _, m.x, h.y, g, b), Mu(d, l.x, l.y, o.x, S + o.y, c.x, c.y + c.h, n, _, h.x, m.y, g, b), Mu(d, l.x, l.y, u.x, S + u.y, c.x + c.w, c.y + c.h, n, _, m.x, m.y, g, b), Bu(e.dynamicLayoutVertexArray, l, x), f.emplaceBack(k, k + 1, k + 2), f.emplaceBack(k + 1, k + 2, k + 3), y.vertexLength += 4, y.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(w[0]), t !== r.length - 1 && A === r[t + 1].sectionIndex || e.programConfigurations.populatePaintArrays(d.length, a, a.index, {}, p, v && v[A]);\n        }\n\n        e.placedSymbolArray.emplaceBack(l.x, l.y, m, this.glyphOffsetArray.length - m, g, u, c, l.segment, n ? n[0] : 0, n ? n[1] : 0, i[0], i[1], o, 0, !1, 0, h);\n      }\n\n      _addCollisionDebugVertex(t, e, r, n, i, s) {\n        return e.emplaceBack(0, 0), t.emplaceBack(r.x, r.y, n, i, Math.round(s.x), Math.round(s.y));\n      }\n\n      addCollisionDebugVertices(t, e, r, n, i, s, a) {\n        const o = i.segments.prepareSegment(4, i.layoutVertexArray, i.indexArray),\n              l = o.vertexLength,\n              u = i.layoutVertexArray,\n              c = i.collisionVertexArray,\n              h = a.anchorX,\n              p = a.anchorY;\n        this._addCollisionDebugVertex(u, c, s, h, p, new S(t, e)), this._addCollisionDebugVertex(u, c, s, h, p, new S(r, e)), this._addCollisionDebugVertex(u, c, s, h, p, new S(r, n)), this._addCollisionDebugVertex(u, c, s, h, p, new S(t, n)), o.vertexLength += 4;\n        const f = i.indexArray;\n        f.emplaceBack(l, l + 1), f.emplaceBack(l + 1, l + 2), f.emplaceBack(l + 2, l + 3), f.emplaceBack(l + 3, l), o.primitiveLength += 4;\n      }\n\n      addDebugCollisionBoxes(t, e, r, n) {\n        for (let i = t; i < e; i++) {\n          const t = this.collisionBoxArray.get(i);\n          this.addCollisionDebugVertices(t.x1, t.y1, t.x2, t.y2, n ? this.textCollisionBox : this.iconCollisionBox, t.anchorPoint, r);\n        }\n      }\n\n      generateCollisionDebugBuffers() {\n        this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new Vu(ss, Ho.members, ls), this.iconCollisionBox = new Vu(ss, Ho.members, ls);\n\n        for (let t = 0; t < this.symbolInstances.length; t++) {\n          const e = this.symbolInstances.get(t);\n          this.addDebugCollisionBoxes(e.textBoxStartIndex, e.textBoxEndIndex, e, !0), this.addDebugCollisionBoxes(e.verticalTextBoxStartIndex, e.verticalTextBoxEndIndex, e, !0), this.addDebugCollisionBoxes(e.iconBoxStartIndex, e.iconBoxEndIndex, e, !1), this.addDebugCollisionBoxes(e.verticalIconBoxStartIndex, e.verticalIconBoxEndIndex, e, !1);\n        }\n      }\n\n      _deserializeCollisionBoxesForSymbol(t, e, r, n, i, s, a, o, l) {\n        const u = {};\n\n        for (let n = e; n < r; n++) {\n          const e = t.get(n);\n          u.textBox = {\n            x1: e.x1,\n            y1: e.y1,\n            x2: e.x2,\n            y2: e.y2,\n            anchorPointX: e.anchorPointX,\n            anchorPointY: e.anchorPointY\n          }, u.textFeatureIndex = e.featureIndex;\n          break;\n        }\n\n        for (let e = n; e < i; e++) {\n          const r = t.get(e);\n          u.verticalTextBox = {\n            x1: r.x1,\n            y1: r.y1,\n            x2: r.x2,\n            y2: r.y2,\n            anchorPointX: r.anchorPointX,\n            anchorPointY: r.anchorPointY\n          }, u.verticalTextFeatureIndex = r.featureIndex;\n          break;\n        }\n\n        for (let e = s; e < a; e++) {\n          const r = t.get(e);\n          u.iconBox = {\n            x1: r.x1,\n            y1: r.y1,\n            x2: r.x2,\n            y2: r.y2,\n            anchorPointX: r.anchorPointX,\n            anchorPointY: r.anchorPointY\n          }, u.iconFeatureIndex = r.featureIndex;\n          break;\n        }\n\n        for (let e = o; e < l; e++) {\n          const r = t.get(e);\n          u.verticalIconBox = {\n            x1: r.x1,\n            y1: r.y1,\n            x2: r.x2,\n            y2: r.y2,\n            anchorPointX: r.anchorPointX,\n            anchorPointY: r.anchorPointY\n          }, u.verticalIconFeatureIndex = r.featureIndex;\n          break;\n        }\n\n        return u;\n      }\n\n      deserializeCollisionBoxes(t) {\n        this.collisionArrays = [];\n\n        for (let e = 0; e < this.symbolInstances.length; e++) {\n          const r = this.symbolInstances.get(e);\n          this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t, r.textBoxStartIndex, r.textBoxEndIndex, r.verticalTextBoxStartIndex, r.verticalTextBoxEndIndex, r.iconBoxStartIndex, r.iconBoxEndIndex, r.verticalIconBoxStartIndex, r.verticalIconBoxEndIndex));\n        }\n      }\n\n      hasTextData() {\n        return this.text.segments.get().length > 0;\n      }\n\n      hasIconData() {\n        return this.icon.segments.get().length > 0;\n      }\n\n      hasDebugData() {\n        return this.textCollisionBox && this.iconCollisionBox;\n      }\n\n      hasTextCollisionBoxData() {\n        return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;\n      }\n\n      hasIconCollisionBoxData() {\n        return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;\n      }\n\n      addIndicesForPlacedSymbol(t, e) {\n        const r = t.placedSymbolArray.get(e),\n              n = r.vertexStartIndex + 4 * r.numGlyphs;\n\n        for (let e = r.vertexStartIndex; e < n; e += 4) t.indexArray.emplaceBack(e, e + 1, e + 2), t.indexArray.emplaceBack(e + 1, e + 2, e + 3);\n      }\n\n      getSortedSymbolIndexes(t) {\n        if (this.sortedAngle === t && void 0 !== this.symbolInstanceIndexes) return this.symbolInstanceIndexes;\n        const e = Math.sin(t),\n              r = Math.cos(t),\n              n = [],\n              i = [],\n              s = [];\n\n        for (let t = 0; t < this.symbolInstances.length; ++t) {\n          s.push(t);\n          const a = this.symbolInstances.get(t);\n          n.push(0 | Math.round(e * a.anchorX + r * a.anchorY)), i.push(a.featureIndex);\n        }\n\n        return s.sort((t, e) => n[t] - n[e] || i[e] - i[t]), s;\n      }\n\n      addToSortKeyRanges(t, e) {\n        const r = this.sortKeyRanges[this.sortKeyRanges.length - 1];\n        r && r.sortKey === e ? r.symbolInstanceEnd = t + 1 : this.sortKeyRanges.push({\n          sortKey: e,\n          symbolInstanceStart: t,\n          symbolInstanceEnd: t + 1\n        });\n      }\n\n      sortFeatures(t) {\n        if (this.sortFeaturesByY && this.sortedAngle !== t && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {\n          this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t), this.sortedAngle = t, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];\n\n          for (const t of this.symbolInstanceIndexes) {\n            const e = this.symbolInstances.get(t);\n            this.featureSortOrder.push(e.featureIndex), [e.rightJustifiedTextSymbolIndex, e.centerJustifiedTextSymbolIndex, e.leftJustifiedTextSymbolIndex].forEach((t, e, r) => {\n              t >= 0 && r.indexOf(t) === e && this.addIndicesForPlacedSymbol(this.text, t);\n            }), e.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, e.verticalPlacedTextSymbolIndex), e.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, e.placedIconSymbolIndex), e.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, e.verticalPlacedIconSymbolIndex);\n          }\n\n          this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);\n        }\n      }\n\n    }\n\n    kn(\"SymbolBucket\", Eu, {\n      omit: [\"layers\", \"collisionBoxArray\", \"features\", \"compareText\"]\n    }), Eu.MAX_GLYPHS = 65535, Eu.addDynamicAttributes = Bu;\n    const Fu = new ci({\n      \"symbol-placement\": new si(nt.layout_symbol[\"symbol-placement\"]),\n      \"symbol-spacing\": new si(nt.layout_symbol[\"symbol-spacing\"]),\n      \"symbol-avoid-edges\": new si(nt.layout_symbol[\"symbol-avoid-edges\"]),\n      \"symbol-sort-key\": new ai(nt.layout_symbol[\"symbol-sort-key\"]),\n      \"symbol-z-order\": new si(nt.layout_symbol[\"symbol-z-order\"]),\n      \"icon-allow-overlap\": new si(nt.layout_symbol[\"icon-allow-overlap\"]),\n      \"icon-overlap\": new si(nt.layout_symbol[\"icon-overlap\"]),\n      \"icon-ignore-placement\": new si(nt.layout_symbol[\"icon-ignore-placement\"]),\n      \"icon-optional\": new si(nt.layout_symbol[\"icon-optional\"]),\n      \"icon-rotation-alignment\": new si(nt.layout_symbol[\"icon-rotation-alignment\"]),\n      \"icon-size\": new ai(nt.layout_symbol[\"icon-size\"]),\n      \"icon-text-fit\": new si(nt.layout_symbol[\"icon-text-fit\"]),\n      \"icon-text-fit-padding\": new si(nt.layout_symbol[\"icon-text-fit-padding\"]),\n      \"icon-image\": new ai(nt.layout_symbol[\"icon-image\"]),\n      \"icon-rotate\": new ai(nt.layout_symbol[\"icon-rotate\"]),\n      \"icon-padding\": new si(nt.layout_symbol[\"icon-padding\"]),\n      \"icon-keep-upright\": new si(nt.layout_symbol[\"icon-keep-upright\"]),\n      \"icon-offset\": new ai(nt.layout_symbol[\"icon-offset\"]),\n      \"icon-anchor\": new ai(nt.layout_symbol[\"icon-anchor\"]),\n      \"icon-pitch-alignment\": new si(nt.layout_symbol[\"icon-pitch-alignment\"]),\n      \"text-pitch-alignment\": new si(nt.layout_symbol[\"text-pitch-alignment\"]),\n      \"text-rotation-alignment\": new si(nt.layout_symbol[\"text-rotation-alignment\"]),\n      \"text-field\": new ai(nt.layout_symbol[\"text-field\"]),\n      \"text-font\": new ai(nt.layout_symbol[\"text-font\"]),\n      \"text-size\": new ai(nt.layout_symbol[\"text-size\"]),\n      \"text-max-width\": new ai(nt.layout_symbol[\"text-max-width\"]),\n      \"text-line-height\": new si(nt.layout_symbol[\"text-line-height\"]),\n      \"text-letter-spacing\": new ai(nt.layout_symbol[\"text-letter-spacing\"]),\n      \"text-justify\": new ai(nt.layout_symbol[\"text-justify\"]),\n      \"text-radial-offset\": new ai(nt.layout_symbol[\"text-radial-offset\"]),\n      \"text-variable-anchor\": new si(nt.layout_symbol[\"text-variable-anchor\"]),\n      \"text-anchor\": new ai(nt.layout_symbol[\"text-anchor\"]),\n      \"text-max-angle\": new si(nt.layout_symbol[\"text-max-angle\"]),\n      \"text-writing-mode\": new si(nt.layout_symbol[\"text-writing-mode\"]),\n      \"text-rotate\": new ai(nt.layout_symbol[\"text-rotate\"]),\n      \"text-padding\": new si(nt.layout_symbol[\"text-padding\"]),\n      \"text-keep-upright\": new si(nt.layout_symbol[\"text-keep-upright\"]),\n      \"text-transform\": new ai(nt.layout_symbol[\"text-transform\"]),\n      \"text-offset\": new ai(nt.layout_symbol[\"text-offset\"]),\n      \"text-allow-overlap\": new si(nt.layout_symbol[\"text-allow-overlap\"]),\n      \"text-overlap\": new si(nt.layout_symbol[\"text-overlap\"]),\n      \"text-ignore-placement\": new si(nt.layout_symbol[\"text-ignore-placement\"]),\n      \"text-optional\": new si(nt.layout_symbol[\"text-optional\"])\n    });\n    var Tu = {\n      paint: new ci({\n        \"icon-opacity\": new ai(nt.paint_symbol[\"icon-opacity\"]),\n        \"icon-color\": new ai(nt.paint_symbol[\"icon-color\"]),\n        \"icon-halo-color\": new ai(nt.paint_symbol[\"icon-halo-color\"]),\n        \"icon-halo-width\": new ai(nt.paint_symbol[\"icon-halo-width\"]),\n        \"icon-halo-blur\": new ai(nt.paint_symbol[\"icon-halo-blur\"]),\n        \"icon-translate\": new si(nt.paint_symbol[\"icon-translate\"]),\n        \"icon-translate-anchor\": new si(nt.paint_symbol[\"icon-translate-anchor\"]),\n        \"text-opacity\": new ai(nt.paint_symbol[\"text-opacity\"]),\n        \"text-color\": new ai(nt.paint_symbol[\"text-color\"], {\n          runtimeType: yt,\n          getOverride: t => t.textColor,\n          hasOverride: t => !!t.textColor\n        }),\n        \"text-halo-color\": new ai(nt.paint_symbol[\"text-halo-color\"]),\n        \"text-halo-width\": new ai(nt.paint_symbol[\"text-halo-width\"]),\n        \"text-halo-blur\": new ai(nt.paint_symbol[\"text-halo-blur\"]),\n        \"text-translate\": new si(nt.paint_symbol[\"text-translate\"]),\n        \"text-translate-anchor\": new si(nt.paint_symbol[\"text-translate-anchor\"])\n      }),\n      layout: Fu\n    };\n\n    class Lu {\n      constructor(t) {\n        this.type = t.property.overrides ? t.property.overrides.runtimeType : ht, this.defaultValue = t;\n      }\n\n      evaluate(t) {\n        if (t.formattedSection) {\n          const e = this.defaultValue.property.overrides;\n          if (e && e.hasOverride(t.formattedSection)) return e.getOverride(t.formattedSection);\n        }\n\n        return t.feature && t.featureState ? this.defaultValue.evaluate(t.feature, t.featureState) : this.defaultValue.property.specification.default;\n      }\n\n      eachChild(t) {\n        this.defaultValue.isConstant() || t(this.defaultValue.value._styleExpression.expression);\n      }\n\n      outputDefined() {\n        return !1;\n      }\n\n      serialize() {\n        return null;\n      }\n\n    }\n\n    kn(\"FormatSectionOverride\", Lu, {\n      omit: [\"defaultValue\"]\n    });\n\n    class Du extends pi {\n      constructor(t) {\n        super(t, Tu);\n      }\n\n      recalculate(t, e) {\n        if (super.recalculate(t, e), \"auto\" === this.layout.get(\"icon-rotation-alignment\") && (this.layout._values[\"icon-rotation-alignment\"] = \"point\" !== this.layout.get(\"symbol-placement\") ? \"map\" : \"viewport\"), \"auto\" === this.layout.get(\"text-rotation-alignment\") && (this.layout._values[\"text-rotation-alignment\"] = \"point\" !== this.layout.get(\"symbol-placement\") ? \"map\" : \"viewport\"), \"auto\" === this.layout.get(\"text-pitch-alignment\") && (this.layout._values[\"text-pitch-alignment\"] = this.layout.get(\"text-rotation-alignment\")), \"auto\" === this.layout.get(\"icon-pitch-alignment\") && (this.layout._values[\"icon-pitch-alignment\"] = this.layout.get(\"icon-rotation-alignment\")), \"point\" === this.layout.get(\"symbol-placement\")) {\n          const t = this.layout.get(\"text-writing-mode\");\n\n          if (t) {\n            const e = [];\n\n            for (const r of t) e.indexOf(r) < 0 && e.push(r);\n\n            this.layout._values[\"text-writing-mode\"] = e;\n          } else this.layout._values[\"text-writing-mode\"] = [\"horizontal\"];\n        }\n\n        this._setPaintOverrides();\n      }\n\n      getValueAndResolveTokens(t, e, r, n) {\n        const i = this.layout.get(t).evaluate(e, {}, r, n),\n              s = this._unevaluatedLayout._values[t];\n        return s.isDataDriven() || Pr(s.value) || !i ? i : function (t, e) {\n          return e.replace(/{([^{}]+)}/g, (e, r) => r in t ? String(t[r]) : \"\");\n        }(e.properties, i);\n      }\n\n      createBucket(t) {\n        return new Eu(t);\n      }\n\n      queryRadius() {\n        return 0;\n      }\n\n      queryIntersectsFeature() {\n        return !1;\n      }\n\n      _setPaintOverrides() {\n        for (const t of Tu.paint.overridableProperties) {\n          if (!Du.hasPaintOverride(this.layout, t)) continue;\n          const e = this.paint.get(t),\n                r = new Lu(e),\n                n = new Cr(r, e.property.specification);\n          let i = null;\n          i = \"constant\" === e.value.kind || \"source\" === e.value.kind ? new Er(\"source\", n) : new Fr(\"composite\", n, e.value.zoomStops, e.value._interpolationType), this.paint._values[t] = new ni(e.property, i, e.parameters);\n        }\n      }\n\n      _handleOverridablePaintPropertyUpdate(t, e, r) {\n        return !(!this.layout || e.isDataDriven() || r.isDataDriven()) && Du.hasPaintOverride(this.layout, t);\n      }\n\n      static hasPaintOverride(t, e) {\n        const r = t.get(\"text-field\"),\n              n = Tu.paint.properties[e];\n        let i = !1;\n\n        const s = t => {\n          for (const e of t) if (n.overrides && n.overrides.hasOverride(e)) return void (i = !0);\n        };\n\n        if (\"constant\" === r.value.kind && r.value.value instanceof Lt) s(r.value.value.sections);else if (\"source\" === r.value.kind) {\n          const t = e => {\n            i || (e instanceof qt && Rt(e.value) === vt ? s(e.value.sections) : e instanceof Zt ? s(e.sections) : e.eachChild(t));\n          },\n                e = r.value;\n\n          e._styleExpression && t(e._styleExpression.expression);\n        }\n        return i;\n      }\n\n    }\n\n    function $u(t, e, r) {\n      let n = \"never\";\n      const i = t.get(e);\n      return i ? n = i : t.get(r) && (n = \"always\"), n;\n    }\n\n    var Ou = {\n      paint: new ci({\n        \"background-color\": new si(nt.paint_background[\"background-color\"]),\n        \"background-pattern\": new li(nt.paint_background[\"background-pattern\"]),\n        \"background-opacity\": new si(nt.paint_background[\"background-opacity\"])\n      })\n    },\n        Ru = {\n      paint: new ci({\n        \"raster-opacity\": new si(nt.paint_raster[\"raster-opacity\"]),\n        \"raster-hue-rotate\": new si(nt.paint_raster[\"raster-hue-rotate\"]),\n        \"raster-brightness-min\": new si(nt.paint_raster[\"raster-brightness-min\"]),\n        \"raster-brightness-max\": new si(nt.paint_raster[\"raster-brightness-max\"]),\n        \"raster-saturation\": new si(nt.paint_raster[\"raster-saturation\"]),\n        \"raster-contrast\": new si(nt.paint_raster[\"raster-contrast\"]),\n        \"raster-resampling\": new si(nt.paint_raster[\"raster-resampling\"]),\n        \"raster-fade-duration\": new si(nt.paint_raster[\"raster-fade-duration\"])\n      })\n    };\n\n    class Uu extends pi {\n      constructor(t) {\n        super(t, {}), this.onAdd = t => {\n          this.implementation.onAdd && this.implementation.onAdd(t, t.painter.context.gl);\n        }, this.onRemove = t => {\n          this.implementation.onRemove && this.implementation.onRemove(t, t.painter.context.gl);\n        }, this.implementation = t;\n      }\n\n      is3D() {\n        return \"3d\" === this.implementation.renderingMode;\n      }\n\n      hasOffscreenPass() {\n        return void 0 !== this.implementation.prerender;\n      }\n\n      recalculate() {}\n\n      updateTransitions() {}\n\n      hasTransition() {\n        return !1;\n      }\n\n      serialize() {}\n\n    }\n\n    const qu = {\n      circle: class extends pi {\n        constructor(t) {\n          super(t, oa);\n        }\n\n        createBucket(t) {\n          return new Ks(t);\n        }\n\n        queryRadius(t) {\n          const e = t;\n          return na(\"circle-radius\", this, e) + na(\"circle-stroke-width\", this, e) + ia(this.paint.get(\"circle-translate\"));\n        }\n\n        queryIntersectsFeature(t, e, r, n, i, s, a, o) {\n          const l = sa(t, this.paint.get(\"circle-translate\"), this.paint.get(\"circle-translate-anchor\"), s.angle, a),\n                u = this.paint.get(\"circle-radius\").evaluate(e, r) + this.paint.get(\"circle-stroke-width\").evaluate(e, r),\n                c = \"map\" === this.paint.get(\"circle-pitch-alignment\"),\n                h = c ? l : function (t, e) {\n            return t.map(t => ya(t, e));\n          }(l, o),\n                p = c ? u * a : u;\n\n          for (const t of n) for (const e of t) {\n            const t = c ? e : ya(e, o);\n            let r = p;\n            const n = da(pa(), fa(e.x, e.y, 0, 1), o);\n            if (\"viewport\" === this.paint.get(\"circle-pitch-scale\") && \"map\" === this.paint.get(\"circle-pitch-alignment\") ? r *= n[3] / s.cameraToCenterDistance : \"map\" === this.paint.get(\"circle-pitch-scale\") && \"viewport\" === this.paint.get(\"circle-pitch-alignment\") && (r *= s.cameraToCenterDistance / n[3]), Gs(h, t, r)) return !0;\n          }\n\n          return !1;\n        }\n\n      },\n      heatmap: class extends pi {\n        constructor(t) {\n          super(t, ga), this._updateColorRamp();\n        }\n\n        createBucket(t) {\n          return new ma(t);\n        }\n\n        _handleSpecialPaintPropertyUpdate(t) {\n          \"heatmap-color\" === t && this._updateColorRamp();\n        }\n\n        _updateColorRamp() {\n          this.colorRamp = Aa({\n            expression: this._transitionablePaint._values[\"heatmap-color\"].value.expression,\n            evaluationKey: \"heatmapDensity\",\n            image: this.colorRamp\n          }), this.colorRampTexture = null;\n        }\n\n        resize() {\n          this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null);\n        }\n\n        queryRadius() {\n          return 0;\n        }\n\n        queryIntersectsFeature() {\n          return !1;\n        }\n\n        hasOffscreenPass() {\n          return 0 !== this.paint.get(\"heatmap-opacity\") && \"none\" !== this.visibility;\n        }\n\n      },\n      hillshade: class extends pi {\n        constructor(t) {\n          super(t, ka);\n        }\n\n        hasOffscreenPass() {\n          return 0 !== this.paint.get(\"hillshade-exaggeration\") && \"none\" !== this.visibility;\n        }\n\n      },\n      fill: class extends pi {\n        constructor(t) {\n          super(t, ho);\n        }\n\n        recalculate(t, e) {\n          super.recalculate(t, e);\n          const r = this.paint._values[\"fill-outline-color\"];\n          \"constant\" === r.value.kind && void 0 === r.value.value && (this.paint._values[\"fill-outline-color\"] = this.paint._values[\"fill-color\"]);\n        }\n\n        createBucket(t) {\n          return new uo(t);\n        }\n\n        queryRadius() {\n          return ia(this.paint.get(\"fill-translate\"));\n        }\n\n        queryIntersectsFeature(t, e, r, n, i, s, a) {\n          return Js(sa(t, this.paint.get(\"fill-translate\"), this.paint.get(\"fill-translate-anchor\"), s.angle, a), n);\n        }\n\n        isTileClipped() {\n          return !0;\n        }\n\n      },\n      \"fill-extrusion\": class extends pi {\n        constructor(t) {\n          super(t, Eo);\n        }\n\n        createBucket(t) {\n          return new Co(t);\n        }\n\n        queryRadius() {\n          return ia(this.paint.get(\"fill-extrusion-translate\"));\n        }\n\n        is3D() {\n          return !0;\n        }\n\n        queryIntersectsFeature(t, e, r, n, i, s, a, o) {\n          const l = sa(t, this.paint.get(\"fill-extrusion-translate\"), this.paint.get(\"fill-extrusion-translate-anchor\"), s.angle, a),\n                u = this.paint.get(\"fill-extrusion-height\").evaluate(e, r),\n                c = this.paint.get(\"fill-extrusion-base\").evaluate(e, r),\n                h = function (t, e, r, n) {\n            const i = [];\n\n            for (const r of t) {\n              const t = fa(r.x, r.y, 0, 1);\n              da(t, t, e), i.push(new S(t[0] / t[3], t[1] / t[3]));\n            }\n\n            return i;\n          }(l, o),\n                p = function (t, e, r, n) {\n            const i = [],\n                  s = [],\n                  a = n[8] * e,\n                  o = n[9] * e,\n                  l = n[10] * e,\n                  u = n[11] * e,\n                  c = n[8] * r,\n                  h = n[9] * r,\n                  p = n[10] * r,\n                  f = n[11] * r;\n\n            for (const e of t) {\n              const t = [],\n                    r = [];\n\n              for (const i of e) {\n                const e = i.x,\n                      s = i.y,\n                      d = n[0] * e + n[4] * s + n[12],\n                      y = n[1] * e + n[5] * s + n[13],\n                      m = n[2] * e + n[6] * s + n[14],\n                      g = n[3] * e + n[7] * s + n[15],\n                      x = m + l,\n                      v = g + u,\n                      b = d + c,\n                      w = y + h,\n                      _ = m + p,\n                      A = g + f,\n                      k = new S((d + a) / v, (y + o) / v);\n\n                k.z = x / v, t.push(k);\n                const z = new S(b / A, w / A);\n                z.z = _ / A, r.push(z);\n              }\n\n              i.push(t), s.push(r);\n            }\n\n            return [i, s];\n          }(n, c, u, o);\n\n          return function (t, e, r) {\n            let n = 1 / 0;\n            Js(r, e) && (n = To(r, e[0]));\n\n            for (let i = 0; i < e.length; i++) {\n              const s = e[i],\n                    a = t[i];\n\n              for (let t = 0; t < s.length - 1; t++) {\n                const e = s[t],\n                      i = [e, s[t + 1], a[t + 1], a[t], e];\n                Zs(r, i) && (n = Math.min(n, To(r, i)));\n              }\n            }\n\n            return n !== 1 / 0 && n;\n          }(p[0], p[1], h);\n        }\n\n      },\n      line: class extends pi {\n        constructor(t) {\n          super(t, Ko), this.gradientVersion = 0;\n        }\n\n        _handleSpecialPaintPropertyUpdate(t) {\n          \"line-gradient\" === t && (this.stepInterpolant = this._transitionablePaint._values[\"line-gradient\"].value.expression._styleExpression.expression instanceof ke, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER);\n        }\n\n        gradientExpression() {\n          return this._transitionablePaint._values[\"line-gradient\"].value.expression;\n        }\n\n        recalculate(t, e) {\n          super.recalculate(t, e), this.paint._values[\"line-floorwidth\"] = Zo.possiblyEvaluate(this._transitioningPaint._values[\"line-width\"].value, t);\n        }\n\n        createBucket(t) {\n          return new jo(t);\n        }\n\n        queryRadius(t) {\n          const e = t,\n                r = Go(na(\"line-width\", this, e), na(\"line-gap-width\", this, e)),\n                n = na(\"line-offset\", this, e);\n          return r / 2 + Math.abs(n) + ia(this.paint.get(\"line-translate\"));\n        }\n\n        queryIntersectsFeature(t, e, r, n, i, s, a) {\n          const o = sa(t, this.paint.get(\"line-translate\"), this.paint.get(\"line-translate-anchor\"), s.angle, a),\n                l = a / 2 * Go(this.paint.get(\"line-width\").evaluate(e, r), this.paint.get(\"line-gap-width\").evaluate(e, r)),\n                u = this.paint.get(\"line-offset\").evaluate(e, r);\n          return u && (n = function (t, e) {\n            const r = [],\n                  n = new S(0, 0);\n\n            for (let i = 0; i < t.length; i++) {\n              const s = t[i],\n                    a = [];\n\n              for (let t = 0; t < s.length; t++) {\n                const r = s[t - 1],\n                      i = s[t],\n                      o = s[t + 1],\n                      l = 0 === t ? n : i.sub(r)._unit()._perp(),\n                      u = t === s.length - 1 ? n : o.sub(i)._unit()._perp(),\n                      c = l._add(u)._unit();\n\n                c._mult(1 / (c.x * u.x + c.y * u.y)), a.push(c._mult(e)._add(i));\n              }\n\n              r.push(a);\n            }\n\n            return r;\n          }(n, u * a)), function (t, e, r) {\n            for (let n = 0; n < e.length; n++) {\n              const i = e[n];\n              if (t.length >= 3) for (let e = 0; e < i.length; e++) if (ea(t, i[e])) return !0;\n              if (Xs(t, i, r)) return !0;\n            }\n\n            return !1;\n          }(o, n, l);\n        }\n\n        isTileClipped() {\n          return !0;\n        }\n\n      },\n      symbol: Du,\n      background: class extends pi {\n        constructor(t) {\n          super(t, Ou);\n        }\n\n      },\n      raster: class extends pi {\n        constructor(t) {\n          super(t, Ru);\n        }\n\n      }\n    };\n\n    class ju {\n      constructor(t) {\n        this._callback = t, this._triggered = !1, \"undefined\" != typeof MessageChannel && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {\n          this._triggered = !1, this._callback();\n        });\n      }\n\n      trigger() {\n        this._triggered || (this._triggered = !0, this._channel ? this._channel.port1.postMessage(!0) : setTimeout(() => {\n          this._triggered = !1, this._callback();\n        }, 0));\n      }\n\n      remove() {\n        delete this._channel, this._callback = () => {};\n      }\n\n    }\n\n    const Nu = 6371008.8;\n\n    class Ku {\n      constructor(t, e) {\n        if (isNaN(t) || isNaN(e)) throw new Error(`Invalid LngLat object: (${t}, ${e})`);\n        if (this.lng = +t, this.lat = +e, this.lat > 90 || this.lat < -90) throw new Error(\"Invalid LngLat latitude value: must be between -90 and 90\");\n      }\n\n      wrap() {\n        return new Ku(a(this.lng, -180, 180), this.lat);\n      }\n\n      toArray() {\n        return [this.lng, this.lat];\n      }\n\n      toString() {\n        return `LngLat(${this.lng}, ${this.lat})`;\n      }\n\n      distanceTo(t) {\n        const e = Math.PI / 180,\n              r = this.lat * e,\n              n = t.lat * e,\n              i = Math.sin(r) * Math.sin(n) + Math.cos(r) * Math.cos(n) * Math.cos((t.lng - this.lng) * e);\n        return Nu * Math.acos(Math.min(i, 1));\n      }\n\n      toBounds() {\n        let t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n        const e = 360 * t / 40075017,\n              r = e / Math.cos(Math.PI / 180 * this.lat);\n        return new Zu(new Ku(this.lng - r, this.lat - e), new Ku(this.lng + r, this.lat + e));\n      }\n\n      static convert(t) {\n        if (t instanceof Ku) return t;\n        if (Array.isArray(t) && (2 === t.length || 3 === t.length)) return new Ku(Number(t[0]), Number(t[1]));\n        if (!Array.isArray(t) && \"object\" == typeof t && null !== t) return new Ku(Number(\"lng\" in t ? t.lng : t.lon), Number(t.lat));\n        throw new Error(\"`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]\");\n      }\n\n    }\n\n    class Zu {\n      constructor(t, e) {\n        t && (e ? this.setSouthWest(t).setNorthEast(e) : 4 === t.length ? this.setSouthWest([t[0], t[1]]).setNorthEast([t[2], t[3]]) : this.setSouthWest(t[0]).setNorthEast(t[1]));\n      }\n\n      setNorthEast(t) {\n        return this._ne = t instanceof Ku ? new Ku(t.lng, t.lat) : Ku.convert(t), this;\n      }\n\n      setSouthWest(t) {\n        return this._sw = t instanceof Ku ? new Ku(t.lng, t.lat) : Ku.convert(t), this;\n      }\n\n      extend(t) {\n        const e = this._sw,\n              r = this._ne;\n        let n, i;\n        if (t instanceof Ku) n = t, i = t;else {\n          if (!(t instanceof Zu)) return Array.isArray(t) ? 4 === t.length || t.every(Array.isArray) ? this.extend(Zu.convert(t)) : this.extend(Ku.convert(t)) : this;\n          if (n = t._sw, i = t._ne, !n || !i) return this;\n        }\n        return e || r ? (e.lng = Math.min(n.lng, e.lng), e.lat = Math.min(n.lat, e.lat), r.lng = Math.max(i.lng, r.lng), r.lat = Math.max(i.lat, r.lat)) : (this._sw = new Ku(n.lng, n.lat), this._ne = new Ku(i.lng, i.lat)), this;\n      }\n\n      getCenter() {\n        return new Ku((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);\n      }\n\n      getSouthWest() {\n        return this._sw;\n      }\n\n      getNorthEast() {\n        return this._ne;\n      }\n\n      getNorthWest() {\n        return new Ku(this.getWest(), this.getNorth());\n      }\n\n      getSouthEast() {\n        return new Ku(this.getEast(), this.getSouth());\n      }\n\n      getWest() {\n        return this._sw.lng;\n      }\n\n      getSouth() {\n        return this._sw.lat;\n      }\n\n      getEast() {\n        return this._ne.lng;\n      }\n\n      getNorth() {\n        return this._ne.lat;\n      }\n\n      toArray() {\n        return [this._sw.toArray(), this._ne.toArray()];\n      }\n\n      toString() {\n        return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;\n      }\n\n      isEmpty() {\n        return !(this._sw && this._ne);\n      }\n\n      contains(t) {\n        const {\n          lng: e,\n          lat: r\n        } = Ku.convert(t);\n        let n = this._sw.lng <= e && e <= this._ne.lng;\n        return this._sw.lng > this._ne.lng && (n = this._sw.lng >= e && e >= this._ne.lng), this._sw.lat <= r && r <= this._ne.lat && n;\n      }\n\n      static convert(t) {\n        return t instanceof Zu ? t : t ? new Zu(t) : t;\n      }\n\n    }\n\n    const Gu = 2 * Math.PI * Nu;\n\n    function Ju(t) {\n      return Gu * Math.cos(t * Math.PI / 180);\n    }\n\n    function Xu(t) {\n      return (180 + t) / 360;\n    }\n\n    function Yu(t) {\n      return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t * Math.PI / 360))) / 360;\n    }\n\n    function Hu(t, e) {\n      return t / Ju(e);\n    }\n\n    function Wu(t) {\n      return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t) * Math.PI / 180)) - 90;\n    }\n\n    class Qu {\n      constructor(t, e) {\n        let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n        this.x = +t, this.y = +e, this.z = +r;\n      }\n\n      static fromLngLat(t) {\n        let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n        const r = Ku.convert(t);\n        return new Qu(Xu(r.lng), Yu(r.lat), Hu(e, r.lat));\n      }\n\n      toLngLat() {\n        return new Ku(360 * this.x - 180, Wu(this.y));\n      }\n\n      toAltitude() {\n        return this.z * Ju(Wu(this.y));\n      }\n\n      meterInMercatorCoordinateUnits() {\n        return 1 / Gu * (t = Wu(this.y), 1 / Math.cos(t * Math.PI / 180));\n        var t;\n      }\n\n    }\n\n    function tc(t, e, r) {\n      var n = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r);\n      return [t * n - 2 * Math.PI * 6378137 / 2, e * n - 2 * Math.PI * 6378137 / 2];\n    }\n\n    class ec {\n      constructor(t, e, r) {\n        this.z = t, this.x = e, this.y = r, this.key = ic(0, t, t, e, r);\n      }\n\n      equals(t) {\n        return this.z === t.z && this.x === t.x && this.y === t.y;\n      }\n\n      url(t, e, r) {\n        const n = (s = this.y, a = this.z, o = tc(256 * (i = this.x), 256 * (s = Math.pow(2, a) - s - 1), a), l = tc(256 * (i + 1), 256 * (s + 1), a), o[0] + \",\" + o[1] + \",\" + l[0] + \",\" + l[1]);\n        var i, s, a, o, l;\n\n        const u = function (t, e, r) {\n          let n,\n              i = \"\";\n\n          for (let s = t; s > 0; s--) n = 1 << s - 1, i += (e & n ? 1 : 0) + (r & n ? 2 : 0);\n\n          return i;\n        }(this.z, this.x, this.y);\n\n        return t[(this.x + this.y) % t.length].replace(/{prefix}/g, (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String(\"tms\" === r ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace(/{ratio}/g, e > 1 ? \"@2x\" : \"\").replace(/{quadkey}/g, u).replace(/{bbox-epsg-3857}/g, n);\n      }\n\n      getTilePoint(t) {\n        const e = Math.pow(2, this.z);\n        return new S((t.x * e - this.x) * Os, (t.y * e - this.y) * Os);\n      }\n\n      toString() {\n        return `${this.z}/${this.x}/${this.y}`;\n      }\n\n    }\n\n    class rc {\n      constructor(t, e) {\n        this.wrap = t, this.canonical = e, this.key = ic(t, e.z, e.z, e.x, e.y);\n      }\n\n    }\n\n    class nc {\n      constructor(t, e, r, n, i) {\n        this.overscaledZ = t, this.wrap = e, this.canonical = new ec(r, +n, +i), this.key = ic(e, t, r, n, i);\n      }\n\n      equals(t) {\n        return this.overscaledZ === t.overscaledZ && this.wrap === t.wrap && this.canonical.equals(t.canonical);\n      }\n\n      scaledTo(t) {\n        const e = this.canonical.z - t;\n        return t > this.canonical.z ? new nc(t, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new nc(t, this.wrap, t, this.canonical.x >> e, this.canonical.y >> e);\n      }\n\n      calculateScaledKey(t, e) {\n        const r = this.canonical.z - t;\n        return t > this.canonical.z ? ic(this.wrap * +e, t, this.canonical.z, this.canonical.x, this.canonical.y) : ic(this.wrap * +e, t, t, this.canonical.x >> r, this.canonical.y >> r);\n      }\n\n      isChildOf(t) {\n        if (t.wrap !== this.wrap) return !1;\n        const e = this.canonical.z - t.canonical.z;\n        return 0 === t.overscaledZ || t.overscaledZ < this.overscaledZ && t.canonical.x === this.canonical.x >> e && t.canonical.y === this.canonical.y >> e;\n      }\n\n      children(t) {\n        if (this.overscaledZ >= t) return [new nc(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];\n        const e = this.canonical.z + 1,\n              r = 2 * this.canonical.x,\n              n = 2 * this.canonical.y;\n        return [new nc(e, this.wrap, e, r, n), new nc(e, this.wrap, e, r + 1, n), new nc(e, this.wrap, e, r, n + 1), new nc(e, this.wrap, e, r + 1, n + 1)];\n      }\n\n      isLessThan(t) {\n        return this.wrap < t.wrap || !(this.wrap > t.wrap) && (this.overscaledZ < t.overscaledZ || !(this.overscaledZ > t.overscaledZ) && (this.canonical.x < t.canonical.x || !(this.canonical.x > t.canonical.x) && this.canonical.y < t.canonical.y));\n      }\n\n      wrapped() {\n        return new nc(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);\n      }\n\n      unwrapTo(t) {\n        return new nc(this.overscaledZ, t, this.canonical.z, this.canonical.x, this.canonical.y);\n      }\n\n      overscaleFactor() {\n        return Math.pow(2, this.overscaledZ - this.canonical.z);\n      }\n\n      toUnwrapped() {\n        return new rc(this.wrap, this.canonical);\n      }\n\n      toString() {\n        return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;\n      }\n\n      getTilePoint(t) {\n        return this.canonical.getTilePoint(new Qu(t.x - this.wrap, t.y));\n      }\n\n    }\n\n    function ic(t, e, r, n, i) {\n      (t *= 2) < 0 && (t = -1 * t - 1);\n      const s = 1 << r;\n      return (s * s * t + s * i + n).toString(36) + r.toString(36) + e.toString(36);\n    }\n\n    kn(\"CanonicalTileID\", ec), kn(\"OverscaledTileID\", nc, {\n      omit: [\"posMatrix\"]\n    });\n\n    class sc {\n      constructor(t, e, r) {\n        if (this.uid = t, e.height !== e.width) throw new RangeError(\"DEM tiles must be square\");\n        if (r && \"mapbox\" !== r && \"terrarium\" !== r) return void d(`\"${r}\" is not a valid encoding type. Valid types include \"mapbox\" and \"terrarium\".`);\n        this.stride = e.height;\n        const n = this.dim = e.height - 2;\n        this.data = new Uint32Array(e.data.buffer), this.encoding = r || \"mapbox\";\n\n        for (let t = 0; t < n; t++) this.data[this._idx(-1, t)] = this.data[this._idx(0, t)], this.data[this._idx(n, t)] = this.data[this._idx(n - 1, t)], this.data[this._idx(t, -1)] = this.data[this._idx(t, 0)], this.data[this._idx(t, n)] = this.data[this._idx(t, n - 1)];\n\n        this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(n, -1)] = this.data[this._idx(n - 1, 0)], this.data[this._idx(-1, n)] = this.data[this._idx(0, n - 1)], this.data[this._idx(n, n)] = this.data[this._idx(n - 1, n - 1)];\n      }\n\n      get(t, e) {\n        const r = new Uint8Array(this.data.buffer),\n              n = 4 * this._idx(t, e);\n\n        return (\"terrarium\" === this.encoding ? this._unpackTerrarium : this._unpackMapbox)(r[n], r[n + 1], r[n + 2]);\n      }\n\n      getUnpackVector() {\n        return \"terrarium\" === this.encoding ? [256, 1, 1 / 256, 32768] : [6553.6, 25.6, .1, 1e4];\n      }\n\n      _idx(t, e) {\n        if (t < -1 || t >= this.dim + 1 || e < -1 || e >= this.dim + 1) throw new RangeError(\"out of range source coordinates for DEM data\");\n        return (e + 1) * this.stride + (t + 1);\n      }\n\n      _unpackMapbox(t, e, r) {\n        return (256 * t * 256 + 256 * e + r) / 10 - 1e4;\n      }\n\n      _unpackTerrarium(t, e, r) {\n        return 256 * t + e + r / 256 - 32768;\n      }\n\n      getPixels() {\n        return new _a({\n          width: this.stride,\n          height: this.stride\n        }, new Uint8Array(this.data.buffer));\n      }\n\n      backfillBorder(t, e, r) {\n        if (this.dim !== t.dim) throw new Error(\"dem dimension mismatch\");\n        let n = e * this.dim,\n            i = e * this.dim + this.dim,\n            s = r * this.dim,\n            a = r * this.dim + this.dim;\n\n        switch (e) {\n          case -1:\n            n = i - 1;\n            break;\n\n          case 1:\n            i = n + 1;\n        }\n\n        switch (r) {\n          case -1:\n            s = a - 1;\n            break;\n\n          case 1:\n            a = s + 1;\n        }\n\n        const o = -e * this.dim,\n              l = -r * this.dim;\n\n        for (let e = s; e < a; e++) for (let r = n; r < i; r++) this.data[this._idx(r, e)] = t.data[this._idx(r + o, e + l)];\n      }\n\n    }\n\n    kn(\"DEMData\", sc);\n\n    class ac {\n      constructor(t) {\n        this._stringToNumber = {}, this._numberToString = [];\n\n        for (let e = 0; e < t.length; e++) {\n          const r = t[e];\n          this._stringToNumber[r] = e, this._numberToString[e] = r;\n        }\n      }\n\n      encode(t) {\n        return this._stringToNumber[t];\n      }\n\n      decode(t) {\n        return this._numberToString[t];\n      }\n\n    }\n\n    class oc {\n      constructor(t, e, r, n, i) {\n        this.type = \"Feature\", this._vectorTileFeature = t, t._z = e, t._x = r, t._y = n, this.properties = t.properties, this.id = i;\n      }\n\n      get geometry() {\n        return void 0 === this._geometry && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry;\n      }\n\n      set geometry(t) {\n        this._geometry = t;\n      }\n\n      toJSON() {\n        const t = function (t, e) {\n          var r = {};\n\n          for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && e.indexOf(n) < 0 && (r[n] = t[n]);\n\n          if (null != t && \"function\" == typeof Object.getOwnPropertySymbols) {\n            var i = 0;\n\n            for (n = Object.getOwnPropertySymbols(t); i < n.length; i++) e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, n[i]) && (r[n[i]] = t[n[i]]);\n          }\n\n          return r;\n        }(this, [\"_geometry\", \"_vectorTileFeature\"]);\n\n        return t.geometry = this.geometry, t;\n      }\n\n    }\n\n    class lc {\n      constructor(t, e) {\n        this.tileID = t, this.x = t.canonical.x, this.y = t.canonical.y, this.z = t.canonical.z, this.grid = new _n(Os, 16, 0), this.grid3D = new _n(Os, 16, 0), this.featureIndexArray = new Xi(), this.promoteId = e;\n      }\n\n      insert(t, e, r, n, i, s) {\n        const a = this.featureIndexArray.length;\n        this.featureIndexArray.emplaceBack(r, n, i);\n        const o = s ? this.grid3D : this.grid;\n\n        for (let t = 0; t < e.length; t++) {\n          const r = e[t],\n                n = [1 / 0, 1 / 0, -1 / 0, -1 / 0];\n\n          for (let t = 0; t < r.length; t++) {\n            const e = r[t];\n            n[0] = Math.min(n[0], e.x), n[1] = Math.min(n[1], e.y), n[2] = Math.max(n[2], e.x), n[3] = Math.max(n[3], e.y);\n          }\n\n          n[0] < Os && n[1] < Os && n[2] >= 0 && n[3] >= 0 && o.insert(a, n[0], n[1], n[2], n[3]);\n        }\n      }\n\n      loadVTLayers() {\n        return this.vtLayers || (this.vtLayers = new yo.VectorTile(new rl(this.rawTileData)).layers, this.sourceLayerCoder = new ac(this.vtLayers ? Object.keys(this.vtLayers).sort() : [\"_geojsonTileLayer\"])), this.vtLayers;\n      }\n\n      query(t, e, r, n) {\n        this.loadVTLayers();\n        const i = t.params || {},\n              s = Os / t.tileSize / t.scale,\n              a = Zr(i.filter),\n              o = t.queryGeometry,\n              l = t.queryPadding * s,\n              u = cc(o),\n              c = this.grid.query(u.minX - l, u.minY - l, u.maxX + l, u.maxY + l),\n              h = cc(t.cameraQueryGeometry),\n              p = this.grid3D.query(h.minX - l, h.minY - l, h.maxX + l, h.maxY + l, (e, r, n, i) => function (t, e, r, n, i) {\n          for (const s of t) if (e <= s.x && r <= s.y && n >= s.x && i >= s.y) return !0;\n\n          const s = [new S(e, r), new S(e, i), new S(n, i), new S(n, r)];\n          if (t.length > 2) for (const e of s) if (ea(t, e)) return !0;\n\n          for (let e = 0; e < t.length - 1; e++) if (ra(t[e], t[e + 1], s)) return !0;\n\n          return !1;\n        }(t.cameraQueryGeometry, e - l, r - l, n + l, i + l));\n\n        for (const t of p) c.push(t);\n\n        c.sort(hc);\n        const f = {};\n        let d;\n\n        for (let l = 0; l < c.length; l++) {\n          const u = c[l];\n          if (u === d) continue;\n          d = u;\n          const h = this.featureIndexArray.get(u);\n          let p = null;\n          this.loadMatchingFeature(f, h.bucketIndex, h.sourceLayerIndex, h.featureIndex, a, i.layers, i.availableImages, e, r, n, (e, r, n) => (p || (p = qs(e)), r.queryIntersectsFeature(o, e, n, p, this.z, t.transform, s, t.pixelPosMatrix)));\n        }\n\n        return f;\n      }\n\n      loadMatchingFeature(t, e, r, n, i, s, a, l, u, c, h) {\n        const p = this.bucketLayerIDs[e];\n        if (s && !function (t, e) {\n          for (let r = 0; r < t.length; r++) if (e.indexOf(t[r]) >= 0) return !0;\n\n          return !1;\n        }(s, p)) return;\n        const f = this.sourceLayerCoder.decode(r),\n              d = this.vtLayers[f].feature(n);\n\n        if (i.needGeometry) {\n          const t = js(d, !0);\n          if (!i.filter(new Yn(this.tileID.overscaledZ), t, this.tileID.canonical)) return;\n        } else if (!i.filter(new Yn(this.tileID.overscaledZ), d)) return;\n\n        const y = this.getId(d, f);\n\n        for (let e = 0; e < p.length; e++) {\n          const r = p[e];\n          if (s && s.indexOf(r) < 0) continue;\n          const i = l[r];\n          if (!i) continue;\n          let f = {};\n          y && c && (f = c.getState(i.sourceLayer || \"_geojsonTileLayer\", y));\n          const m = o({}, u[r]);\n          m.paint = uc(m.paint, i.paint, d, f, a), m.layout = uc(m.layout, i.layout, d, f, a);\n          const g = !h || h(d, i, f);\n          if (!g) continue;\n          const x = new oc(d, this.z, this.x, this.y, y);\n          x.layer = m;\n          let v = t[r];\n          void 0 === v && (v = t[r] = []), v.push({\n            featureIndex: n,\n            feature: x,\n            intersectionZ: g\n          });\n        }\n      }\n\n      lookupSymbolFeatures(t, e, r, n, i, s, a, o) {\n        const l = {};\n        this.loadVTLayers();\n        const u = Zr(i);\n\n        for (const i of t) this.loadMatchingFeature(l, r, n, i, u, s, a, o, e);\n\n        return l;\n      }\n\n      hasLayer(t) {\n        for (const e of this.bucketLayerIDs) for (const r of e) if (t === r) return !0;\n\n        return !1;\n      }\n\n      getId(t, e) {\n        let r = t.id;\n        return this.promoteId && (r = t.properties[\"string\" == typeof this.promoteId ? this.promoteId : this.promoteId[e]], \"boolean\" == typeof r && (r = Number(r))), r;\n      }\n\n    }\n\n    function uc(t, e, r, n, i) {\n      return c(t, (t, s) => {\n        const a = e instanceof ii ? e.get(s) : null;\n        return a && a.evaluate ? a.evaluate(r, n, i) : a;\n      });\n    }\n\n    function cc(t) {\n      let e = 1 / 0,\n          r = 1 / 0,\n          n = -1 / 0,\n          i = -1 / 0;\n\n      for (const s of t) e = Math.min(e, s.x), r = Math.min(r, s.y), n = Math.max(n, s.x), i = Math.max(i, s.y);\n\n      return {\n        minX: e,\n        minY: r,\n        maxX: n,\n        maxY: i\n      };\n    }\n\n    function hc(t, e) {\n      return e - t;\n    }\n\n    var pc;\n    kn(\"FeatureIndex\", lc, {\n      omit: [\"rawTileData\", \"sourceLayerCoder\"]\n    }), t.PerformanceMarkers = void 0, (pc = t.PerformanceMarkers || (t.PerformanceMarkers = {})).create = \"create\", pc.load = \"load\", pc.fullLoad = \"fullLoad\";\n    let fc = null,\n        dc = [];\n    const yc = 1e3 / 30,\n          mc = {\n      mark(t) {\n        performance.mark(t);\n      },\n\n      frame(t) {\n        const e = t;\n        null != fc && dc.push(e - fc), fc = e;\n      },\n\n      clearMetrics() {\n        fc = null, dc = [], performance.clearMeasures(\"loadTime\"), performance.clearMeasures(\"fullLoadTime\");\n\n        for (const e in t.PerformanceMarkers) performance.clearMarks(t.PerformanceMarkers[e]);\n      },\n\n      getPerformanceMetrics() {\n        performance.measure(\"loadTime\", t.PerformanceMarkers.create, t.PerformanceMarkers.load), performance.measure(\"fullLoadTime\", t.PerformanceMarkers.create, t.PerformanceMarkers.fullLoad);\n        const e = performance.getEntriesByName(\"loadTime\")[0].duration,\n              r = performance.getEntriesByName(\"fullLoadTime\")[0].duration,\n              n = dc.length,\n              i = 1 / (dc.reduce((t, e) => t + e, 0) / n / 1e3),\n              s = dc.filter(t => t > yc).reduce((t, e) => t + (e - yc) / yc, 0);\n        return {\n          loadTime: e,\n          fullLoadTime: r,\n          fps: i,\n          percentDroppedFrames: s / (n + s) * 100\n        };\n      }\n\n    };\n    t.AJAXError = q, t.ARRAY_TYPE = la, t.Actor = class {\n      constructor(t, e, r) {\n        this.target = t, this.parent = e, this.mapId = r, this.callbacks = {}, this.tasks = {}, this.taskQueue = [], this.cancelCallbacks = {}, u([\"receive\", \"process\"], this), this.invoker = new ju(this.process), this.target.addEventListener(\"message\", this.receive, !1), this.globalScope = g() ? t : window;\n      }\n\n      send(t, e, r, n) {\n        let i = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : !1;\n        const s = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);\n        r && (this.callbacks[s] = r);\n        const a = _(this.globalScope) ? void 0 : [];\n        return this.target.postMessage({\n          id: s,\n          type: t,\n          hasCallback: !!r,\n          targetMapId: n,\n          mustQueue: i,\n          sourceMapId: this.mapId,\n          data: zn(e, a)\n        }, a), {\n          cancel: () => {\n            r && delete this.callbacks[s], this.target.postMessage({\n              id: s,\n              type: \"<cancel>\",\n              targetMapId: n,\n              sourceMapId: this.mapId\n            });\n          }\n        };\n      }\n\n      receive(t) {\n        const e = t.data,\n              r = e.id;\n        if (r && (!e.targetMapId || this.mapId === e.targetMapId)) if (\"<cancel>\" === e.type) {\n          delete this.tasks[r];\n          const t = this.cancelCallbacks[r];\n          delete this.cancelCallbacks[r], t && t();\n        } else g() || e.mustQueue ? (this.tasks[r] = e, this.taskQueue.push(r), this.invoker.trigger()) : this.processTask(r, e);\n      }\n\n      process() {\n        if (!this.taskQueue.length) return;\n        const t = this.taskQueue.shift(),\n              e = this.tasks[t];\n        delete this.tasks[t], this.taskQueue.length && this.invoker.trigger(), e && this.processTask(t, e);\n      }\n\n      processTask(t, e) {\n        if (\"<response>\" === e.type) {\n          const r = this.callbacks[t];\n          delete this.callbacks[t], r && (e.error ? r(In(e.error)) : r(null, In(e.data)));\n        } else {\n          let r = !1;\n          const n = _(this.globalScope) ? void 0 : [],\n                i = e.hasCallback ? (e, i) => {\n            r = !0, delete this.cancelCallbacks[t], this.target.postMessage({\n              id: t,\n              type: \"<response>\",\n              sourceMapId: this.mapId,\n              error: e ? zn(e) : null,\n              data: zn(i, n)\n            }, n);\n          } : t => {\n            r = !0;\n          };\n          let s = null;\n          const a = In(e.data);\n          if (this.parent[e.type]) s = this.parent[e.type](e.sourceMapId, a, i);else if (this.parent.getWorkerSource) {\n            const t = e.type.split(\".\");\n            s = this.parent.getWorkerSource(e.sourceMapId, t[0], a.source)[t[1]](a, i);\n          } else i(new Error(`Could not find function ${e.type}`));\n          !r && s && s.cancel && (this.cancelCallbacks[t] = s.cancel);\n        }\n      }\n\n      remove() {\n        this.invoker.remove(), this.target.removeEventListener(\"message\", this.receive, !1);\n      }\n\n    }, t.AlphaImage = wa, t.CanonicalTileID = ec, t.CollisionBoxArray = Ui, t.CollisionCircleLayoutArray = class extends Bi {}, t.Color = Et, t.DEMData = sc, t.DataConstantProperty = si, t.DictionaryCoder = ac, t.EXTENT = Os, t.ErrorEvent = et, t.EvaluationParameters = Yn, t.Event = tt, t.Evented = rt, t.FeatureIndex = lc, t.FillBucket = uo, t.FillExtrusionBucket = Co, t.GeoJSONFeature = oc, t.ImageAtlas = Cl, t.ImagePosition = Bl, t.LineBucket = jo, t.LineStripIndexArray = class extends $i {}, t.LngLat = Ku, t.LngLatBounds = Zu, t.MercatorCoordinate = Qu, t.ONE_EM = el, t.OverscaledTileID = nc, t.PerformanceUtils = mc, t.PosArray = class extends xi {}, t.Properties = ci, t.QuadTriangleArray = class extends Pi {}, t.RGBAImage = _a, t.RasterBoundsArray = class extends vi {}, t.RequestPerformance = class {\n      constructor(t) {\n        this._marks = {\n          start: [t.url, \"start\"].join(\"#\"),\n          end: [t.url, \"end\"].join(\"#\"),\n          measure: t.url.toString()\n        }, performance.mark(this._marks.start);\n      }\n\n      finish() {\n        performance.mark(this._marks.end);\n        let t = performance.getEntriesByName(this._marks.measure);\n        return 0 === t.length && (performance.measure(this._marks.measure, this._marks.start, this._marks.end), t = performance.getEntriesByName(this._marks.measure), performance.clearMarks(this._marks.start), performance.clearMarks(this._marks.end), performance.clearMeasures(this._marks.measure)), t;\n      }\n\n    }, t.ResourceType = U, t.SegmentVector = hs, t.SymbolBucket = Eu, t.Transitionable = Qn, t.TriangleIndexArray = os, t.Uniform1f = Ss, t.Uniform1i = class extends ks {\n      constructor(t, e) {\n        super(t, e), this.current = 0;\n      }\n\n      set(t) {\n        this.current !== t && (this.current = t, this.gl.uniform1i(this.location, t));\n      }\n\n    }, t.Uniform2f = class extends ks {\n      constructor(t, e) {\n        super(t, e), this.current = [0, 0];\n      }\n\n      set(t) {\n        t[0] === this.current[0] && t[1] === this.current[1] || (this.current = t, this.gl.uniform2f(this.location, t[0], t[1]));\n      }\n\n    }, t.Uniform3f = class extends ks {\n      constructor(t, e) {\n        super(t, e), this.current = [0, 0, 0];\n      }\n\n      set(t) {\n        t[0] === this.current[0] && t[1] === this.current[1] && t[2] === this.current[2] || (this.current = t, this.gl.uniform3f(this.location, t[0], t[1], t[2]));\n      }\n\n    }, t.Uniform4f = zs, t.UniformColor = Is, t.UniformMatrix4f = class extends ks {\n      constructor(t, e) {\n        super(t, e), this.current = Ms;\n      }\n\n      set(t) {\n        if (t[12] !== this.current[12] || t[0] !== this.current[0]) return this.current = t, void this.gl.uniformMatrix4fv(this.location, !1, t);\n\n        for (let e = 1; e < 16; e++) if (t[e] !== this.current[e]) {\n          this.current = t, this.gl.uniformMatrix4fv(this.location, !1, t);\n          break;\n        }\n      }\n\n    }, t.UnwrappedTileID = rc, t.ValidationError = it, t.ZoomHistory = Mn, t.addDynamicAttributes = Bu, t.asyncAll = function (t, e, r) {\n      if (!t.length) return r(null, []);\n      let n = t.length;\n      const i = new Array(t.length);\n      let s = null;\n      t.forEach((t, a) => {\n        e(t, (t, e) => {\n          t && (s = t), i[a] = e, 0 == --n && r(s, i);\n        });\n      });\n    }, t.bezier = n, t.bindAll = u, t.cacheEntryPossiblyAdded = function (t) {\n      F++, F > V && (t.getActor().send(\"enforceCacheSizeLimit\", P), F = 0);\n    }, t.clamp = s, t.clearTileCache = function (t) {\n      const e = caches.delete(M);\n      t && e.catch(t).then(() => t());\n    }, t.clipLine = au, t.clone = function (t) {\n      var e = new la(16);\n      return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], e;\n    }, t.clone$1 = p, t.collisionCircleLayout = Wo, t.config = I, t.create = function () {\n      var t = new la(16);\n      return la != Float32Array && (t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0), t[0] = 1, t[5] = 1, t[10] = 1, t[15] = 1, t;\n    }, t.createExpression = Vr, t.createFilter = Zr, t.createLayout = mi, t.createStyleLayer = function (t) {\n      return \"custom\" === t.type ? new Uu(t) : new qu[t.type](t);\n    }, t.dot = function (t, e) {\n      return t[0] * e[0] + t[1] * e[1] + t[2] * e[2] + t[3] * e[3];\n    }, t.ease = i, t.emitValidationErrors = wn, t.enforceCacheSizeLimit = function (t) {\n      E(), B && B.then(e => {\n        e.keys().then(r => {\n          for (let n = 0; n < r.length - t; n++) e.delete(r[n]);\n        });\n      });\n    }, t.evaluateSizeForFeature = Xl, t.evaluateSizeForZoom = Yl, t.evaluateVariableOffset = vu, t.evented = Zn, t.exported = k, t.exported$1 = T, t.extend = o, t.filterObject = h, t.fromValues = fa, t.getAnchorAlignment = jl, t.getAnchorJustification = bu, t.getArrayBuffer = Z, t.getImage = H, t.getJSON = function (t, e) {\n      return K(o(t, {\n        type: \"json\"\n      }), e);\n    }, t.getOverlapMode = $u, t.getRTLTextPluginStatus = Gn, t.getReferrer = j, t.getVideo = function (t, e) {\n      const r = window.document.createElement(\"video\");\n      r.muted = !0, r.onloadstart = function () {\n        e(null, r);\n      };\n\n      for (let e = 0; e < t.length; e++) {\n        const n = window.document.createElement(\"source\");\n        G(t[e]) || (r.crossOrigin = \"Anonymous\"), n.src = t[e], r.appendChild(n);\n      }\n\n      return {\n        cancel: () => {}\n      };\n    }, t.identity = ua, t.invert = function (t, e) {\n      var r = e[0],\n          n = e[1],\n          i = e[2],\n          s = e[3],\n          a = e[4],\n          o = e[5],\n          l = e[6],\n          u = e[7],\n          c = e[8],\n          h = e[9],\n          p = e[10],\n          f = e[11],\n          d = e[12],\n          y = e[13],\n          m = e[14],\n          g = e[15],\n          x = r * o - n * a,\n          v = r * l - i * a,\n          b = r * u - s * a,\n          w = n * l - i * o,\n          _ = n * u - s * o,\n          A = i * u - s * l,\n          k = c * y - h * d,\n          S = c * m - p * d,\n          z = c * g - f * d,\n          I = h * m - p * y,\n          M = h * g - f * y,\n          B = p * g - f * m,\n          C = x * B - v * M + b * I + w * z - _ * S + A * k;\n\n      return C ? (t[0] = (o * B - l * M + u * I) * (C = 1 / C), t[1] = (i * M - n * B - s * I) * C, t[2] = (y * A - m * _ + g * w) * C, t[3] = (p * _ - h * A - f * w) * C, t[4] = (l * z - a * B - u * S) * C, t[5] = (r * B - i * z + s * S) * C, t[6] = (m * b - d * A - g * v) * C, t[7] = (c * A - p * b + f * v) * C, t[8] = (a * M - o * z + u * k) * C, t[9] = (n * z - r * M - s * k) * C, t[10] = (d * _ - y * b + g * x) * C, t[11] = (h * b - c * _ - f * x) * C, t[12] = (o * S - a * I - l * k) * C, t[13] = (r * I - n * S + i * k) * C, t[14] = (y * v - d * w - m * x) * C, t[15] = (c * w - h * v + p * x) * C, t) : null;\n    }, t.isImageBitmap = A, t.isSafari = _, t.keysDifference = function (t, e) {\n      const r = [];\n\n      for (const n in t) n in e || r.push(n);\n\n      return r;\n    }, t.lazyLoadRTLTextPlugin = function () {\n      Xn.isLoading() || Xn.isLoaded() || \"deferred\" !== Gn() || Jn();\n    }, t.makeRequest = K, t.mapObject = c, t.mercatorXfromLng = Xu, t.mercatorYfromLat = Yu, t.mercatorZfromAltitude = Hu, t.mul = ha, t.multiply = ca, t.nextPowerOfTwo = function (t) {\n      return t <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(t) / Math.LN2));\n    }, t.number = Se, t.ortho = function (t, e, r, n, i, s, a) {\n      var o = 1 / (e - r),\n          l = 1 / (n - i),\n          u = 1 / (s - a);\n      return t[0] = -2 * o, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = -2 * l, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 2 * u, t[11] = 0, t[12] = (e + r) * o, t[13] = (i + n) * l, t[14] = (a + s) * u, t[15] = 1, t;\n    }, t.parseCacheControl = x, t.parseGlyphPBF = function (t) {\n      return new rl(t).readFields(Sl, []);\n    }, t.pbf = rl, t.performSymbolLayout = function (e, r, n, i, s, a, o) {\n      e.createArrays(), e.tilePixelRatio = Os / (512 * e.overscaling), e.compareText = {}, e.iconsNeedLinear = !1;\n      const l = e.layers[0].layout,\n            u = e.layers[0]._unevaluatedLayout._values,\n            c = {\n        layoutIconSize: u[\"icon-size\"].possiblyEvaluate(new Yn(e.zoom + 1), o),\n        layoutTextSize: u[\"text-size\"].possiblyEvaluate(new Yn(e.zoom + 1), o),\n        textMaxSize: u[\"text-size\"].possiblyEvaluate(new Yn(18))\n      };\n\n      if (\"composite\" === e.textSizeData.kind) {\n        const {\n          minZoom: t,\n          maxZoom: r\n        } = e.textSizeData;\n        c.compositeTextSizes = [u[\"text-size\"].possiblyEvaluate(new Yn(t), o), u[\"text-size\"].possiblyEvaluate(new Yn(r), o)];\n      }\n\n      if (\"composite\" === e.iconSizeData.kind) {\n        const {\n          minZoom: t,\n          maxZoom: r\n        } = e.iconSizeData;\n        c.compositeIconSizes = [u[\"icon-size\"].possiblyEvaluate(new Yn(t), o), u[\"icon-size\"].possiblyEvaluate(new Yn(r), o)];\n      }\n\n      const h = l.get(\"text-line-height\") * el,\n            p = \"map\" === l.get(\"text-rotation-alignment\") && \"point\" !== l.get(\"symbol-placement\"),\n            f = l.get(\"text-keep-upright\"),\n            y = l.get(\"text-size\");\n\n      for (const a of e.features) {\n        const u = l.get(\"text-font\").evaluate(a, {}, o).join(\",\"),\n              m = y.evaluate(a, {}, o),\n              g = c.layoutTextSize.evaluate(a, {}, o),\n              x = c.layoutIconSize.evaluate(a, {}, o),\n              v = {\n          horizontal: {},\n          vertical: void 0\n        },\n              b = a.text;\n        let w,\n            _ = [0, 0];\n\n        if (b) {\n          const i = b.toString(),\n                c = l.get(\"text-letter-spacing\").evaluate(a, {}, o) * el,\n                d = Pn(i) ? c : 0,\n                y = l.get(\"text-anchor\").evaluate(a, {}, o),\n                x = l.get(\"text-variable-anchor\");\n\n          if (!x) {\n            const t = l.get(\"text-radial-offset\").evaluate(a, {}, o);\n            _ = t ? vu(y, [t * el, xu]) : l.get(\"text-offset\").evaluate(a, {}, o).map(t => t * el);\n          }\n\n          let w = p ? \"center\" : l.get(\"text-justify\").evaluate(a, {}, o);\n\n          const A = l.get(\"symbol-placement\"),\n                k = \"point\" === A ? l.get(\"text-max-width\").evaluate(a, {}, o) * el : 0,\n                S = () => {\n            e.allowVerticalPlacement && Cn(i) && (v.vertical = Fl(b, r, n, s, u, k, h, y, \"left\", d, _, t.WritingMode.vertical, !0, A, g, m));\n          };\n\n          if (!p && x) {\n            const e = \"auto\" === w ? x.map(t => bu(t)) : [w];\n            let i = !1;\n\n            for (let a = 0; a < e.length; a++) {\n              const o = e[a];\n              if (!v.horizontal[o]) if (i) v.horizontal[o] = v.horizontal[0];else {\n                const e = Fl(b, r, n, s, u, k, h, \"center\", o, d, _, t.WritingMode.horizontal, !1, A, g, m);\n                e && (v.horizontal[o] = e, i = 1 === e.positionedLines.length);\n              }\n            }\n\n            S();\n          } else {\n            \"auto\" === w && (w = bu(y));\n            const e = Fl(b, r, n, s, u, k, h, y, w, d, _, t.WritingMode.horizontal, !1, A, g, m);\n            e && (v.horizontal[w] = e), S(), Cn(i) && p && f && (v.vertical = Fl(b, r, n, s, u, k, h, y, w, d, _, t.WritingMode.vertical, !1, A, g, m));\n          }\n        }\n\n        let A = !1;\n\n        if (a.icon && a.icon.name) {\n          const t = i[a.icon.name];\n          t && (w = Kl(s[a.icon.name], l.get(\"icon-offset\").evaluate(a, {}, o), l.get(\"icon-anchor\").evaluate(a, {}, o)), A = !!t.sdf, void 0 === e.sdfIcons ? e.sdfIcons = A : e.sdfIcons !== A && d(\"Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer\"), (t.pixelRatio !== e.pixelRatio || 0 !== l.get(\"icon-rotate\").constantOr(1)) && (e.iconsNeedLinear = !0));\n        }\n\n        const k = ku(v.horizontal) || v.vertical;\n        e.iconsInText = !!k && k.iconsInText, (k || w) && wu(e, a, v, w, i, c, g, x, _, A, o);\n      }\n\n      a && e.generateCollisionDebugBuffers();\n    }, t.perspective = function (t, e, r, n, i) {\n      var s,\n          a = 1 / Math.tan(e / 2);\n      return t[0] = a / r, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = a, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[11] = -1, t[12] = 0, t[13] = 0, t[15] = 0, null != i && i !== 1 / 0 ? (t[10] = (i + n) * (s = 1 / (n - i)), t[14] = 2 * i * n * s) : (t[10] = -1, t[14] = -2 * n), t;\n    }, t.pick = function (t, e) {\n      const r = {};\n\n      for (let n = 0; n < e.length; n++) {\n        const i = e[n];\n        i in t && (r[i] = t[i]);\n      }\n\n      return r;\n    }, t.plugin = Xn, t.pointGeometry = S, t.polygonIntersectsPolygon = Zs, t.potpack = Ml, t.refProperties = [\"type\", \"source\", \"source-layer\", \"minzoom\", \"maxzoom\", \"filter\", \"layout\"], t.register = kn, t.registerForPluginStateChange = function (t) {\n      return t({\n        pluginStatus: qn,\n        pluginURL: jn\n      }), Zn.on(\"pluginStateChange\", t), t;\n    }, t.renderColorRamp = Aa, t.rotateX = function (t, e, r) {\n      var n = Math.sin(r),\n          i = Math.cos(r),\n          s = e[4],\n          a = e[5],\n          o = e[6],\n          l = e[7],\n          u = e[8],\n          c = e[9],\n          h = e[10],\n          p = e[11];\n      return e !== t && (t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t[4] = s * i + u * n, t[5] = a * i + c * n, t[6] = o * i + h * n, t[7] = l * i + p * n, t[8] = u * i - s * n, t[9] = c * i - a * n, t[10] = h * i - o * n, t[11] = p * i - l * n, t;\n    }, t.rotateZ = function (t, e, r) {\n      var n = Math.sin(r),\n          i = Math.cos(r),\n          s = e[0],\n          a = e[1],\n          o = e[2],\n          l = e[3],\n          u = e[4],\n          c = e[5],\n          h = e[6],\n          p = e[7];\n      return e !== t && (t[8] = e[8], t[9] = e[9], t[10] = e[10], t[11] = e[11], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t[0] = s * i + u * n, t[1] = a * i + c * n, t[2] = o * i + h * n, t[3] = l * i + p * n, t[4] = u * i - s * n, t[5] = c * i - a * n, t[6] = h * i - o * n, t[7] = p * i - l * n, t;\n    }, t.scale = function (t, e, r) {\n      var n = r[0],\n          i = r[1],\n          s = r[2];\n      return t[0] = e[0] * n, t[1] = e[1] * n, t[2] = e[2] * n, t[3] = e[3] * n, t[4] = e[4] * i, t[5] = e[5] * i, t[6] = e[6] * i, t[7] = e[7] * i, t[8] = e[8] * s, t[9] = e[9] * s, t[10] = e[10] * s, t[11] = e[11] * s, t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15], t;\n    }, t.scale$1 = function (t, e, r) {\n      return t[0] = e[0] * r, t[1] = e[1] * r, t[2] = e[2] * r, t[3] = e[3] * r, t;\n    }, t.setCacheLimits = function (t, e) {\n      P = t, V = e;\n    }, t.setRTLTextPlugin = function (t, e) {\n      let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;\n      if (qn === $n || qn === On || qn === Rn) throw new Error(\"setRTLTextPlugin cannot be called multiple times.\");\n      jn = k.resolveURL(t), qn = $n, Un = e, Kn(), r || Jn();\n    }, t.spec = nt, t.sphericalToCartesian = function (_ref64) {\n      let [t, e, r] = _ref64;\n      return e += 90, e *= Math.PI / 180, r *= Math.PI / 180, {\n        x: t * Math.cos(e) * Math.sin(r),\n        y: t * Math.sin(e) * Math.sin(r),\n        z: t * Math.cos(r)\n      };\n    }, t.symbolSize = Hl, t.toEvaluationFeature = js, t.transformMat4 = da, t.translate = function (t, e, r) {\n      var n,\n          i,\n          s,\n          a,\n          o,\n          l,\n          u,\n          c,\n          h,\n          p,\n          f,\n          d,\n          y = r[0],\n          m = r[1],\n          g = r[2];\n      return e === t ? (t[12] = e[0] * y + e[4] * m + e[8] * g + e[12], t[13] = e[1] * y + e[5] * m + e[9] * g + e[13], t[14] = e[2] * y + e[6] * m + e[10] * g + e[14], t[15] = e[3] * y + e[7] * m + e[11] * g + e[15]) : (i = e[1], s = e[2], a = e[3], o = e[4], l = e[5], u = e[6], c = e[7], h = e[8], p = e[9], f = e[10], d = e[11], t[0] = n = e[0], t[1] = i, t[2] = s, t[3] = a, t[4] = o, t[5] = l, t[6] = u, t[7] = c, t[8] = h, t[9] = p, t[10] = f, t[11] = d, t[12] = n * y + o * m + h * g + e[12], t[13] = i * y + l * m + p * g + e[13], t[14] = s * y + u * m + f * g + e[14], t[15] = a * y + c * m + d * g + e[15]), t;\n    }, t.triggerPluginCompletionEvent = Nn, t.unicodeBlockLookup = Bn, t.uniqueId = function () {\n      return l++;\n    }, t.validateCustomStyleLayer = function (t) {\n      const e = [],\n            r = t.id;\n      return void 0 === r && e.push({\n        message: `layers.${r}: missing required property \"id\"`\n      }), void 0 === t.render && e.push({\n        message: `layers.${r}: missing required method \"render\"`\n      }), t.renderingMode && \"2d\" !== t.renderingMode && \"3d\" !== t.renderingMode && e.push({\n        message: `layers.${r}: property \"renderingMode\" must be either \"2d\" or \"3d\"`\n      }), e;\n    }, t.validateLight = xn, t.validateStyle = gn, t.vectorTile = yo, t.warnOnce = d, t.wrap = a;\n  });\n  define([\"./shared\"], function (e) {\n    \"use strict\";\n\n    function t(e) {\n      const o = typeof e;\n      if (\"number\" === o || \"boolean\" === o || \"string\" === o || null == e) return JSON.stringify(e);\n\n      if (Array.isArray(e)) {\n        let o = \"[\";\n\n        for (const i of e) o += `${t(i)},`;\n\n        return `${o}]`;\n      }\n\n      const i = Object.keys(e).sort();\n      let r = \"{\";\n\n      for (let o = 0; o < i.length; o++) r += `${JSON.stringify(i[o])}:${t(e[i[o]])},`;\n\n      return `${r}}`;\n    }\n\n    function o(o) {\n      let i = \"\";\n\n      for (const r of e.refProperties) i += `/${t(o[r])}`;\n\n      return i;\n    }\n\n    class i {\n      constructor(e) {\n        this.keyCache = {}, e && this.replace(e);\n      }\n\n      replace(e) {\n        this._layerConfigs = {}, this._layers = {}, this.update(e, []);\n      }\n\n      update(t, i) {\n        for (const o of t) {\n          this._layerConfigs[o.id] = o;\n          const t = this._layers[o.id] = e.createStyleLayer(o);\n          t._featureFilter = e.createFilter(t.filter), this.keyCache[o.id] && delete this.keyCache[o.id];\n        }\n\n        for (const e of i) delete this.keyCache[e], delete this._layerConfigs[e], delete this._layers[e];\n\n        this.familiesBySource = {};\n\n        const r = function (e, t) {\n          const i = {};\n\n          for (let r = 0; r < e.length; r++) {\n            const n = t && t[e[r].id] || o(e[r]);\n            t && (t[e[r].id] = n);\n            let s = i[n];\n            s || (s = i[n] = []), s.push(e[r]);\n          }\n\n          const r = [];\n\n          for (const e in i) r.push(i[e]);\n\n          return r;\n        }(Object.values(this._layerConfigs), this.keyCache);\n\n        for (const e of r) {\n          const t = e.map(e => this._layers[e.id]),\n                o = t[0];\n          if (\"none\" === o.visibility) continue;\n          const i = o.source || \"\";\n          let r = this.familiesBySource[i];\n          r || (r = this.familiesBySource[i] = {});\n          const n = o.sourceLayer || \"_geojsonTileLayer\";\n          let s = r[n];\n          s || (s = r[n] = []), s.push(t);\n        }\n      }\n\n    }\n\n    class r {\n      constructor(t) {\n        const o = {},\n              i = [];\n\n        for (const e in t) {\n          const r = t[e],\n                n = o[e] = {};\n\n          for (const e in r) {\n            const t = r[+e];\n            if (!t || 0 === t.bitmap.width || 0 === t.bitmap.height) continue;\n            const o = {\n              x: 0,\n              y: 0,\n              w: t.bitmap.width + 2,\n              h: t.bitmap.height + 2\n            };\n            i.push(o), n[e] = {\n              rect: o,\n              metrics: t.metrics\n            };\n          }\n        }\n\n        const {\n          w: r,\n          h: n\n        } = e.potpack(i),\n              s = new e.AlphaImage({\n          width: r || 1,\n          height: n || 1\n        });\n\n        for (const i in t) {\n          const r = t[i];\n\n          for (const t in r) {\n            const n = r[+t];\n            if (!n || 0 === n.bitmap.width || 0 === n.bitmap.height) continue;\n            const a = o[i][t].rect;\n            e.AlphaImage.copy(n.bitmap, s, {\n              x: 0,\n              y: 0\n            }, {\n              x: a.x + 1,\n              y: a.y + 1\n            }, n.bitmap);\n          }\n        }\n\n        this.image = s, this.positions = o;\n      }\n\n    }\n\n    e.register(\"GlyphAtlas\", r);\n\n    class n {\n      constructor(t) {\n        this.tileID = new e.OverscaledTileID(t.tileID.overscaledZ, t.tileID.wrap, t.tileID.canonical.z, t.tileID.canonical.x, t.tileID.canonical.y), this.uid = t.uid, this.zoom = t.zoom, this.pixelRatio = t.pixelRatio, this.tileSize = t.tileSize, this.source = t.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = t.showCollisionBoxes, this.collectResourceTiming = !!t.collectResourceTiming, this.returnDependencies = !!t.returnDependencies, this.promoteId = t.promoteId;\n      }\n\n      parse(t, o, i, n, a) {\n        this.status = \"parsing\", this.data = t, this.collisionBoxArray = new e.CollisionBoxArray();\n        const l = new e.DictionaryCoder(Object.keys(t.layers).sort()),\n              c = new e.FeatureIndex(this.tileID, this.promoteId);\n        c.bucketLayerIDs = [];\n        const u = {},\n              h = {\n          featureIndex: c,\n          iconDependencies: {},\n          patternDependencies: {},\n          glyphDependencies: {},\n          availableImages: i\n        },\n              p = o.familiesBySource[this.source];\n\n        for (const o in p) {\n          const r = t.layers[o];\n          if (!r) continue;\n          1 === r.version && e.warnOnce(`Vector tile source \"${this.source}\" layer \"${o}\" does not use vector tile spec v2 and therefore may have some rendering errors.`);\n          const n = l.encode(o),\n                a = [];\n\n          for (let e = 0; e < r.length; e++) {\n            const t = r.feature(e),\n                  i = c.getId(t, o);\n            a.push({\n              feature: t,\n              id: i,\n              index: e,\n              sourceLayerIndex: n\n            });\n          }\n\n          for (const e of p[o]) {\n            const t = e[0];\n            t.minzoom && this.zoom < Math.floor(t.minzoom) || t.maxzoom && this.zoom >= t.maxzoom || \"none\" !== t.visibility && (s(e, this.zoom, i), (u[t.id] = t.createBucket({\n              index: c.bucketLayerIDs.length,\n              layers: e,\n              zoom: this.zoom,\n              pixelRatio: this.pixelRatio,\n              overscaling: this.overscaling,\n              collisionBoxArray: this.collisionBoxArray,\n              sourceLayerIndex: n,\n              sourceID: this.source\n            })).populate(a, h, this.tileID.canonical), c.bucketLayerIDs.push(e.map(e => e.id)));\n          }\n        }\n\n        let f, d, g, m;\n        const y = e.mapObject(h.glyphDependencies, e => Object.keys(e).map(Number));\n        Object.keys(y).length ? n.send(\"getGlyphs\", {\n          uid: this.uid,\n          stacks: y\n        }, (e, t) => {\n          f || (f = e, d = t, w.call(this));\n        }) : d = {};\n        const v = Object.keys(h.iconDependencies);\n        v.length ? n.send(\"getImages\", {\n          icons: v,\n          source: this.source,\n          tileID: this.tileID,\n          type: \"icons\"\n        }, (e, t) => {\n          f || (f = e, g = t, w.call(this));\n        }) : g = {};\n        const x = Object.keys(h.patternDependencies);\n\n        function w() {\n          if (f) return a(f);\n\n          if (d && g && m) {\n            const t = new r(d),\n                  o = new e.ImageAtlas(g, m);\n\n            for (const r in u) {\n              const n = u[r];\n              n instanceof e.SymbolBucket ? (s(n.layers, this.zoom, i), e.performSymbolLayout(n, d, t.positions, g, o.iconPositions, this.showCollisionBoxes, this.tileID.canonical)) : n.hasPattern && (n instanceof e.LineBucket || n instanceof e.FillBucket || n instanceof e.FillExtrusionBucket) && (s(n.layers, this.zoom, i), n.addFeatures(h, this.tileID.canonical, o.patternPositions));\n            }\n\n            this.status = \"done\", a(null, {\n              buckets: Object.values(u).filter(e => !e.isEmpty()),\n              featureIndex: c,\n              collisionBoxArray: this.collisionBoxArray,\n              glyphAtlasImage: t.image,\n              imageAtlas: o,\n              glyphMap: this.returnDependencies ? d : null,\n              iconMap: this.returnDependencies ? g : null,\n              glyphPositions: this.returnDependencies ? t.positions : null\n            });\n          }\n        }\n\n        x.length ? n.send(\"getImages\", {\n          icons: x,\n          source: this.source,\n          tileID: this.tileID,\n          type: \"patterns\"\n        }, (e, t) => {\n          f || (f = e, m = t, w.call(this));\n        }) : m = {}, w.call(this);\n      }\n\n    }\n\n    function s(t, o, i) {\n      const r = new e.EvaluationParameters(o);\n\n      for (const e of t) e.recalculate(r, i);\n    }\n\n    function a(t, o) {\n      const i = e.getArrayBuffer(t.request, (t, i, r, n) => {\n        t ? o(t) : i && o(null, {\n          vectorTile: new e.vectorTile.VectorTile(new e.pbf(i)),\n          rawData: i,\n          cacheControl: r,\n          expires: n\n        });\n      });\n      return () => {\n        i.cancel(), o();\n      };\n    }\n\n    class l {\n      constructor(e, t, o, i) {\n        this.actor = e, this.layerIndex = t, this.availableImages = o, this.loadVectorData = i || a, this.loading = {}, this.loaded = {};\n      }\n\n      loadTile(t, o) {\n        const i = t.uid;\n        this.loading || (this.loading = {});\n        const r = !!(t && t.request && t.request.collectResourceTiming) && new e.RequestPerformance(t.request),\n              s = this.loading[i] = new n(t);\n        s.abort = this.loadVectorData(t, (t, n) => {\n          if (delete this.loading[i], t || !n) return s.status = \"done\", this.loaded[i] = s, o(t);\n          const a = n.rawData,\n                l = {};\n          n.expires && (l.expires = n.expires), n.cacheControl && (l.cacheControl = n.cacheControl);\n          const c = {};\n\n          if (r) {\n            const e = r.finish();\n            e && (c.resourceTiming = JSON.parse(JSON.stringify(e)));\n          }\n\n          s.vectorTile = n.vectorTile, s.parse(n.vectorTile, this.layerIndex, this.availableImages, this.actor, (t, i) => {\n            if (t || !i) return o(t);\n            o(null, e.extend({\n              rawTileData: a.slice(0)\n            }, i, l, c));\n          }), this.loaded = this.loaded || {}, this.loaded[i] = s;\n        });\n      }\n\n      reloadTile(e, t) {\n        const o = this.loaded,\n              i = e.uid,\n              r = this;\n\n        if (o && o[i]) {\n          const n = o[i];\n          n.showCollisionBoxes = e.showCollisionBoxes;\n\n          const s = (e, o) => {\n            const i = n.reloadCallback;\n            i && (delete n.reloadCallback, n.parse(n.vectorTile, r.layerIndex, this.availableImages, r.actor, i)), t(e, o);\n          };\n\n          \"parsing\" === n.status ? n.reloadCallback = s : \"done\" === n.status && (n.vectorTile ? n.parse(n.vectorTile, this.layerIndex, this.availableImages, this.actor, s) : s());\n        }\n      }\n\n      abortTile(e, t) {\n        const o = this.loading,\n              i = e.uid;\n        o && o[i] && o[i].abort && (o[i].abort(), delete o[i]), t();\n      }\n\n      removeTile(e, t) {\n        const o = this.loaded,\n              i = e.uid;\n        o && o[i] && delete o[i], t();\n      }\n\n    }\n\n    class c {\n      constructor() {\n        this.loaded = {};\n      }\n\n      loadTile(t, o) {\n        const {\n          uid: i,\n          encoding: r,\n          rawImageData: n\n        } = t,\n              s = e.isImageBitmap(n) ? this.getImageData(n) : n,\n              a = new e.DEMData(i, s, r);\n        this.loaded = this.loaded || {}, this.loaded[i] = a, o(null, a);\n      }\n\n      getImageData(t) {\n        this.offscreenCanvas && this.offscreenCanvasContext || (this.offscreenCanvas = new OffscreenCanvas(t.width, t.height), this.offscreenCanvasContext = this.offscreenCanvas.getContext(\"2d\")), this.offscreenCanvas.width = t.width, this.offscreenCanvas.height = t.height, this.offscreenCanvasContext.drawImage(t, 0, 0, t.width, t.height);\n        const o = this.offscreenCanvasContext.getImageData(-1, -1, t.width + 2, t.height + 2);\n        return this.offscreenCanvasContext.clearRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height), new e.RGBAImage({\n          width: o.width,\n          height: o.height\n        }, o.data);\n      }\n\n      removeTile(e) {\n        const t = this.loaded,\n              o = e.uid;\n        t && t[o] && delete t[o];\n      }\n\n    }\n\n    var u = function e(t, o) {\n      var i,\n          r = t && t.type;\n      if (\"FeatureCollection\" === r) for (i = 0; i < t.features.length; i++) e(t.features[i], o);else if (\"GeometryCollection\" === r) for (i = 0; i < t.geometries.length; i++) e(t.geometries[i], o);else if (\"Feature\" === r) e(t.geometry, o);else if (\"Polygon\" === r) h(t.coordinates, o);else if (\"MultiPolygon\" === r) for (i = 0; i < t.coordinates.length; i++) h(t.coordinates[i], o);\n      return t;\n    };\n\n    function h(e, t) {\n      if (0 !== e.length) {\n        p(e[0], t);\n\n        for (var o = 1; o < e.length; o++) p(e[o], !t);\n      }\n    }\n\n    function p(e, t) {\n      for (var o = 0, i = 0, r = 0, n = e.length, s = n - 1; r < n; s = r++) {\n        var a = (e[r][0] - e[s][0]) * (e[s][1] + e[r][1]),\n            l = o + a;\n        i += Math.abs(o) >= Math.abs(a) ? o - l + a : a - l + o, o = l;\n      }\n\n      o + i >= 0 != !!t && e.reverse();\n    }\n\n    const f = e.vectorTile.VectorTileFeature.prototype.toGeoJSON;\n\n    class d {\n      constructor(t) {\n        this._feature = t, this.extent = e.EXTENT, this.type = t.type, this.properties = t.tags, \"id\" in t && !isNaN(t.id) && (this.id = parseInt(t.id, 10));\n      }\n\n      loadGeometry() {\n        if (1 === this._feature.type) {\n          const t = [];\n\n          for (const o of this._feature.geometry) t.push([new e.pointGeometry(o[0], o[1])]);\n\n          return t;\n        }\n\n        {\n          const t = [];\n\n          for (const o of this._feature.geometry) {\n            const i = [];\n\n            for (const t of o) i.push(new e.pointGeometry(t[0], t[1]));\n\n            t.push(i);\n          }\n\n          return t;\n        }\n      }\n\n      toGeoJSON(e, t, o) {\n        return f.call(this, e, t, o);\n      }\n\n    }\n\n    class g {\n      constructor(t) {\n        this.layers = {\n          _geojsonTileLayer: this\n        }, this.name = \"_geojsonTileLayer\", this.extent = e.EXTENT, this.length = t.length, this._features = t;\n      }\n\n      feature(e) {\n        return new d(this._features[e]);\n      }\n\n    }\n\n    var m = {\n      exports: {}\n    },\n        y = e.pointGeometry,\n        v = e.vectorTile.VectorTileFeature,\n        x = w;\n\n    function w(e, t) {\n      this.options = t || {}, this.features = e, this.length = e.length;\n    }\n\n    function S(e, t) {\n      this.id = \"number\" == typeof e.id ? e.id : void 0, this.type = e.type, this.rawGeometry = 1 === e.type ? [e.geometry] : e.geometry, this.properties = e.tags, this.extent = t || 4096;\n    }\n\n    w.prototype.feature = function (e) {\n      return new S(this.features[e], this.options.extent);\n    }, S.prototype.loadGeometry = function () {\n      var e = this.rawGeometry;\n      this.geometry = [];\n\n      for (var t = 0; t < e.length; t++) {\n        for (var o = e[t], i = [], r = 0; r < o.length; r++) i.push(new y(o[r][0], o[r][1]));\n\n        this.geometry.push(i);\n      }\n\n      return this.geometry;\n    }, S.prototype.bbox = function () {\n      this.geometry || this.loadGeometry();\n\n      for (var e = this.geometry, t = 1 / 0, o = -1 / 0, i = 1 / 0, r = -1 / 0, n = 0; n < e.length; n++) for (var s = e[n], a = 0; a < s.length; a++) {\n        var l = s[a];\n        t = Math.min(t, l.x), o = Math.max(o, l.x), i = Math.min(i, l.y), r = Math.max(r, l.y);\n      }\n\n      return [t, i, o, r];\n    }, S.prototype.toGeoJSON = v.prototype.toGeoJSON;\n    var I = e.pbf,\n        M = x;\n\n    function b(e) {\n      var t = new I();\n      return function (e, t) {\n        for (var o in e.layers) t.writeMessage(3, k, e.layers[o]);\n      }(e, t), t.finish();\n    }\n\n    function k(e, t) {\n      var o;\n      t.writeVarintField(15, e.version || 1), t.writeStringField(1, e.name || \"\"), t.writeVarintField(5, e.extent || 4096);\n      var i = {\n        keys: [],\n        values: [],\n        keycache: {},\n        valuecache: {}\n      };\n\n      for (o = 0; o < e.length; o++) i.feature = e.feature(o), t.writeMessage(2, _, i);\n\n      var r = i.keys;\n\n      for (o = 0; o < r.length; o++) t.writeStringField(3, r[o]);\n\n      var n = i.values;\n\n      for (o = 0; o < n.length; o++) t.writeMessage(4, L, n[o]);\n    }\n\n    function _(e, t) {\n      var o = e.feature;\n      void 0 !== o.id && t.writeVarintField(1, o.id), t.writeMessage(2, P, e), t.writeVarintField(3, o.type), t.writeMessage(4, D, o);\n    }\n\n    function P(e, t) {\n      var o = e.feature,\n          i = e.keys,\n          r = e.values,\n          n = e.keycache,\n          s = e.valuecache;\n\n      for (var a in o.properties) {\n        var l = o.properties[a],\n            c = n[a];\n\n        if (null !== l) {\n          void 0 === c && (i.push(a), n[a] = c = i.length - 1), t.writeVarint(c);\n          var u = typeof l;\n          \"string\" !== u && \"boolean\" !== u && \"number\" !== u && (l = JSON.stringify(l));\n          var h = u + \":\" + l,\n              p = s[h];\n          void 0 === p && (r.push(l), s[h] = p = r.length - 1), t.writeVarint(p);\n        }\n      }\n    }\n\n    function T(e, t) {\n      return (t << 3) + (7 & e);\n    }\n\n    function C(e) {\n      return e << 1 ^ e >> 31;\n    }\n\n    function D(e, t) {\n      for (var o = e.loadGeometry(), i = e.type, r = 0, n = 0, s = o.length, a = 0; a < s; a++) {\n        var l = o[a],\n            c = 1;\n        1 === i && (c = l.length), t.writeVarint(T(1, c));\n\n        for (var u = 3 === i ? l.length - 1 : l.length, h = 0; h < u; h++) {\n          1 === h && 1 !== i && t.writeVarint(T(2, u - 1));\n          var p = l[h].x - r,\n              f = l[h].y - n;\n          t.writeVarint(C(p)), t.writeVarint(C(f)), r += p, n += f;\n        }\n\n        3 === i && t.writeVarint(T(7, 1));\n      }\n    }\n\n    function L(e, t) {\n      var o = typeof e;\n      \"string\" === o ? t.writeStringField(1, e) : \"boolean\" === o ? t.writeBooleanField(7, e) : \"number\" === o && (e % 1 != 0 ? t.writeDoubleField(3, e) : e < 0 ? t.writeSVarintField(6, e) : t.writeVarintField(5, e));\n    }\n\n    m.exports = b, m.exports.fromVectorTileJs = b, m.exports.fromGeojsonVt = function (e, t) {\n      t = t || {};\n      var o = {};\n\n      for (var i in e) o[i] = new M(e[i].features, t), o[i].name = i, o[i].version = t.version, o[i].extent = t.extent;\n\n      return b({\n        layers: o\n      });\n    }, m.exports.GeoJSONWrapper = M;\n    var z = m.exports;\n\n    function O(e, t, o, i, r, n) {\n      if (r - i <= o) return;\n      const s = i + r >> 1;\n      E(e, t, s, i, r, n % 2), O(e, t, o, i, s - 1, n + 1), O(e, t, o, s + 1, r, n + 1);\n    }\n\n    function E(e, t, o, i, r, n) {\n      for (; r > i;) {\n        if (r - i > 600) {\n          const s = r - i + 1,\n                a = o - i + 1,\n                l = Math.log(s),\n                c = .5 * Math.exp(2 * l / 3),\n                u = .5 * Math.sqrt(l * c * (s - c) / s) * (a - s / 2 < 0 ? -1 : 1);\n          E(e, t, o, Math.max(i, Math.floor(o - a * c / s + u)), Math.min(r, Math.floor(o + (s - a) * c / s + u)), n);\n        }\n\n        const s = t[2 * o + n];\n        let a = i,\n            l = r;\n\n        for (F(e, t, i, o), t[2 * r + n] > s && F(e, t, i, r); a < l;) {\n          for (F(e, t, a, l), a++, l--; t[2 * a + n] < s;) a++;\n\n          for (; t[2 * l + n] > s;) l--;\n        }\n\n        t[2 * i + n] === s ? F(e, t, i, l) : (l++, F(e, t, l, r)), l <= o && (i = l + 1), o <= l && (r = l - 1);\n      }\n    }\n\n    function F(e, t, o, i) {\n      N(e, o, i), N(t, 2 * o, 2 * i), N(t, 2 * o + 1, 2 * i + 1);\n    }\n\n    function N(e, t, o) {\n      const i = e[t];\n      e[t] = e[o], e[o] = i;\n    }\n\n    function A(e, t, o, i) {\n      const r = e - o,\n            n = t - i;\n      return r * r + n * n;\n    }\n\n    const G = e => e[0],\n          J = e => e[1];\n\n    class Z {\n      constructor(e) {\n        let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : G;\n        let o = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : J;\n        let i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 64;\n        let r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : Float64Array;\n        this.nodeSize = i, this.points = e;\n        const n = e.length < 65536 ? Uint16Array : Uint32Array,\n              s = this.ids = new n(e.length),\n              a = this.coords = new r(2 * e.length);\n\n        for (let i = 0; i < e.length; i++) s[i] = i, a[2 * i] = t(e[i]), a[2 * i + 1] = o(e[i]);\n\n        O(s, a, i, 0, s.length - 1, 0);\n      }\n\n      range(e, t, o, i) {\n        return function (e, t, o, i, r, n, s) {\n          const a = [0, e.length - 1, 0],\n                l = [];\n          let c, u;\n\n          for (; a.length;) {\n            const h = a.pop(),\n                  p = a.pop(),\n                  f = a.pop();\n\n            if (p - f <= s) {\n              for (let s = f; s <= p; s++) c = t[2 * s], u = t[2 * s + 1], c >= o && c <= r && u >= i && u <= n && l.push(e[s]);\n\n              continue;\n            }\n\n            const d = Math.floor((f + p) / 2);\n            c = t[2 * d], u = t[2 * d + 1], c >= o && c <= r && u >= i && u <= n && l.push(e[d]);\n            const g = (h + 1) % 2;\n            (0 === h ? o <= c : i <= u) && (a.push(f), a.push(d - 1), a.push(g)), (0 === h ? r >= c : n >= u) && (a.push(d + 1), a.push(p), a.push(g));\n          }\n\n          return l;\n        }(this.ids, this.coords, e, t, o, i, this.nodeSize);\n      }\n\n      within(e, t, o) {\n        return function (e, t, o, i, r, n) {\n          const s = [0, e.length - 1, 0],\n                a = [],\n                l = r * r;\n\n          for (; s.length;) {\n            const c = s.pop(),\n                  u = s.pop(),\n                  h = s.pop();\n\n            if (u - h <= n) {\n              for (let r = h; r <= u; r++) A(t[2 * r], t[2 * r + 1], o, i) <= l && a.push(e[r]);\n\n              continue;\n            }\n\n            const p = Math.floor((h + u) / 2),\n                  f = t[2 * p],\n                  d = t[2 * p + 1];\n            A(f, d, o, i) <= l && a.push(e[p]);\n            const g = (c + 1) % 2;\n            (0 === c ? o - r <= f : i - r <= d) && (s.push(h), s.push(p - 1), s.push(g)), (0 === c ? o + r >= f : i + r >= d) && (s.push(p + 1), s.push(u), s.push(g));\n          }\n\n          return a;\n        }(this.ids, this.coords, e, t, o, this.nodeSize);\n      }\n\n    }\n\n    const B = {\n      minZoom: 0,\n      maxZoom: 16,\n      minPoints: 2,\n      radius: 40,\n      extent: 512,\n      nodeSize: 64,\n      log: !1,\n      generateId: !1,\n      reduce: null,\n      map: e => e\n    },\n          j = Math.fround || (Y = new Float32Array(1), e => (Y[0] = +e, Y[0]));\n    var Y;\n\n    class V {\n      constructor(e) {\n        this.options = K(Object.create(B), e), this.trees = new Array(this.options.maxZoom + 1);\n      }\n\n      load(e) {\n        const {\n          log: t,\n          minZoom: o,\n          maxZoom: i,\n          nodeSize: r\n        } = this.options;\n        t && console.time(\"total time\");\n        const n = `prepare ${e.length} points`;\n        t && console.time(n), this.points = e;\n        let s = [];\n\n        for (let t = 0; t < e.length; t++) e[t].geometry && s.push(W(e[t], t));\n\n        this.trees[i + 1] = new Z(s, Q, ee, r, Float32Array), t && console.timeEnd(n);\n\n        for (let e = i; e >= o; e--) {\n          const o = +Date.now();\n          s = this._cluster(s, e), this.trees[e] = new Z(s, Q, ee, r, Float32Array), t && console.log(\"z%d: %d clusters in %dms\", e, s.length, +Date.now() - o);\n        }\n\n        return t && console.timeEnd(\"total time\"), this;\n      }\n\n      getClusters(e, t) {\n        let o = ((e[0] + 180) % 360 + 360) % 360 - 180;\n        const i = Math.max(-90, Math.min(90, e[1]));\n        let r = 180 === e[2] ? 180 : ((e[2] + 180) % 360 + 360) % 360 - 180;\n        const n = Math.max(-90, Math.min(90, e[3]));\n        if (e[2] - e[0] >= 360) o = -180, r = 180;else if (o > r) {\n          const e = this.getClusters([o, i, 180, n], t),\n                s = this.getClusters([-180, i, r, n], t);\n          return e.concat(s);\n        }\n\n        const s = this.trees[this._limitZoom(t)],\n              a = s.range(q(o), U(n), q(r), U(i)),\n              l = [];\n\n        for (const e of a) {\n          const t = s.points[e];\n          l.push(t.numPoints ? R(t) : this.points[t.index]);\n        }\n\n        return l;\n      }\n\n      getChildren(e) {\n        const t = this._getOriginId(e),\n              o = this._getOriginZoom(e),\n              i = \"No cluster with the specified id.\",\n              r = this.trees[o];\n\n        if (!r) throw new Error(i);\n        const n = r.points[t];\n        if (!n) throw new Error(i);\n        const s = this.options.radius / (this.options.extent * Math.pow(2, o - 1)),\n              a = r.within(n.x, n.y, s),\n              l = [];\n\n        for (const t of a) {\n          const o = r.points[t];\n          o.parentId === e && l.push(o.numPoints ? R(o) : this.points[o.index]);\n        }\n\n        if (0 === l.length) throw new Error(i);\n        return l;\n      }\n\n      getLeaves(e, t, o) {\n        const i = [];\n        return this._appendLeaves(i, e, t = t || 10, o = o || 0, 0), i;\n      }\n\n      getTile(e, t, o) {\n        const i = this.trees[this._limitZoom(e)],\n              r = Math.pow(2, e),\n              {\n          extent: n,\n          radius: s\n        } = this.options,\n              a = s / n,\n              l = (o - a) / r,\n              c = (o + 1 + a) / r,\n              u = {\n          features: []\n        };\n\n        return this._addTileFeatures(i.range((t - a) / r, l, (t + 1 + a) / r, c), i.points, t, o, r, u), 0 === t && this._addTileFeatures(i.range(1 - a / r, l, 1, c), i.points, r, o, r, u), t === r - 1 && this._addTileFeatures(i.range(0, l, a / r, c), i.points, -1, o, r, u), u.features.length ? u : null;\n      }\n\n      getClusterExpansionZoom(e) {\n        let t = this._getOriginZoom(e) - 1;\n\n        for (; t <= this.options.maxZoom;) {\n          const o = this.getChildren(e);\n          if (t++, 1 !== o.length) break;\n          e = o[0].properties.cluster_id;\n        }\n\n        return t;\n      }\n\n      _appendLeaves(e, t, o, i, r) {\n        const n = this.getChildren(t);\n\n        for (const t of n) {\n          const n = t.properties;\n          if (n && n.cluster ? r + n.point_count <= i ? r += n.point_count : r = this._appendLeaves(e, n.cluster_id, o, i, r) : r < i ? r++ : e.push(t), e.length === o) break;\n        }\n\n        return r;\n      }\n\n      _addTileFeatures(e, t, o, i, r, n) {\n        for (const s of e) {\n          const e = t[s],\n                a = e.numPoints;\n          let l, c, u;\n          if (a) l = $(e), c = e.x, u = e.y;else {\n            const t = this.points[e.index];\n            l = t.properties, c = q(t.geometry.coordinates[0]), u = U(t.geometry.coordinates[1]);\n          }\n          const h = {\n            type: 1,\n            geometry: [[Math.round(this.options.extent * (c * r - o)), Math.round(this.options.extent * (u * r - i))]],\n            tags: l\n          };\n          let p;\n          a ? p = e.id : this.options.generateId ? p = e.index : this.points[e.index].id && (p = this.points[e.index].id), void 0 !== p && (h.id = p), n.features.push(h);\n        }\n      }\n\n      _limitZoom(e) {\n        return Math.max(this.options.minZoom, Math.min(+e, this.options.maxZoom + 1));\n      }\n\n      _cluster(e, t) {\n        const o = [],\n              {\n          radius: i,\n          extent: r,\n          reduce: n,\n          minPoints: s\n        } = this.options,\n              a = i / (r * Math.pow(2, t));\n\n        for (let i = 0; i < e.length; i++) {\n          const r = e[i];\n          if (r.zoom <= t) continue;\n          r.zoom = t;\n          const l = this.trees[t + 1],\n                c = l.within(r.x, r.y, a),\n                u = r.numPoints || 1;\n          let h = u;\n\n          for (const e of c) {\n            const o = l.points[e];\n            o.zoom > t && (h += o.numPoints || 1);\n          }\n\n          if (h > u && h >= s) {\n            let e = r.x * u,\n                s = r.y * u,\n                a = n && u > 1 ? this._map(r, !0) : null;\n            const p = (i << 5) + (t + 1) + this.points.length;\n\n            for (const o of c) {\n              const i = l.points[o];\n              if (i.zoom <= t) continue;\n              i.zoom = t;\n              const c = i.numPoints || 1;\n              e += i.x * c, s += i.y * c, i.parentId = p, n && (a || (a = this._map(r, !0)), n(a, this._map(i)));\n            }\n\n            r.parentId = p, o.push(X(e / h, s / h, p, h, a));\n          } else if (o.push(r), h > 1) for (const e of c) {\n            const i = l.points[e];\n            i.zoom <= t || (i.zoom = t, o.push(i));\n          }\n        }\n\n        return o;\n      }\n\n      _getOriginId(e) {\n        return e - this.points.length >> 5;\n      }\n\n      _getOriginZoom(e) {\n        return (e - this.points.length) % 32;\n      }\n\n      _map(e, t) {\n        if (e.numPoints) return t ? K({}, e.properties) : e.properties;\n        const o = this.points[e.index].properties,\n              i = this.options.map(o);\n        return t && i === o ? K({}, i) : i;\n      }\n\n    }\n\n    function X(e, t, o, i, r) {\n      return {\n        x: j(e),\n        y: j(t),\n        zoom: 1 / 0,\n        id: o,\n        parentId: -1,\n        numPoints: i,\n        properties: r\n      };\n    }\n\n    function W(e, t) {\n      const [o, i] = e.geometry.coordinates;\n      return {\n        x: j(q(o)),\n        y: j(U(i)),\n        zoom: 1 / 0,\n        index: t,\n        parentId: -1\n      };\n    }\n\n    function R(e) {\n      return {\n        type: \"Feature\",\n        id: e.id,\n        properties: $(e),\n        geometry: {\n          type: \"Point\",\n          coordinates: [(t = e.x, 360 * (t - .5)), H(e.y)]\n        }\n      };\n      var t;\n    }\n\n    function $(e) {\n      const t = e.numPoints,\n            o = t >= 1e4 ? `${Math.round(t / 1e3)}k` : t >= 1e3 ? Math.round(t / 100) / 10 + \"k\" : t;\n      return K(K({}, e.properties), {\n        cluster: !0,\n        cluster_id: e.id,\n        point_count: t,\n        point_count_abbreviated: o\n      });\n    }\n\n    function q(e) {\n      return e / 360 + .5;\n    }\n\n    function U(e) {\n      const t = Math.sin(e * Math.PI / 180),\n            o = .5 - .25 * Math.log((1 + t) / (1 - t)) / Math.PI;\n      return o < 0 ? 0 : o > 1 ? 1 : o;\n    }\n\n    function H(e) {\n      const t = (180 - 360 * e) * Math.PI / 180;\n      return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;\n    }\n\n    function K(e, t) {\n      for (const o in t) e[o] = t[o];\n\n      return e;\n    }\n\n    function Q(e) {\n      return e.x;\n    }\n\n    function ee(e) {\n      return e.y;\n    }\n\n    function te(e, t, o, i) {\n      for (var r, n = i, s = o - t >> 1, a = o - t, l = e[t], c = e[t + 1], u = e[o], h = e[o + 1], p = t + 3; p < o; p += 3) {\n        var f = oe(e[p], e[p + 1], l, c, u, h);\n        if (f > n) r = p, n = f;else if (f === n) {\n          var d = Math.abs(p - s);\n          d < a && (r = p, a = d);\n        }\n      }\n\n      n > i && (r - t > 3 && te(e, t, r, i), e[r + 2] = n, o - r > 3 && te(e, r, o, i));\n    }\n\n    function oe(e, t, o, i, r, n) {\n      var s = r - o,\n          a = n - i;\n\n      if (0 !== s || 0 !== a) {\n        var l = ((e - o) * s + (t - i) * a) / (s * s + a * a);\n        l > 1 ? (o = r, i = n) : l > 0 && (o += s * l, i += a * l);\n      }\n\n      return (s = e - o) * s + (a = t - i) * a;\n    }\n\n    function ie(e, t, o, i) {\n      var r = {\n        id: void 0 === e ? null : e,\n        type: t,\n        geometry: o,\n        tags: i,\n        minX: 1 / 0,\n        minY: 1 / 0,\n        maxX: -1 / 0,\n        maxY: -1 / 0\n      };\n      return function (e) {\n        var t = e.geometry,\n            o = e.type;\n        if (\"Point\" === o || \"MultiPoint\" === o || \"LineString\" === o) re(e, t);else if (\"Polygon\" === o || \"MultiLineString\" === o) for (var i = 0; i < t.length; i++) re(e, t[i]);else if (\"MultiPolygon\" === o) for (i = 0; i < t.length; i++) for (var r = 0; r < t[i].length; r++) re(e, t[i][r]);\n      }(r), r;\n    }\n\n    function re(e, t) {\n      for (var o = 0; o < t.length; o += 3) e.minX = Math.min(e.minX, t[o]), e.minY = Math.min(e.minY, t[o + 1]), e.maxX = Math.max(e.maxX, t[o]), e.maxY = Math.max(e.maxY, t[o + 1]);\n    }\n\n    function ne(e, t, o, i) {\n      if (t.geometry) {\n        var r = t.geometry.coordinates,\n            n = t.geometry.type,\n            s = Math.pow(o.tolerance / ((1 << o.maxZoom) * o.extent), 2),\n            a = [],\n            l = t.id;\n        if (o.promoteId ? l = t.properties[o.promoteId] : o.generateId && (l = i || 0), \"Point\" === n) se(r, a);else if (\"MultiPoint\" === n) for (var c = 0; c < r.length; c++) se(r[c], a);else if (\"LineString\" === n) ae(r, a, s, !1);else if (\"MultiLineString\" === n) {\n          if (o.lineMetrics) {\n            for (c = 0; c < r.length; c++) ae(r[c], a = [], s, !1), e.push(ie(l, \"LineString\", a, t.properties));\n\n            return;\n          }\n\n          le(r, a, s, !1);\n        } else if (\"Polygon\" === n) le(r, a, s, !0);else {\n          if (\"MultiPolygon\" !== n) {\n            if (\"GeometryCollection\" === n) {\n              for (c = 0; c < t.geometry.geometries.length; c++) ne(e, {\n                id: l,\n                geometry: t.geometry.geometries[c],\n                properties: t.properties\n              }, o, i);\n\n              return;\n            }\n\n            throw new Error(\"Input data is not a valid GeoJSON object.\");\n          }\n\n          for (c = 0; c < r.length; c++) {\n            var u = [];\n            le(r[c], u, s, !0), a.push(u);\n          }\n        }\n        e.push(ie(l, n, a, t.properties));\n      }\n    }\n\n    function se(e, t) {\n      t.push(ce(e[0])), t.push(ue(e[1])), t.push(0);\n    }\n\n    function ae(e, t, o, i) {\n      for (var r, n, s = 0, a = 0; a < e.length; a++) {\n        var l = ce(e[a][0]),\n            c = ue(e[a][1]);\n        t.push(l), t.push(c), t.push(0), a > 0 && (s += i ? (r * c - l * n) / 2 : Math.sqrt(Math.pow(l - r, 2) + Math.pow(c - n, 2))), r = l, n = c;\n      }\n\n      var u = t.length - 3;\n      t[2] = 1, te(t, 0, u, o), t[u + 2] = 1, t.size = Math.abs(s), t.start = 0, t.end = t.size;\n    }\n\n    function le(e, t, o, i) {\n      for (var r = 0; r < e.length; r++) {\n        var n = [];\n        ae(e[r], n, o, i), t.push(n);\n      }\n    }\n\n    function ce(e) {\n      return e / 360 + .5;\n    }\n\n    function ue(e) {\n      var t = Math.sin(e * Math.PI / 180),\n          o = .5 - .25 * Math.log((1 + t) / (1 - t)) / Math.PI;\n      return o < 0 ? 0 : o > 1 ? 1 : o;\n    }\n\n    function he(e, t, o, i, r, n, s, a) {\n      if (i /= t, n >= (o /= t) && s < i) return e;\n      if (s < o || n >= i) return null;\n\n      for (var l = [], c = 0; c < e.length; c++) {\n        var u = e[c],\n            h = u.geometry,\n            p = u.type,\n            f = 0 === r ? u.minX : u.minY,\n            d = 0 === r ? u.maxX : u.maxY;\n        if (f >= o && d < i) l.push(u);else if (!(d < o || f >= i)) {\n          var g = [];\n          if (\"Point\" === p || \"MultiPoint\" === p) pe(h, g, o, i, r);else if (\"LineString\" === p) fe(h, g, o, i, r, !1, a.lineMetrics);else if (\"MultiLineString\" === p) ge(h, g, o, i, r, !1);else if (\"Polygon\" === p) ge(h, g, o, i, r, !0);else if (\"MultiPolygon\" === p) for (var m = 0; m < h.length; m++) {\n            var y = [];\n            ge(h[m], y, o, i, r, !0), y.length && g.push(y);\n          }\n\n          if (g.length) {\n            if (a.lineMetrics && \"LineString\" === p) {\n              for (m = 0; m < g.length; m++) l.push(ie(u.id, p, g[m], u.tags));\n\n              continue;\n            }\n\n            \"LineString\" !== p && \"MultiLineString\" !== p || (1 === g.length ? (p = \"LineString\", g = g[0]) : p = \"MultiLineString\"), \"Point\" !== p && \"MultiPoint\" !== p || (p = 3 === g.length ? \"Point\" : \"MultiPoint\"), l.push(ie(u.id, p, g, u.tags));\n          }\n        }\n      }\n\n      return l.length ? l : null;\n    }\n\n    function pe(e, t, o, i, r) {\n      for (var n = 0; n < e.length; n += 3) {\n        var s = e[n + r];\n        s >= o && s <= i && (t.push(e[n]), t.push(e[n + 1]), t.push(e[n + 2]));\n      }\n    }\n\n    function fe(e, t, o, i, r, n, s) {\n      for (var a, l, c = de(e), u = 0 === r ? ye : ve, h = e.start, p = 0; p < e.length - 3; p += 3) {\n        var f = e[p],\n            d = e[p + 1],\n            g = e[p + 2],\n            m = e[p + 3],\n            y = e[p + 4],\n            v = 0 === r ? f : d,\n            x = 0 === r ? m : y,\n            w = !1;\n        s && (a = Math.sqrt(Math.pow(f - m, 2) + Math.pow(d - y, 2))), v < o ? x > o && (l = u(c, f, d, m, y, o), s && (c.start = h + a * l)) : v > i ? x < i && (l = u(c, f, d, m, y, i), s && (c.start = h + a * l)) : me(c, f, d, g), x < o && v >= o && (l = u(c, f, d, m, y, o), w = !0), x > i && v <= i && (l = u(c, f, d, m, y, i), w = !0), !n && w && (s && (c.end = h + a * l), t.push(c), c = de(e)), s && (h += a);\n      }\n\n      var S = e.length - 3;\n      f = e[S], d = e[S + 1], g = e[S + 2], (v = 0 === r ? f : d) >= o && v <= i && me(c, f, d, g), S = c.length - 3, n && S >= 3 && (c[S] !== c[0] || c[S + 1] !== c[1]) && me(c, c[0], c[1], c[2]), c.length && t.push(c);\n    }\n\n    function de(e) {\n      var t = [];\n      return t.size = e.size, t.start = e.start, t.end = e.end, t;\n    }\n\n    function ge(e, t, o, i, r, n) {\n      for (var s = 0; s < e.length; s++) fe(e[s], t, o, i, r, n, !1);\n    }\n\n    function me(e, t, o, i) {\n      e.push(t), e.push(o), e.push(i);\n    }\n\n    function ye(e, t, o, i, r, n) {\n      var s = (n - t) / (i - t);\n      return e.push(n), e.push(o + (r - o) * s), e.push(1), s;\n    }\n\n    function ve(e, t, o, i, r, n) {\n      var s = (n - o) / (r - o);\n      return e.push(t + (i - t) * s), e.push(n), e.push(1), s;\n    }\n\n    function xe(e, t) {\n      for (var o = [], i = 0; i < e.length; i++) {\n        var r,\n            n = e[i],\n            s = n.type;\n        if (\"Point\" === s || \"MultiPoint\" === s || \"LineString\" === s) r = we(n.geometry, t);else if (\"MultiLineString\" === s || \"Polygon\" === s) {\n          r = [];\n\n          for (var a = 0; a < n.geometry.length; a++) r.push(we(n.geometry[a], t));\n        } else if (\"MultiPolygon\" === s) for (r = [], a = 0; a < n.geometry.length; a++) {\n          for (var l = [], c = 0; c < n.geometry[a].length; c++) l.push(we(n.geometry[a][c], t));\n\n          r.push(l);\n        }\n        o.push(ie(n.id, s, r, n.tags));\n      }\n\n      return o;\n    }\n\n    function we(e, t) {\n      var o = [];\n      o.size = e.size, void 0 !== e.start && (o.start = e.start, o.end = e.end);\n\n      for (var i = 0; i < e.length; i += 3) o.push(e[i] + t, e[i + 1], e[i + 2]);\n\n      return o;\n    }\n\n    function Se(e, t) {\n      if (e.transformed) return e;\n      var o,\n          i,\n          r,\n          n = 1 << e.z,\n          s = e.x,\n          a = e.y;\n\n      for (o = 0; o < e.features.length; o++) {\n        var l = e.features[o],\n            c = l.geometry,\n            u = l.type;\n        if (l.geometry = [], 1 === u) for (i = 0; i < c.length; i += 2) l.geometry.push(Ie(c[i], c[i + 1], t, n, s, a));else for (i = 0; i < c.length; i++) {\n          var h = [];\n\n          for (r = 0; r < c[i].length; r += 2) h.push(Ie(c[i][r], c[i][r + 1], t, n, s, a));\n\n          l.geometry.push(h);\n        }\n      }\n\n      return e.transformed = !0, e;\n    }\n\n    function Ie(e, t, o, i, r, n) {\n      return [Math.round(o * (e * i - r)), Math.round(o * (t * i - n))];\n    }\n\n    function Me(e, t, o, i, r) {\n      for (var n = t === r.maxZoom ? 0 : r.tolerance / ((1 << t) * r.extent), s = {\n        features: [],\n        numPoints: 0,\n        numSimplified: 0,\n        numFeatures: 0,\n        source: null,\n        x: o,\n        y: i,\n        z: t,\n        transformed: !1,\n        minX: 2,\n        minY: 1,\n        maxX: -1,\n        maxY: 0\n      }, a = 0; a < e.length; a++) {\n        s.numFeatures++, be(s, e[a], n, r);\n        var l = e[a].minX,\n            c = e[a].minY,\n            u = e[a].maxX,\n            h = e[a].maxY;\n        l < s.minX && (s.minX = l), c < s.minY && (s.minY = c), u > s.maxX && (s.maxX = u), h > s.maxY && (s.maxY = h);\n      }\n\n      return s;\n    }\n\n    function be(e, t, o, i) {\n      var r = t.geometry,\n          n = t.type,\n          s = [];\n      if (\"Point\" === n || \"MultiPoint\" === n) for (var a = 0; a < r.length; a += 3) s.push(r[a]), s.push(r[a + 1]), e.numPoints++, e.numSimplified++;else if (\"LineString\" === n) ke(s, r, e, o, !1, !1);else if (\"MultiLineString\" === n || \"Polygon\" === n) for (a = 0; a < r.length; a++) ke(s, r[a], e, o, \"Polygon\" === n, 0 === a);else if (\"MultiPolygon\" === n) for (var l = 0; l < r.length; l++) {\n        var c = r[l];\n\n        for (a = 0; a < c.length; a++) ke(s, c[a], e, o, !0, 0 === a);\n      }\n\n      if (s.length) {\n        var u = t.tags || null;\n\n        if (\"LineString\" === n && i.lineMetrics) {\n          for (var h in u = {}, t.tags) u[h] = t.tags[h];\n\n          u.mapbox_clip_start = r.start / r.size, u.mapbox_clip_end = r.end / r.size;\n        }\n\n        var p = {\n          geometry: s,\n          type: \"Polygon\" === n || \"MultiPolygon\" === n ? 3 : \"LineString\" === n || \"MultiLineString\" === n ? 2 : 1,\n          tags: u\n        };\n        null !== t.id && (p.id = t.id), e.features.push(p);\n      }\n    }\n\n    function ke(e, t, o, i, r, n) {\n      var s = i * i;\n      if (i > 0 && t.size < (r ? s : i)) o.numPoints += t.length / 3;else {\n        for (var a = [], l = 0; l < t.length; l += 3) (0 === i || t[l + 2] > s) && (o.numSimplified++, a.push(t[l]), a.push(t[l + 1])), o.numPoints++;\n\n        r && function (e, t) {\n          for (var o = 0, i = 0, r = e.length, n = r - 2; i < r; n = i, i += 2) o += (e[i] - e[n]) * (e[i + 1] + e[n + 1]);\n\n          if (o > 0 === t) for (i = 0, r = e.length; i < r / 2; i += 2) {\n            var s = e[i],\n                a = e[i + 1];\n            e[i] = e[r - 2 - i], e[i + 1] = e[r - 1 - i], e[r - 2 - i] = s, e[r - 1 - i] = a;\n          }\n        }(a, n), e.push(a);\n      }\n    }\n\n    function _e(e, t) {\n      var o = (t = this.options = function (e, t) {\n        for (var o in t) e[o] = t[o];\n\n        return e;\n      }(Object.create(this.options), t)).debug;\n\n      if (o && console.time(\"preprocess data\"), t.maxZoom < 0 || t.maxZoom > 24) throw new Error(\"maxZoom should be in the 0-24 range\");\n      if (t.promoteId && t.generateId) throw new Error(\"promoteId and generateId cannot be used together.\");\n\n      var i = function (e, t) {\n        var o = [];\n        if (\"FeatureCollection\" === e.type) for (var i = 0; i < e.features.length; i++) ne(o, e.features[i], t, i);else ne(o, \"Feature\" === e.type ? e : {\n          geometry: e\n        }, t);\n        return o;\n      }(e, t);\n\n      this.tiles = {}, this.tileCoords = [], o && (console.timeEnd(\"preprocess data\"), console.log(\"index: maxZoom: %d, maxPoints: %d\", t.indexMaxZoom, t.indexMaxPoints), console.time(\"generate tiles\"), this.stats = {}, this.total = 0), i = function (e, t) {\n        var o = t.buffer / t.extent,\n            i = e,\n            r = he(e, 1, -1 - o, o, 0, -1, 2, t),\n            n = he(e, 1, 1 - o, 2 + o, 0, -1, 2, t);\n        return (r || n) && (i = he(e, 1, -o, 1 + o, 0, -1, 2, t) || [], r && (i = xe(r, 1).concat(i)), n && (i = i.concat(xe(n, -1)))), i;\n      }(i, t), i.length && this.splitTile(i, 0, 0, 0), o && (i.length && console.log(\"features: %d, points: %d\", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd(\"generate tiles\"), console.log(\"tiles generated:\", this.total, JSON.stringify(this.stats)));\n    }\n\n    function Pe(e, t, o) {\n      return 32 * ((1 << e) * o + t) + e;\n    }\n\n    function Te(e, t) {\n      const o = e.tileID.canonical;\n      if (!this._geoJSONIndex) return t(null, null);\n\n      const i = this._geoJSONIndex.getTile(o.z, o.x, o.y);\n\n      if (!i) return t(null, null);\n      const r = new g(i.features);\n      let n = z(r);\n      0 === n.byteOffset && n.byteLength === n.buffer.byteLength || (n = new Uint8Array(n)), t(null, {\n        vectorTile: r,\n        rawData: n.buffer\n      });\n    }\n\n    _e.prototype.options = {\n      maxZoom: 14,\n      indexMaxZoom: 5,\n      indexMaxPoints: 1e5,\n      tolerance: 3,\n      extent: 4096,\n      buffer: 64,\n      lineMetrics: !1,\n      promoteId: null,\n      generateId: !1,\n      debug: 0\n    }, _e.prototype.splitTile = function (e, t, o, i, r, n, s) {\n      for (var a = [e, t, o, i], l = this.options, c = l.debug; a.length;) {\n        i = a.pop(), o = a.pop(), t = a.pop(), e = a.pop();\n        var u = 1 << t,\n            h = Pe(t, o, i),\n            p = this.tiles[h];\n\n        if (!p && (c > 1 && console.time(\"creation\"), p = this.tiles[h] = Me(e, t, o, i, l), this.tileCoords.push({\n          z: t,\n          x: o,\n          y: i\n        }), c)) {\n          c > 1 && (console.log(\"tile z%d-%d-%d (features: %d, points: %d, simplified: %d)\", t, o, i, p.numFeatures, p.numPoints, p.numSimplified), console.timeEnd(\"creation\"));\n          var f = \"z\" + t;\n          this.stats[f] = (this.stats[f] || 0) + 1, this.total++;\n        }\n\n        if (p.source = e, r) {\n          if (t === l.maxZoom || t === r) continue;\n          var d = 1 << r - t;\n          if (o !== Math.floor(n / d) || i !== Math.floor(s / d)) continue;\n        } else if (t === l.indexMaxZoom || p.numPoints <= l.indexMaxPoints) continue;\n\n        if (p.source = null, 0 !== e.length) {\n          c > 1 && console.time(\"clipping\");\n          var g,\n              m,\n              y,\n              v,\n              x,\n              w,\n              S = .5 * l.buffer / l.extent,\n              I = .5 - S,\n              M = .5 + S,\n              b = 1 + S;\n          g = m = y = v = null, x = he(e, u, o - S, o + M, 0, p.minX, p.maxX, l), w = he(e, u, o + I, o + b, 0, p.minX, p.maxX, l), e = null, x && (g = he(x, u, i - S, i + M, 1, p.minY, p.maxY, l), m = he(x, u, i + I, i + b, 1, p.minY, p.maxY, l), x = null), w && (y = he(w, u, i - S, i + M, 1, p.minY, p.maxY, l), v = he(w, u, i + I, i + b, 1, p.minY, p.maxY, l), w = null), c > 1 && console.timeEnd(\"clipping\"), a.push(g || [], t + 1, 2 * o, 2 * i), a.push(m || [], t + 1, 2 * o, 2 * i + 1), a.push(y || [], t + 1, 2 * o + 1, 2 * i), a.push(v || [], t + 1, 2 * o + 1, 2 * i + 1);\n        }\n      }\n    }, _e.prototype.getTile = function (e, t, o) {\n      var i = this.options,\n          r = i.extent,\n          n = i.debug;\n      if (e < 0 || e > 24) return null;\n      var s = 1 << e,\n          a = Pe(e, t = (t % s + s) % s, o);\n      if (this.tiles[a]) return Se(this.tiles[a], r);\n      n > 1 && console.log(\"drilling down to z%d-%d-%d\", e, t, o);\n\n      for (var l, c = e, u = t, h = o; !l && c > 0;) c--, u = Math.floor(u / 2), h = Math.floor(h / 2), l = this.tiles[Pe(c, u, h)];\n\n      return l && l.source ? (n > 1 && console.log(\"found parent tile z%d-%d-%d\", c, u, h), n > 1 && console.time(\"drilling down\"), this.splitTile(l.source, c, u, h, e, t, o), n > 1 && console.timeEnd(\"drilling down\"), this.tiles[a] ? Se(this.tiles[a], r) : null) : null;\n    };\n\n    class Ce extends l {\n      constructor(e, t, o, i) {\n        super(e, t, o, Te), i && (this.loadGeoJSON = i);\n      }\n\n      loadData(e, t) {\n        this._pendingCallback && this._pendingCallback(null, {\n          abandoned: !0\n        }), this._pendingCallback = t, this._pendingLoadDataParams = e, this._state && \"Idle\" !== this._state ? this._state = \"NeedsLoadData\" : (this._state = \"Coalescing\", this._loadData());\n      }\n\n      _loadData() {\n        if (!this._pendingCallback || !this._pendingLoadDataParams) return;\n        const t = this._pendingCallback,\n              o = this._pendingLoadDataParams;\n        delete this._pendingCallback, delete this._pendingLoadDataParams;\n        const i = !!(o && o.request && o.request.collectResourceTiming) && new e.RequestPerformance(o.request);\n        this.loadGeoJSON(o, (r, n) => {\n          if (r || !n) return t(r);\n          if (\"object\" != typeof n) return t(new Error(`Input data given to '${o.source}' is not a valid GeoJSON object.`));\n          {\n            u(n, !0);\n\n            try {\n              if (o.filter) {\n                const t = e.createExpression(o.filter, {\n                  type: \"boolean\",\n                  \"property-type\": \"data-driven\",\n                  overridable: !1,\n                  transition: !1\n                });\n                if (\"error\" === t.result) throw new Error(t.value.map(e => `${e.key}: ${e.message}`).join(\", \"));\n                const i = n.features.filter(e => t.value.evaluate({\n                  zoom: 0\n                }, e));\n                n = {\n                  type: \"FeatureCollection\",\n                  features: i\n                };\n              }\n\n              this._geoJSONIndex = o.cluster ? new V(function (_ref65) {\n                let {\n                  superclusterOptions: t,\n                  clusterProperties: o\n                } = _ref65;\n                if (!o || !t) return t;\n                const i = {},\n                      r = {},\n                      n = {\n                  accumulated: null,\n                  zoom: 0\n                },\n                      s = {\n                  properties: null\n                },\n                      a = Object.keys(o);\n\n                for (const t of a) {\n                  const [n, s] = o[t],\n                        a = e.createExpression(s),\n                        l = e.createExpression(\"string\" == typeof n ? [n, [\"accumulated\"], [\"get\", t]] : n);\n                  i[t] = a.value, r[t] = l.value;\n                }\n\n                return t.map = e => {\n                  s.properties = e;\n                  const t = {};\n\n                  for (const e of a) t[e] = i[e].evaluate(n, s);\n\n                  return t;\n                }, t.reduce = (e, t) => {\n                  s.properties = t;\n\n                  for (const t of a) n.accumulated = e[t], e[t] = r[t].evaluate(n, s);\n                }, t;\n              }(o)).load(n.features) : function (e, t) {\n                return new _e(e, t);\n              }(n, o.geojsonVtOptions);\n            } catch (r) {\n              return t(r);\n            }\n\n            this.loaded = {};\n            const s = {};\n\n            if (i) {\n              const e = i.finish();\n              e && (s.resourceTiming = {}, s.resourceTiming[o.source] = JSON.parse(JSON.stringify(e)));\n            }\n\n            t(null, s);\n          }\n        });\n      }\n\n      coalesce() {\n        \"Coalescing\" === this._state ? this._state = \"Idle\" : \"NeedsLoadData\" === this._state && (this._state = \"Coalescing\", this._loadData());\n      }\n\n      reloadTile(e, t) {\n        const o = this.loaded;\n        return o && o[e.uid] ? super.reloadTile(e, t) : this.loadTile(e, t);\n      }\n\n      loadGeoJSON(t, o) {\n        if (t.request) e.getJSON(t.request, o);else {\n          if (\"string\" != typeof t.data) return o(new Error(`Input data given to '${t.source}' is not a valid GeoJSON object.`));\n\n          try {\n            return o(null, JSON.parse(t.data));\n          } catch (e) {\n            return o(new Error(`Input data given to '${t.source}' is not a valid GeoJSON object.`));\n          }\n        }\n      }\n\n      removeSource(e, t) {\n        this._pendingCallback && this._pendingCallback(null, {\n          abandoned: !0\n        }), t();\n      }\n\n      getClusterExpansionZoom(e, t) {\n        try {\n          t(null, this._geoJSONIndex.getClusterExpansionZoom(e.clusterId));\n        } catch (e) {\n          t(e);\n        }\n      }\n\n      getClusterChildren(e, t) {\n        try {\n          t(null, this._geoJSONIndex.getChildren(e.clusterId));\n        } catch (e) {\n          t(e);\n        }\n      }\n\n      getClusterLeaves(e, t) {\n        try {\n          t(null, this._geoJSONIndex.getLeaves(e.clusterId, e.limit, e.offset));\n        } catch (e) {\n          t(e);\n        }\n      }\n\n    }\n\n    class De {\n      constructor(t) {\n        this.self = t, this.actor = new e.Actor(t, this), this.layerIndexes = {}, this.availableImages = {}, this.workerSourceTypes = {\n          vector: l,\n          geojson: Ce\n        }, this.workerSources = {}, this.demWorkerSources = {}, this.self.registerWorkerSource = (e, t) => {\n          if (this.workerSourceTypes[e]) throw new Error(`Worker source with name \"${e}\" already registered.`);\n          this.workerSourceTypes[e] = t;\n        }, this.self.registerRTLTextPlugin = t => {\n          if (e.plugin.isParsed()) throw new Error(\"RTL text plugin already registered.\");\n          e.plugin.applyArabicShaping = t.applyArabicShaping, e.plugin.processBidirectionalText = t.processBidirectionalText, e.plugin.processStyledBidirectionalText = t.processStyledBidirectionalText;\n        };\n      }\n\n      setReferrer(e, t) {\n        this.referrer = t;\n      }\n\n      setImages(e, t, o) {\n        this.availableImages[e] = t;\n\n        for (const o in this.workerSources[e]) {\n          const i = this.workerSources[e][o];\n\n          for (const e in i) i[e].availableImages = t;\n        }\n\n        o();\n      }\n\n      setLayers(e, t, o) {\n        this.getLayerIndex(e).replace(t), o();\n      }\n\n      updateLayers(e, t, o) {\n        this.getLayerIndex(e).update(t.layers, t.removedIds), o();\n      }\n\n      loadTile(e, t, o) {\n        this.getWorkerSource(e, t.type, t.source).loadTile(t, o);\n      }\n\n      loadDEMTile(e, t, o) {\n        this.getDEMWorkerSource(e, t.source).loadTile(t, o);\n      }\n\n      reloadTile(e, t, o) {\n        this.getWorkerSource(e, t.type, t.source).reloadTile(t, o);\n      }\n\n      abortTile(e, t, o) {\n        this.getWorkerSource(e, t.type, t.source).abortTile(t, o);\n      }\n\n      removeTile(e, t, o) {\n        this.getWorkerSource(e, t.type, t.source).removeTile(t, o);\n      }\n\n      removeDEMTile(e, t) {\n        this.getDEMWorkerSource(e, t.source).removeTile(t);\n      }\n\n      removeSource(e, t, o) {\n        if (!this.workerSources[e] || !this.workerSources[e][t.type] || !this.workerSources[e][t.type][t.source]) return;\n        const i = this.workerSources[e][t.type][t.source];\n        delete this.workerSources[e][t.type][t.source], void 0 !== i.removeSource ? i.removeSource(t, o) : o();\n      }\n\n      loadWorkerSource(e, t, o) {\n        try {\n          this.self.importScripts(t.url), o();\n        } catch (e) {\n          o(e.toString());\n        }\n      }\n\n      syncRTLPluginState(t, o, i) {\n        try {\n          e.plugin.setState(o);\n          const t = e.plugin.getPluginURL();\n\n          if (e.plugin.isLoaded() && !e.plugin.isParsed() && null != t) {\n            this.self.importScripts(t);\n            const o = e.plugin.isParsed();\n            i(o ? void 0 : new Error(`RTL Text Plugin failed to import scripts from ${t}`), o);\n          }\n        } catch (e) {\n          i(e.toString());\n        }\n      }\n\n      getAvailableImages(e) {\n        let t = this.availableImages[e];\n        return t || (t = []), t;\n      }\n\n      getLayerIndex(e) {\n        let t = this.layerIndexes[e];\n        return t || (t = this.layerIndexes[e] = new i()), t;\n      }\n\n      getWorkerSource(e, t, o) {\n        if (this.workerSources[e] || (this.workerSources[e] = {}), this.workerSources[e][t] || (this.workerSources[e][t] = {}), !this.workerSources[e][t][o]) {\n          const i = {\n            send: (t, o, i) => {\n              this.actor.send(t, o, i, e);\n            }\n          };\n          this.workerSources[e][t][o] = new this.workerSourceTypes[t](i, this.getLayerIndex(e), this.getAvailableImages(e));\n        }\n\n        return this.workerSources[e][t][o];\n      }\n\n      getDEMWorkerSource(e, t) {\n        return this.demWorkerSources[e] || (this.demWorkerSources[e] = {}), this.demWorkerSources[e][t] || (this.demWorkerSources[e][t] = new c()), this.demWorkerSources[e][t];\n      }\n\n      enforceCacheSizeLimit(t, o) {\n        e.enforceCacheSizeLimit(o);\n      }\n\n    }\n\n    return \"undefined\" != typeof WorkerGlobalScope && \"undefined\" != typeof self && self instanceof WorkerGlobalScope && (self.worker = new De(self)), De;\n  });\n  define([\"./shared\"], function (t) {\n    \"use strict\";\n\n    var e = i;\n\n    function i(t) {\n      return !function (t) {\n        return \"undefined\" == typeof window || \"undefined\" == typeof document ? \"not a browser\" : Array.prototype && Array.prototype.every && Array.prototype.filter && Array.prototype.forEach && Array.prototype.indexOf && Array.prototype.lastIndexOf && Array.prototype.map && Array.prototype.some && Array.prototype.reduce && Array.prototype.reduceRight && Array.isArray ? Function.prototype && Function.prototype.bind ? Object.keys && Object.create && Object.getPrototypeOf && Object.getOwnPropertyNames && Object.isSealed && Object.isFrozen && Object.isExtensible && Object.getOwnPropertyDescriptor && Object.defineProperty && Object.defineProperties && Object.seal && Object.freeze && Object.preventExtensions ? \"JSON\" in window && \"parse\" in JSON && \"stringify\" in JSON ? function () {\n          if (!(\"Worker\" in window && \"Blob\" in window && \"URL\" in window)) return !1;\n          var t,\n              e,\n              i = new Blob([\"\"], {\n            type: \"text/javascript\"\n          }),\n              o = URL.createObjectURL(i);\n\n          try {\n            e = new Worker(o), t = !0;\n          } catch (e) {\n            t = !1;\n          }\n\n          return e && e.terminate(), URL.revokeObjectURL(o), t;\n        }() ? \"Uint8ClampedArray\" in window ? ArrayBuffer.isView ? function () {\n          var t = document.createElement(\"canvas\");\n          t.width = t.height = 1;\n          var e = t.getContext(\"2d\");\n          if (!e) return !1;\n          var i = e.getImageData(0, 0, 1, 1);\n          return i && i.width === t.width;\n        }() ? (void 0 === o[e = t && t.failIfMajorPerformanceCaveat] && (o[e] = function (t) {\n          var e,\n              o = function (t) {\n            var e = document.createElement(\"canvas\"),\n                o = Object.create(i.webGLContextAttributes);\n            return o.failIfMajorPerformanceCaveat = t, e.getContext(\"webgl\", o) || e.getContext(\"experimental-webgl\", o);\n          }(t);\n\n          if (!o) return !1;\n\n          try {\n            e = o.createShader(o.VERTEX_SHADER);\n          } catch (t) {\n            return !1;\n          }\n\n          return !(!e || o.isContextLost()) && (o.shaderSource(e, \"void main() {}\"), o.compileShader(e), !0 === o.getShaderParameter(e, o.COMPILE_STATUS));\n        }(e)), o[e] ? document.documentMode ? \"insufficient ECMAScript 6 support\" : void 0 : \"insufficient WebGL support\") : \"insufficient Canvas/getImageData support\" : \"insufficient ArrayBuffer support\" : \"insufficient Uint8ClampedArray support\" : \"insufficient worker support\" : \"insufficient JSON support\" : \"insufficient Object support\" : \"insufficient Function support\" : \"insufficent Array support\";\n        var e;\n      }(t);\n    }\n\n    var o = {};\n\n    function a(t, e) {\n      if (Array.isArray(t)) {\n        if (!Array.isArray(e) || t.length !== e.length) return !1;\n\n        for (let i = 0; i < t.length; i++) if (!a(t[i], e[i])) return !1;\n\n        return !0;\n      }\n\n      if (\"object\" == typeof t && null !== t && null !== e) {\n        if (\"object\" != typeof e) return !1;\n        if (Object.keys(t).length !== Object.keys(e).length) return !1;\n\n        for (const i in t) if (!a(t[i], e[i])) return !1;\n\n        return !0;\n      }\n\n      return t === e;\n    }\n\n    i.webGLContextAttributes = {\n      antialias: !1,\n      alpha: !0,\n      stencil: !0,\n      depth: !0\n    };\n\n    class s {\n      static testProp(t) {\n        if (!s.docStyle) return t[0];\n\n        for (let e = 0; e < t.length; e++) if (t[e] in s.docStyle) return t[e];\n\n        return t[0];\n      }\n\n      static create(t, e, i) {\n        const o = window.document.createElement(t);\n        return void 0 !== e && (o.className = e), i && i.appendChild(o), o;\n      }\n\n      static createNS(t, e) {\n        return window.document.createElementNS(t, e);\n      }\n\n      static disableDrag() {\n        s.docStyle && s.selectProp && (s.userSelect = s.docStyle[s.selectProp], s.docStyle[s.selectProp] = \"none\");\n      }\n\n      static enableDrag() {\n        s.docStyle && s.selectProp && (s.docStyle[s.selectProp] = s.userSelect);\n      }\n\n      static setTransform(t, e) {\n        t.style[s.transformProp] = e;\n      }\n\n      static addEventListener(t, e, i) {\n        let o = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n        t.addEventListener(e, i, \"passive\" in o ? o : o.capture);\n      }\n\n      static removeEventListener(t, e, i) {\n        let o = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n        t.removeEventListener(e, i, \"passive\" in o ? o : o.capture);\n      }\n\n      static suppressClickInternal(t) {\n        t.preventDefault(), t.stopPropagation(), window.removeEventListener(\"click\", s.suppressClickInternal, !0);\n      }\n\n      static suppressClick() {\n        window.addEventListener(\"click\", s.suppressClickInternal, !0), window.setTimeout(() => {\n          window.removeEventListener(\"click\", s.suppressClickInternal, !0);\n        }, 0);\n      }\n\n      static mousePos(e, i) {\n        const o = e.getBoundingClientRect();\n        return new t.pointGeometry(i.clientX - o.left - e.clientLeft, i.clientY - o.top - e.clientTop);\n      }\n\n      static touchPos(e, i) {\n        const o = e.getBoundingClientRect(),\n              a = [];\n\n        for (let s = 0; s < i.length; s++) a.push(new t.pointGeometry(i[s].clientX - o.left - e.clientLeft, i[s].clientY - o.top - e.clientTop));\n\n        return a;\n      }\n\n      static mouseButton(t) {\n        return t.button;\n      }\n\n      static remove(t) {\n        t.parentNode && t.parentNode.removeChild(t);\n      }\n\n    }\n\n    s.docStyle = \"undefined\" != typeof window && window.document && window.document.documentElement.style, s.selectProp = s.testProp([\"userSelect\", \"MozUserSelect\", \"WebkitUserSelect\", \"msUserSelect\"]), s.transformProp = s.testProp([\"transform\", \"WebkitTransform\"]);\n\n    class r {\n      constructor(t) {\n        this._transformRequestFn = t;\n      }\n\n      transformRequest(t, e) {\n        return this._transformRequestFn && this._transformRequestFn(t, e) || {\n          url: t\n        };\n      }\n\n      normalizeSpriteURL(t, e, i) {\n        const o = function (t) {\n          const e = t.match(n);\n          if (!e) throw new Error(`Unable to parse URL \"${t}\"`);\n          return {\n            protocol: e[1],\n            authority: e[2],\n            path: e[3] || \"/\",\n            params: e[4] ? e[4].split(\"&\") : []\n          };\n        }(t);\n\n        return o.path += `${e}${i}`, function (t) {\n          const e = t.params.length ? `?${t.params.join(\"&\")}` : \"\";\n          return `${t.protocol}://${t.authority}${t.path}${e}`;\n        }(o);\n      }\n\n      setTransformRequest(t) {\n        this._transformRequestFn = t;\n      }\n\n    }\n\n    const n = /^(\\w+):\\/\\/([^/?]*)(\\/[^?]+)?\\??(.+)?/;\n\n    function l(e) {\n      var i = new t.ARRAY_TYPE(3);\n      return i[0] = e[0], i[1] = e[1], i[2] = e[2], i;\n    }\n\n    function c(e, i, o) {\n      var a = new t.ARRAY_TYPE(3);\n      return a[0] = e, a[1] = i, a[2] = o, a;\n    }\n\n    var h,\n        u = function (t, e, i) {\n      return t[0] = e[0] - i[0], t[1] = e[1] - i[1], t[2] = e[2] - i[2], t;\n    };\n\n    h = new t.ARRAY_TYPE(3), t.ARRAY_TYPE != Float32Array && (h[0] = 0, h[1] = 0, h[2] = 0);\n\n    var d = function (t) {\n      var e = t[0],\n          i = t[1];\n      return e * e + i * i;\n    };\n\n    !function () {\n      var e = new t.ARRAY_TYPE(2);\n      t.ARRAY_TYPE != Float32Array && (e[0] = 0, e[1] = 0);\n    }();\n\n    class m {\n      constructor(t, e, i, o) {\n        this.context = t, this.format = i, this.texture = t.gl.createTexture(), this.update(e, o);\n      }\n\n      update(e, i, o) {\n        const {\n          width: a,\n          height: s\n        } = e,\n              r = !(this.size && this.size[0] === a && this.size[1] === s || o),\n              {\n          context: n\n        } = this,\n              {\n          gl: l\n        } = n;\n        if (this.useMipmap = Boolean(i && i.useMipmap), l.bindTexture(l.TEXTURE_2D, this.texture), n.pixelStoreUnpackFlipY.set(!1), n.pixelStoreUnpack.set(1), n.pixelStoreUnpackPremultiplyAlpha.set(this.format === l.RGBA && (!i || !1 !== i.premultiply)), r) this.size = [a, s], e instanceof HTMLImageElement || e instanceof HTMLCanvasElement || e instanceof HTMLVideoElement || e instanceof ImageData || t.isImageBitmap(e) ? l.texImage2D(l.TEXTURE_2D, 0, this.format, this.format, l.UNSIGNED_BYTE, e) : l.texImage2D(l.TEXTURE_2D, 0, this.format, a, s, 0, this.format, l.UNSIGNED_BYTE, e.data);else {\n          const {\n            x: i,\n            y: r\n          } = o || {\n            x: 0,\n            y: 0\n          };\n          e instanceof HTMLImageElement || e instanceof HTMLCanvasElement || e instanceof HTMLVideoElement || e instanceof ImageData || t.isImageBitmap(e) ? l.texSubImage2D(l.TEXTURE_2D, 0, i, r, l.RGBA, l.UNSIGNED_BYTE, e) : l.texSubImage2D(l.TEXTURE_2D, 0, i, r, a, s, l.RGBA, l.UNSIGNED_BYTE, e.data);\n        }\n        this.useMipmap && this.isSizePowerOfTwo() && l.generateMipmap(l.TEXTURE_2D);\n      }\n\n      bind(t, e, i) {\n        const {\n          context: o\n        } = this,\n              {\n          gl: a\n        } = o;\n        a.bindTexture(a.TEXTURE_2D, this.texture), i !== a.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (i = a.LINEAR), t !== this.filter && (a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MAG_FILTER, t), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, i || t), this.filter = t), e !== this.wrap && (a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_S, e), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_T, e), this.wrap = e);\n      }\n\n      isSizePowerOfTwo() {\n        return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;\n      }\n\n      destroy() {\n        const {\n          gl: t\n        } = this.context;\n        t.deleteTexture(this.texture), this.texture = null;\n      }\n\n    }\n\n    function _(t) {\n      const {\n        userImage: e\n      } = t;\n      return !!(e && e.render && e.render()) && (t.data.replace(new Uint8Array(e.data.buffer)), !0);\n    }\n\n    class p extends t.Evented {\n      constructor() {\n        super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = !1, this.requestors = [], this.patterns = {}, this.atlasImage = new t.RGBAImage({\n          width: 1,\n          height: 1\n        }), this.dirty = !0;\n      }\n\n      isLoaded() {\n        return this.loaded;\n      }\n\n      setLoaded(t) {\n        if (this.loaded !== t && (this.loaded = t, t)) {\n          for (const {\n            ids: t,\n            callback: e\n          } of this.requestors) this._notify(t, e);\n\n          this.requestors = [];\n        }\n      }\n\n      getImage(t) {\n        return this.images[t];\n      }\n\n      addImage(t, e) {\n        this._validate(t, e) && (this.images[t] = e);\n      }\n\n      _validate(e, i) {\n        let o = !0;\n        return this._validateStretch(i.stretchX, i.data && i.data.width) || (this.fire(new t.ErrorEvent(new Error(`Image \"${e}\" has invalid \"stretchX\" value`))), o = !1), this._validateStretch(i.stretchY, i.data && i.data.height) || (this.fire(new t.ErrorEvent(new Error(`Image \"${e}\" has invalid \"stretchY\" value`))), o = !1), this._validateContent(i.content, i) || (this.fire(new t.ErrorEvent(new Error(`Image \"${e}\" has invalid \"content\" value`))), o = !1), o;\n      }\n\n      _validateStretch(t, e) {\n        if (!t) return !0;\n        let i = 0;\n\n        for (const o of t) {\n          if (o[0] < i || o[1] < o[0] || e < o[1]) return !1;\n          i = o[1];\n        }\n\n        return !0;\n      }\n\n      _validateContent(t, e) {\n        return !(t && (4 !== t.length || t[0] < 0 || e.data.width < t[0] || t[1] < 0 || e.data.height < t[1] || t[2] < 0 || e.data.width < t[2] || t[3] < 0 || e.data.height < t[3] || t[2] < t[0] || t[3] < t[1]));\n      }\n\n      updateImage(t, e) {\n        e.version = this.images[t].version + 1, this.images[t] = e, this.updatedImages[t] = !0;\n      }\n\n      removeImage(t) {\n        const e = this.images[t];\n        delete this.images[t], delete this.patterns[t], e.userImage && e.userImage.onRemove && e.userImage.onRemove();\n      }\n\n      listImages() {\n        return Object.keys(this.images);\n      }\n\n      getImages(t, e) {\n        let i = !0;\n        if (!this.isLoaded()) for (const e of t) this.images[e] || (i = !1);\n        this.isLoaded() || i ? this._notify(t, e) : this.requestors.push({\n          ids: t,\n          callback: e\n        });\n      }\n\n      _notify(e, i) {\n        const o = {};\n\n        for (const i of e) {\n          this.images[i] || this.fire(new t.Event(\"styleimagemissing\", {\n            id: i\n          }));\n          const e = this.images[i];\n          e ? o[i] = {\n            data: e.data.clone(),\n            pixelRatio: e.pixelRatio,\n            sdf: e.sdf,\n            version: e.version,\n            stretchX: e.stretchX,\n            stretchY: e.stretchY,\n            content: e.content,\n            hasRenderCallback: Boolean(e.userImage && e.userImage.render)\n          } : t.warnOnce(`Image \"${i}\" could not be loaded. Please make sure you have added the image with map.addImage() or a \"sprite\" property in your style. You can provide missing images by listening for the \"styleimagemissing\" map event.`);\n        }\n\n        i(null, o);\n      }\n\n      getPixelSize() {\n        const {\n          width: t,\n          height: e\n        } = this.atlasImage;\n        return {\n          width: t,\n          height: e\n        };\n      }\n\n      getPattern(e) {\n        const i = this.patterns[e],\n              o = this.getImage(e);\n        if (!o) return null;\n        if (i && i.position.version === o.version) return i.position;\n        if (i) i.position.version = o.version;else {\n          const i = {\n            w: o.data.width + 2,\n            h: o.data.height + 2,\n            x: 0,\n            y: 0\n          },\n                a = new t.ImagePosition(i, o);\n          this.patterns[e] = {\n            bin: i,\n            position: a\n          };\n        }\n        return this._updatePatternAtlas(), this.patterns[e].position;\n      }\n\n      bind(t) {\n        const e = t.gl;\n        this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = !1) : this.atlasTexture = new m(t, this.atlasImage, e.RGBA), this.atlasTexture.bind(e.LINEAR, e.CLAMP_TO_EDGE);\n      }\n\n      _updatePatternAtlas() {\n        const e = [];\n\n        for (const t in this.patterns) e.push(this.patterns[t].bin);\n\n        const {\n          w: i,\n          h: o\n        } = t.potpack(e),\n              a = this.atlasImage;\n        a.resize({\n          width: i || 1,\n          height: o || 1\n        });\n\n        for (const e in this.patterns) {\n          const {\n            bin: i\n          } = this.patterns[e],\n                o = i.x + 1,\n                s = i.y + 1,\n                r = this.images[e].data,\n                n = r.width,\n                l = r.height;\n          t.RGBAImage.copy(r, a, {\n            x: 0,\n            y: 0\n          }, {\n            x: o,\n            y: s\n          }, {\n            width: n,\n            height: l\n          }), t.RGBAImage.copy(r, a, {\n            x: 0,\n            y: l - 1\n          }, {\n            x: o,\n            y: s - 1\n          }, {\n            width: n,\n            height: 1\n          }), t.RGBAImage.copy(r, a, {\n            x: 0,\n            y: 0\n          }, {\n            x: o,\n            y: s + l\n          }, {\n            width: n,\n            height: 1\n          }), t.RGBAImage.copy(r, a, {\n            x: n - 1,\n            y: 0\n          }, {\n            x: o - 1,\n            y: s\n          }, {\n            width: 1,\n            height: l\n          }), t.RGBAImage.copy(r, a, {\n            x: 0,\n            y: 0\n          }, {\n            x: o + n,\n            y: s\n          }, {\n            width: 1,\n            height: l\n          });\n        }\n\n        this.dirty = !0;\n      }\n\n      beginFrame() {\n        this.callbackDispatchedThisFrame = {};\n      }\n\n      dispatchRenderCallbacks(t) {\n        for (const e of t) {\n          if (this.callbackDispatchedThisFrame[e]) continue;\n          this.callbackDispatchedThisFrame[e] = !0;\n          const t = this.images[e];\n          _(t) && this.updateImage(e, t);\n        }\n      }\n\n    }\n\n    const f = 1e20;\n\n    function g(t, e, i, o, a, s, r, n, l) {\n      for (let c = e; c < e + o; c++) x(t, i * s + c, s, a, r, n, l);\n\n      for (let c = i; c < i + a; c++) x(t, c * s + e, 1, o, r, n, l);\n    }\n\n    function x(t, e, i, o, a, s, r) {\n      s[0] = 0, r[0] = -f, r[1] = f, a[0] = t[e];\n\n      for (let n = 1, l = 0, c = 0; n < o; n++) {\n        a[n] = t[e + n * i];\n        const o = n * n;\n\n        do {\n          const t = s[l];\n          c = (a[n] - a[t] + o - t * t) / (n - t) / 2;\n        } while (c <= r[l] && --l > -1);\n\n        l++, s[l] = n, r[l] = c, r[l + 1] = f;\n      }\n\n      for (let n = 0, l = 0; n < o; n++) {\n        for (; r[l + 1] < n;) l++;\n\n        const o = s[l],\n              c = n - o;\n        t[e + n * i] = a[o] + c * c;\n      }\n    }\n\n    class v {\n      constructor(t, e) {\n        this.requestManager = t, this.localIdeographFontFamily = e, this.entries = {};\n      }\n\n      setURL(t) {\n        this.url = t;\n      }\n\n      getGlyphs(e, i) {\n        const o = [];\n\n        for (const t in e) for (const i of e[t]) o.push({\n          stack: t,\n          id: i\n        });\n\n        t.asyncAll(o, (_ref66, i) => {\n          let {\n            stack: t,\n            id: e\n          } = _ref66;\n          let o = this.entries[t];\n          o || (o = this.entries[t] = {\n            glyphs: {},\n            requests: {},\n            ranges: {}\n          });\n          let a = o.glyphs[e];\n          if (void 0 !== a) return void i(null, {\n            stack: t,\n            id: e,\n            glyph: a\n          });\n          if (a = this._tinySDF(o, t, e), a) return o.glyphs[e] = a, void i(null, {\n            stack: t,\n            id: e,\n            glyph: a\n          });\n          const s = Math.floor(e / 256);\n          if (256 * s > 65535) return void i(new Error(\"glyphs > 65535 not supported\"));\n          if (o.ranges[s]) return void i(null, {\n            stack: t,\n            id: e,\n            glyph: a\n          });\n          let r = o.requests[s];\n          r || (r = o.requests[s] = [], v.loadGlyphRange(t, s, this.url, this.requestManager, (t, e) => {\n            if (e) {\n              for (const t in e) this._doesCharSupportLocalGlyph(+t) || (o.glyphs[+t] = e[+t]);\n\n              o.ranges[s] = !0;\n            }\n\n            for (const i of r) i(t, e);\n\n            delete o.requests[s];\n          })), r.push((o, a) => {\n            o ? i(o) : a && i(null, {\n              stack: t,\n              id: e,\n              glyph: a[e] || null\n            });\n          });\n        }, (t, e) => {\n          if (t) i(t);else if (e) {\n            const t = {};\n\n            for (const {\n              stack: i,\n              id: o,\n              glyph: a\n            } of e) (t[i] || (t[i] = {}))[o] = a && {\n              id: a.id,\n              bitmap: a.bitmap.clone(),\n              metrics: a.metrics\n            };\n\n            i(null, t);\n          }\n        });\n      }\n\n      _doesCharSupportLocalGlyph(e) {\n        return !!this.localIdeographFontFamily && (t.unicodeBlockLookup[\"CJK Unified Ideographs\"](e) || t.unicodeBlockLookup[\"Hangul Syllables\"](e) || t.unicodeBlockLookup.Hiragana(e) || t.unicodeBlockLookup.Katakana(e));\n      }\n\n      _tinySDF(e, i, o) {\n        const a = this.localIdeographFontFamily;\n        if (!a) return;\n        if (!this._doesCharSupportLocalGlyph(o)) return;\n        let s = e.tinySDF;\n\n        if (!s) {\n          let t = \"400\";\n          /bold/i.test(i) ? t = \"900\" : /medium/i.test(i) ? t = \"500\" : /light/i.test(i) && (t = \"200\"), s = e.tinySDF = new v.TinySDF({\n            fontSize: 24,\n            buffer: 3,\n            radius: 8,\n            cutoff: .25,\n            fontFamily: a,\n            fontWeight: t\n          });\n        }\n\n        const r = s.draw(String.fromCharCode(o));\n        return {\n          id: o,\n          bitmap: new t.AlphaImage({\n            width: r.width || 30,\n            height: r.height || 30\n          }, r.data),\n          metrics: {\n            width: r.glyphWidth || 24,\n            height: r.glyphHeight || 24,\n            left: r.glyphLeft || 0,\n            top: r.glyphTop || -8,\n            advance: r.glyphAdvance || 24\n          }\n        };\n      }\n\n    }\n\n    v.loadGlyphRange = function (e, i, o, a, s) {\n      const r = 256 * i,\n            n = r + 255,\n            l = a.transformRequest(o.replace(\"{fontstack}\", e).replace(\"{range}\", `${r}-${n}`), t.ResourceType.Glyphs);\n      t.getArrayBuffer(l, (e, i) => {\n        if (e) s(e);else if (i) {\n          const e = {};\n\n          for (const o of t.parseGlyphPBF(i)) e[o.id] = o;\n\n          s(null, e);\n        }\n      });\n    }, v.TinySDF = class {\n      constructor(_ref67) {\n        let {\n          fontSize: t = 24,\n          buffer: e = 3,\n          radius: i = 8,\n          cutoff: o = .25,\n          fontFamily: a = \"sans-serif\",\n          fontWeight: s = \"normal\",\n          fontStyle: r = \"normal\"\n        } = _ref67;\n        this.buffer = e, this.cutoff = o, this.radius = i;\n\n        const n = this.size = t + 4 * e,\n              l = this._createCanvas(n),\n              c = this.ctx = l.getContext(\"2d\", {\n          willReadFrequently: !0\n        });\n\n        c.font = `${r} ${s} ${t}px ${a}`, c.textBaseline = \"alphabetic\", c.textAlign = \"left\", c.fillStyle = \"black\", this.gridOuter = new Float64Array(n * n), this.gridInner = new Float64Array(n * n), this.f = new Float64Array(n), this.z = new Float64Array(n + 1), this.v = new Uint16Array(n);\n      }\n\n      _createCanvas(t) {\n        const e = document.createElement(\"canvas\");\n        return e.width = e.height = t, e;\n      }\n\n      draw(t) {\n        const {\n          width: e,\n          actualBoundingBoxAscent: i,\n          actualBoundingBoxDescent: o,\n          actualBoundingBoxLeft: a,\n          actualBoundingBoxRight: s\n        } = this.ctx.measureText(t),\n              r = Math.floor(i),\n              n = Math.min(this.size - this.buffer, Math.ceil(s - a)),\n              l = Math.min(this.size - this.buffer, Math.ceil(i) + Math.ceil(o)),\n              c = n + 2 * this.buffer,\n              h = l + 2 * this.buffer,\n              u = c * h,\n              d = new Uint8ClampedArray(u),\n              m = {\n          data: d,\n          width: c,\n          height: h,\n          glyphWidth: n,\n          glyphHeight: l,\n          glyphTop: r,\n          glyphLeft: 0,\n          glyphAdvance: e\n        };\n        if (0 === n || 0 === l) return m;\n        const {\n          ctx: _,\n          buffer: p,\n          gridInner: x,\n          gridOuter: v\n        } = this;\n        _.clearRect(p, p, n, l), _.fillText(t, p, p + r + 1);\n\n        const y = _.getImageData(p, p, n, l);\n\n        v.fill(f, 0, u), x.fill(0, 0, u);\n\n        for (let t = 0; t < l; t++) for (let e = 0; e < n; e++) {\n          const i = y.data[4 * (t * n + e) + 3] / 255;\n          if (0 === i) continue;\n          const o = (t + p) * c + e + p;\n          if (1 === i) v[o] = 0, x[o] = f;else {\n            const t = .5 - i;\n            v[o] = t > 0 ? t * t : 0, x[o] = t < 0 ? t * t : 0;\n          }\n        }\n\n        g(v, 0, 0, c, h, c, this.f, this.v, this.z), g(x, p, p, n, l, c, this.f, this.v, this.z);\n\n        for (let t = 0; t < u; t++) {\n          const e = Math.sqrt(v[t]) - Math.sqrt(x[t]);\n          d[t] = Math.round(255 - 255 * (e / this.radius + this.cutoff));\n        }\n\n        return m;\n      }\n\n    };\n    const y = new t.Properties({\n      anchor: new t.DataConstantProperty(t.spec.light.anchor),\n      position: new class {\n        constructor() {\n          this.specification = t.spec.light.position;\n        }\n\n        possiblyEvaluate(e, i) {\n          return t.sphericalToCartesian(e.expression.evaluate(i));\n        }\n\n        interpolate(e, i, o) {\n          return {\n            x: t.number(e.x, i.x, o),\n            y: t.number(e.y, i.y, o),\n            z: t.number(e.z, i.z, o)\n          };\n        }\n\n      }(),\n      color: new t.DataConstantProperty(t.spec.light.color),\n      intensity: new t.DataConstantProperty(t.spec.light.intensity)\n    }),\n          b = \"-transition\";\n\n    class w extends t.Evented {\n      constructor(e) {\n        super(), this._transitionable = new t.Transitionable(y), this.setLight(e), this._transitioning = this._transitionable.untransitioned();\n      }\n\n      getLight() {\n        return this._transitionable.serialize();\n      }\n\n      setLight(e) {\n        let i = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        if (!this._validate(t.validateLight, e, i)) for (const t in e) {\n          const i = e[t];\n          t.endsWith(b) ? this._transitionable.setTransition(t.slice(0, -b.length), i) : this._transitionable.setValue(t, i);\n        }\n      }\n\n      updateTransitions(t) {\n        this._transitioning = this._transitionable.transitioned(t, this._transitioning);\n      }\n\n      hasTransition() {\n        return this._transitioning.hasTransition();\n      }\n\n      recalculate(t) {\n        this.properties = this._transitioning.possiblyEvaluate(t);\n      }\n\n      _validate(e, i, o) {\n        return (!o || !1 !== o.validate) && t.emitValidationErrors(this, e.call(t.validateStyle, t.extend({\n          value: i,\n          style: {\n            glyphs: !0,\n            sprite: !0\n          },\n          styleSpec: t.spec\n        })));\n      }\n\n    }\n\n    class T {\n      constructor(t, e) {\n        this.width = t, this.height = e, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {};\n      }\n\n      getDash(t, e) {\n        const i = t.join(\",\") + String(e);\n        return this.dashEntry[i] || (this.dashEntry[i] = this.addDash(t, e)), this.dashEntry[i];\n      }\n\n      getDashRanges(t, e, i) {\n        const o = [];\n        let a = t.length % 2 == 1 ? -t[t.length - 1] * i : 0,\n            s = t[0] * i,\n            r = !0;\n        o.push({\n          left: a,\n          right: s,\n          isDash: r,\n          zeroLength: 0 === t[0]\n        });\n        let n = t[0];\n\n        for (let e = 1; e < t.length; e++) {\n          r = !r;\n          const l = t[e];\n          a = n * i, n += l, s = n * i, o.push({\n            left: a,\n            right: s,\n            isDash: r,\n            zeroLength: 0 === l\n          });\n        }\n\n        return o;\n      }\n\n      addRoundDash(t, e, i) {\n        const o = e / 2;\n\n        for (let e = -i; e <= i; e++) {\n          const a = this.width * (this.nextRow + i + e);\n          let s = 0,\n              r = t[s];\n\n          for (let n = 0; n < this.width; n++) {\n            n / r.right > 1 && (r = t[++s]);\n            const l = Math.abs(n - r.left),\n                  c = Math.abs(n - r.right),\n                  h = Math.min(l, c);\n            let u;\n            const d = e / i * (o + 1);\n\n            if (r.isDash) {\n              const t = o - Math.abs(d);\n              u = Math.sqrt(h * h + t * t);\n            } else u = o - Math.sqrt(h * h + d * d);\n\n            this.data[a + n] = Math.max(0, Math.min(255, u + 128));\n          }\n        }\n      }\n\n      addRegularDash(t) {\n        for (let e = t.length - 1; e >= 0; --e) {\n          const i = t[e],\n                o = t[e + 1];\n          i.zeroLength ? t.splice(e, 1) : o && o.isDash === i.isDash && (o.left = i.left, t.splice(e, 1));\n        }\n\n        const e = t[0],\n              i = t[t.length - 1];\n        e.isDash === i.isDash && (e.left = i.left - this.width, i.right = e.right + this.width);\n        const o = this.width * this.nextRow;\n        let a = 0,\n            s = t[a];\n\n        for (let e = 0; e < this.width; e++) {\n          e / s.right > 1 && (s = t[++a]);\n          const i = Math.abs(e - s.left),\n                r = Math.abs(e - s.right),\n                n = Math.min(i, r);\n          this.data[o + e] = Math.max(0, Math.min(255, (s.isDash ? n : -n) + 128));\n        }\n      }\n\n      addDash(e, i) {\n        const o = i ? 7 : 0,\n              a = 2 * o + 1;\n        if (this.nextRow + a > this.height) return t.warnOnce(\"LineAtlas out of space\"), null;\n        let s = 0;\n\n        for (let t = 0; t < e.length; t++) s += e[t];\n\n        if (0 !== s) {\n          const t = this.width / s,\n                a = this.getDashRanges(e, this.width, t);\n          i ? this.addRoundDash(a, t, o) : this.addRegularDash(a);\n        }\n\n        const r = {\n          y: (this.nextRow + o + .5) / this.height,\n          height: 2 * o / this.height,\n          width: s\n        };\n        return this.nextRow += a, this.dirty = !0, r;\n      }\n\n      bind(t) {\n        const e = t.gl;\n        this.texture ? (e.bindTexture(e.TEXTURE_2D, this.texture), this.dirty && (this.dirty = !1, e.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, this.width, this.height, e.ALPHA, e.UNSIGNED_BYTE, this.data))) : (this.texture = e.createTexture(), e.bindTexture(e.TEXTURE_2D, this.texture), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.REPEAT), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.REPEAT), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.LINEAR), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.LINEAR), e.texImage2D(e.TEXTURE_2D, 0, e.ALPHA, this.width, this.height, 0, e.ALPHA, e.UNSIGNED_BYTE, this.data));\n      }\n\n    }\n\n    class E {\n      constructor(e, i) {\n        this.workerPool = e, this.actors = [], this.currentActor = 0, this.id = t.uniqueId();\n        const o = this.workerPool.acquire(this.id);\n\n        for (let t = 0; t < o.length; t++) {\n          const e = new E.Actor(o[t], i, this.id);\n          e.name = `Worker ${t}`, this.actors.push(e);\n        }\n      }\n\n      broadcast(e, i, o) {\n        t.asyncAll(this.actors, (t, o) => {\n          t.send(e, i, o);\n        }, o = o || function () {});\n      }\n\n      getActor() {\n        return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];\n      }\n\n      remove() {\n        this.actors.forEach(t => {\n          t.remove();\n        }), this.actors = [], this.workerPool.release(this.id);\n      }\n\n    }\n\n    function I(e, i, o) {\n      const a = function (i, a) {\n        if (i) return o(i);\n\n        if (a) {\n          const i = t.pick(t.extend(a, e), [\"tiles\", \"minzoom\", \"maxzoom\", \"attribution\", \"maplibreLogo\", \"bounds\", \"scheme\", \"tileSize\", \"encoding\"]);\n          a.vector_layers && (i.vectorLayers = a.vector_layers, i.vectorLayerIds = i.vectorLayers.map(t => t.id)), o(null, i);\n        }\n      };\n\n      return e.url ? t.getJSON(i.transformRequest(e.url, t.ResourceType.Source), a) : t.exported.frame(() => a(null, e));\n    }\n\n    E.Actor = t.Actor;\n\n    class S {\n      constructor(e, i, o) {\n        this.bounds = t.LngLatBounds.convert(this.validateBounds(e)), this.minzoom = i || 0, this.maxzoom = o || 24;\n      }\n\n      validateBounds(t) {\n        return Array.isArray(t) && 4 === t.length ? [Math.max(-180, t[0]), Math.max(-90, t[1]), Math.min(180, t[2]), Math.min(90, t[3])] : [-180, -90, 180, 90];\n      }\n\n      contains(e) {\n        const i = Math.pow(2, e.z),\n              o = Math.floor(t.mercatorXfromLng(this.bounds.getWest()) * i),\n              a = Math.floor(t.mercatorYfromLat(this.bounds.getNorth()) * i),\n              s = Math.ceil(t.mercatorXfromLng(this.bounds.getEast()) * i),\n              r = Math.ceil(t.mercatorYfromLat(this.bounds.getSouth()) * i);\n        return e.x >= o && e.x < s && e.y >= a && e.y < r;\n      }\n\n    }\n\n    class C extends t.Evented {\n      constructor(e, i, o, a) {\n        if (super(), this.id = e, this.dispatcher = o, this.type = \"vector\", this.minzoom = 0, this.maxzoom = 22, this.scheme = \"xyz\", this.tileSize = 512, this.reparseOverscaled = !0, this.isTileClipped = !0, this._loaded = !1, t.extend(this, t.pick(i, [\"url\", \"scheme\", \"tileSize\", \"promoteId\"])), this._options = t.extend({\n          type: \"vector\"\n        }, i), this._collectResourceTiming = i.collectResourceTiming, 512 !== this.tileSize) throw new Error(\"vector tile sources must have a tileSize of 512\");\n        this.setEventedParent(a);\n      }\n\n      load() {\n        this._loaded = !1, this.fire(new t.Event(\"dataloading\", {\n          dataType: \"source\"\n        })), this._tileJSONRequest = I(this._options, this.map._requestManager, (e, i) => {\n          this._tileJSONRequest = null, this._loaded = !0, this.map.style.sourceCaches[this.id].clearTiles(), e ? this.fire(new t.ErrorEvent(e)) : i && (t.extend(this, i), i.bounds && (this.tileBounds = new S(i.bounds, this.minzoom, this.maxzoom)), this.fire(new t.Event(\"data\", {\n            dataType: \"source\",\n            sourceDataType: \"metadata\"\n          })), this.fire(new t.Event(\"data\", {\n            dataType: \"source\",\n            sourceDataType: \"content\"\n          })));\n        });\n      }\n\n      loaded() {\n        return this._loaded;\n      }\n\n      hasTile(t) {\n        return !this.tileBounds || this.tileBounds.contains(t.canonical);\n      }\n\n      onAdd(t) {\n        this.map = t, this.load();\n      }\n\n      setSourceProperty(t) {\n        this._tileJSONRequest && this._tileJSONRequest.cancel(), t(), this.load();\n      }\n\n      setTiles(t) {\n        return this.setSourceProperty(() => {\n          this._options.tiles = t;\n        }), this;\n      }\n\n      setUrl(t) {\n        return this.setSourceProperty(() => {\n          this.url = t, this._options.url = t;\n        }), this;\n      }\n\n      onRemove() {\n        this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);\n      }\n\n      serialize() {\n        return t.extend({}, this._options);\n      }\n\n      loadTile(e, i) {\n        const o = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme),\n              a = {\n          request: this.map._requestManager.transformRequest(o, t.ResourceType.Tile),\n          uid: e.uid,\n          tileID: e.tileID,\n          zoom: e.tileID.overscaledZ,\n          tileSize: this.tileSize * e.tileID.overscaleFactor(),\n          type: this.type,\n          source: this.id,\n          pixelRatio: this.map.getPixelRatio(),\n          showCollisionBoxes: this.map.showCollisionBoxes,\n          promoteId: this.promoteId\n        };\n\n        function s(o, a) {\n          return delete e.request, e.aborted ? i(null) : o && 404 !== o.status ? i(o) : (a && a.resourceTiming && (e.resourceTiming = a.resourceTiming), this.map._refreshExpiredTiles && a && e.setExpiryData(a), e.loadVectorData(a, this.map.painter), t.cacheEntryPossiblyAdded(this.dispatcher), i(null), void (e.reloadCallback && (this.loadTile(e, e.reloadCallback), e.reloadCallback = null)));\n        }\n\n        a.request.collectResourceTiming = this._collectResourceTiming, e.actor && \"expired\" !== e.state ? \"loading\" === e.state ? e.reloadCallback = i : e.request = e.actor.send(\"reloadTile\", a, s.bind(this)) : (e.actor = this.dispatcher.getActor(), e.request = e.actor.send(\"loadTile\", a, s.bind(this)));\n      }\n\n      abortTile(t) {\n        t.request && (t.request.cancel(), delete t.request), t.actor && t.actor.send(\"abortTile\", {\n          uid: t.uid,\n          type: this.type,\n          source: this.id\n        }, void 0);\n      }\n\n      unloadTile(t) {\n        t.unloadVectorData(), t.actor && t.actor.send(\"removeTile\", {\n          uid: t.uid,\n          type: this.type,\n          source: this.id\n        }, void 0);\n      }\n\n      hasTransition() {\n        return !1;\n      }\n\n    }\n\n    class P extends t.Evented {\n      constructor(e, i, o, a) {\n        super(), this.id = e, this.dispatcher = o, this.setEventedParent(a), this.type = \"raster\", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = !0, this.scheme = \"xyz\", this.tileSize = 512, this._loaded = !1, this._options = t.extend({\n          type: \"raster\"\n        }, i), t.extend(this, t.pick(i, [\"url\", \"scheme\", \"tileSize\"]));\n      }\n\n      load() {\n        this._loaded = !1, this.fire(new t.Event(\"dataloading\", {\n          dataType: \"source\"\n        })), this._tileJSONRequest = I(this._options, this.map._requestManager, (e, i) => {\n          this._tileJSONRequest = null, this._loaded = !0, e ? this.fire(new t.ErrorEvent(e)) : i && (t.extend(this, i), i.bounds && (this.tileBounds = new S(i.bounds, this.minzoom, this.maxzoom)), this.fire(new t.Event(\"data\", {\n            dataType: \"source\",\n            sourceDataType: \"metadata\"\n          })), this.fire(new t.Event(\"data\", {\n            dataType: \"source\",\n            sourceDataType: \"content\"\n          })));\n        });\n      }\n\n      loaded() {\n        return this._loaded;\n      }\n\n      onAdd(t) {\n        this.map = t, this.load();\n      }\n\n      onRemove() {\n        this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);\n      }\n\n      serialize() {\n        return t.extend({}, this._options);\n      }\n\n      hasTile(t) {\n        return !this.tileBounds || this.tileBounds.contains(t.canonical);\n      }\n\n      loadTile(e, i) {\n        const o = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);\n        e.request = t.getImage(this.map._requestManager.transformRequest(o, t.ResourceType.Tile), (o, a) => {\n          if (delete e.request, e.aborted) e.state = \"unloaded\", i(null);else if (o) e.state = \"errored\", i(o);else if (a) {\n            this.map._refreshExpiredTiles && e.setExpiryData(a), delete a.cacheControl, delete a.expires;\n            const o = this.map.painter.context,\n                  s = o.gl;\n            e.texture = this.map.painter.getTileTexture(a.width), e.texture ? e.texture.update(a, {\n              useMipmap: !0\n            }) : (e.texture = new m(o, a, s.RGBA, {\n              useMipmap: !0\n            }), e.texture.bind(s.LINEAR, s.CLAMP_TO_EDGE, s.LINEAR_MIPMAP_NEAREST), o.extTextureFilterAnisotropic && s.texParameterf(s.TEXTURE_2D, o.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, o.extTextureFilterAnisotropicMax)), e.state = \"loaded\", t.cacheEntryPossiblyAdded(this.dispatcher), i(null);\n          }\n        });\n      }\n\n      abortTile(t, e) {\n        t.request && (t.request.cancel(), delete t.request), e();\n      }\n\n      unloadTile(t, e) {\n        t.texture && this.map.painter.saveTileTexture(t.texture), e();\n      }\n\n      hasTransition() {\n        return !1;\n      }\n\n    }\n\n    let z;\n\n    class D extends P {\n      constructor(e, i, o, a) {\n        super(e, i, o, a), this.type = \"raster-dem\", this.maxzoom = 22, this._options = t.extend({\n          type: \"raster-dem\"\n        }, i), this.encoding = i.encoding || \"mapbox\";\n      }\n\n      serialize() {\n        return {\n          type: \"raster-dem\",\n          url: this.url,\n          tileSize: this.tileSize,\n          tiles: this.tiles,\n          bounds: this.bounds,\n          encoding: this.encoding\n        };\n      }\n\n      loadTile(e, i) {\n        const o = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);\n\n        function a(t, o) {\n          t && (e.state = \"errored\", i(t)), o && (e.dem = o, e.needsHillshadePrepare = !0, e.state = \"loaded\", i(null));\n        }\n\n        e.request = t.getImage(this.map._requestManager.transformRequest(o, t.ResourceType.Tile), function (o, s) {\n          if (delete e.request, e.aborted) e.state = \"unloaded\", i(null);else if (o) e.state = \"errored\", i(o);else if (s) {\n            this.map._refreshExpiredTiles && e.setExpiryData(s), delete s.cacheControl, delete s.expires;\n            const i = t.isImageBitmap(s) && (null == z && (z = \"undefined\" != typeof OffscreenCanvas && new OffscreenCanvas(1, 1).getContext(\"2d\") && \"function\" == typeof createImageBitmap), z) ? s : t.exported.getImageData(s, 1),\n                  o = {\n              uid: e.uid,\n              coord: e.tileID,\n              source: this.id,\n              rawImageData: i,\n              encoding: this.encoding\n            };\n            e.actor && \"expired\" !== e.state || (e.actor = this.dispatcher.getActor(), e.actor.send(\"loadDEMTile\", o, a.bind(this)));\n          }\n        }.bind(this)), e.neighboringTiles = this._getNeighboringTiles(e.tileID);\n      }\n\n      _getNeighboringTiles(e) {\n        const i = e.canonical,\n              o = Math.pow(2, i.z),\n              a = (i.x - 1 + o) % o,\n              s = 0 === i.x ? e.wrap - 1 : e.wrap,\n              r = (i.x + 1 + o) % o,\n              n = i.x + 1 === o ? e.wrap + 1 : e.wrap,\n              l = {};\n        return l[new t.OverscaledTileID(e.overscaledZ, s, i.z, a, i.y).key] = {\n          backfilled: !1\n        }, l[new t.OverscaledTileID(e.overscaledZ, n, i.z, r, i.y).key] = {\n          backfilled: !1\n        }, i.y > 0 && (l[new t.OverscaledTileID(e.overscaledZ, s, i.z, a, i.y - 1).key] = {\n          backfilled: !1\n        }, l[new t.OverscaledTileID(e.overscaledZ, e.wrap, i.z, i.x, i.y - 1).key] = {\n          backfilled: !1\n        }, l[new t.OverscaledTileID(e.overscaledZ, n, i.z, r, i.y - 1).key] = {\n          backfilled: !1\n        }), i.y + 1 < o && (l[new t.OverscaledTileID(e.overscaledZ, s, i.z, a, i.y + 1).key] = {\n          backfilled: !1\n        }, l[new t.OverscaledTileID(e.overscaledZ, e.wrap, i.z, i.x, i.y + 1).key] = {\n          backfilled: !1\n        }, l[new t.OverscaledTileID(e.overscaledZ, n, i.z, r, i.y + 1).key] = {\n          backfilled: !1\n        }), l;\n      }\n\n      unloadTile(t) {\n        t.demTexture && this.map.painter.saveTileTexture(t.demTexture), t.fbo && (t.fbo.destroy(), delete t.fbo), t.dem && delete t.dem, delete t.neighboringTiles, t.state = \"unloaded\", t.actor && t.actor.send(\"removeDEMTile\", {\n          uid: t.uid,\n          source: this.id\n        });\n      }\n\n    }\n\n    class A extends t.Evented {\n      constructor(e, i, o, a) {\n        super(), this.id = e, this.type = \"geojson\", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = !0, this.reparseOverscaled = !0, this._removed = !1, this._pendingLoads = 0, this.actor = o.getActor(), this.setEventedParent(a), this._data = i.data, this._options = t.extend({}, i), this._collectResourceTiming = i.collectResourceTiming, void 0 !== i.maxzoom && (this.maxzoom = i.maxzoom), i.type && (this.type = i.type), i.attribution && (this.attribution = i.attribution), this.promoteId = i.promoteId;\n        const s = t.EXTENT / this.tileSize;\n        this.workerOptions = t.extend({\n          source: this.id,\n          cluster: i.cluster || !1,\n          geojsonVtOptions: {\n            buffer: (void 0 !== i.buffer ? i.buffer : 128) * s,\n            tolerance: (void 0 !== i.tolerance ? i.tolerance : .375) * s,\n            extent: t.EXTENT,\n            maxZoom: this.maxzoom,\n            lineMetrics: i.lineMetrics || !1,\n            generateId: i.generateId || !1\n          },\n          superclusterOptions: {\n            maxZoom: void 0 !== i.clusterMaxZoom ? i.clusterMaxZoom : this.maxzoom - 1,\n            minPoints: Math.max(2, i.clusterMinPoints || 2),\n            extent: t.EXTENT,\n            radius: (i.clusterRadius || 50) * s,\n            log: !1,\n            generateId: i.generateId || !1\n          },\n          clusterProperties: i.clusterProperties,\n          filter: i.filter\n        }, i.workerOptions);\n      }\n\n      load() {\n        this._updateWorkerData(\"metadata\");\n      }\n\n      onAdd(t) {\n        this.map = t, this.load();\n      }\n\n      setData(t) {\n        return this._data = t, this._updateWorkerData(\"content\"), this;\n      }\n\n      getClusterExpansionZoom(t, e) {\n        return this.actor.send(\"geojson.getClusterExpansionZoom\", {\n          clusterId: t,\n          source: this.id\n        }, e), this;\n      }\n\n      getClusterChildren(t, e) {\n        return this.actor.send(\"geojson.getClusterChildren\", {\n          clusterId: t,\n          source: this.id\n        }, e), this;\n      }\n\n      getClusterLeaves(t, e, i, o) {\n        return this.actor.send(\"geojson.getClusterLeaves\", {\n          source: this.id,\n          clusterId: t,\n          limit: e,\n          offset: i\n        }, o), this;\n      }\n\n      _updateWorkerData(e) {\n        const i = t.extend({}, this.workerOptions),\n              o = this._data;\n        \"string\" == typeof o ? (i.request = this.map._requestManager.transformRequest(t.exported.resolveURL(o), t.ResourceType.Source), i.request.collectResourceTiming = this._collectResourceTiming) : i.data = JSON.stringify(o), this._pendingLoads++, this.fire(new t.Event(\"dataloading\", {\n          dataType: \"source\"\n        })), this.actor.send(`${this.type}.loadData`, i, (o, a) => {\n          if (this._pendingLoads--, this._removed || a && a.abandoned) return;\n          let s = null;\n          if (a && a.resourceTiming && a.resourceTiming[this.id] && (s = a.resourceTiming[this.id].slice(0)), this.actor.send(`${this.type}.coalesce`, {\n            source: i.source\n          }, null), o) return void this.fire(new t.ErrorEvent(o));\n          const r = {\n            dataType: \"source\",\n            sourceDataType: e\n          };\n          this._collectResourceTiming && s && s.length > 0 && t.extend(r, {\n            resourceTiming: s\n          }), this.fire(new t.Event(\"data\", r));\n        });\n      }\n\n      loaded() {\n        return 0 === this._pendingLoads;\n      }\n\n      loadTile(t, e) {\n        const i = t.actor ? \"reloadTile\" : \"loadTile\";\n        t.actor = this.actor;\n        const o = {\n          type: this.type,\n          uid: t.uid,\n          tileID: t.tileID,\n          zoom: t.tileID.overscaledZ,\n          maxZoom: this.maxzoom,\n          tileSize: this.tileSize,\n          source: this.id,\n          pixelRatio: this.map.getPixelRatio(),\n          showCollisionBoxes: this.map.showCollisionBoxes,\n          promoteId: this.promoteId\n        };\n        t.request = this.actor.send(i, o, (o, a) => (delete t.request, t.unloadVectorData(), t.aborted ? e(null) : o ? e(o) : (t.loadVectorData(a, this.map.painter, \"reloadTile\" === i), e(null))));\n      }\n\n      abortTile(t) {\n        t.request && (t.request.cancel(), delete t.request), t.aborted = !0;\n      }\n\n      unloadTile(t) {\n        t.unloadVectorData(), this.actor.send(\"removeTile\", {\n          uid: t.uid,\n          type: this.type,\n          source: this.id\n        });\n      }\n\n      onRemove() {\n        this._removed = !0, this.actor.send(\"removeSource\", {\n          type: this.type,\n          source: this.id\n        });\n      }\n\n      serialize() {\n        return t.extend({}, this._options, {\n          type: this.type,\n          data: this._data\n        });\n      }\n\n      hasTransition() {\n        return !1;\n      }\n\n    }\n\n    var M = t.createLayout([{\n      name: \"a_pos\",\n      type: \"Int16\",\n      components: 2\n    }, {\n      name: \"a_texture_pos\",\n      type: \"Int16\",\n      components: 2\n    }]);\n\n    class L extends t.Evented {\n      constructor(t, e, i, o) {\n        super(), this.id = t, this.dispatcher = i, this.coordinates = e.coordinates, this.type = \"image\", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = !1, this.setEventedParent(o), this.options = e;\n      }\n\n      load(e, i) {\n        this._loaded = !1, this.fire(new t.Event(\"dataloading\", {\n          dataType: \"source\"\n        })), this.url = this.options.url, t.getImage(this.map._requestManager.transformRequest(this.url, t.ResourceType.Image), (o, a) => {\n          this._loaded = !0, o ? this.fire(new t.ErrorEvent(o)) : a && (this.image = a, e && (this.coordinates = e), i && i(), this._finishLoading());\n        });\n      }\n\n      loaded() {\n        return this._loaded;\n      }\n\n      updateImage(t) {\n        return this.image && t.url ? (this.options.url = t.url, this.load(t.coordinates, () => {\n          this.texture = null;\n        }), this) : this;\n      }\n\n      _finishLoading() {\n        this.map && (this.setCoordinates(this.coordinates), this.fire(new t.Event(\"data\", {\n          dataType: \"source\",\n          sourceDataType: \"metadata\"\n        })));\n      }\n\n      onAdd(t) {\n        this.map = t, this.load();\n      }\n\n      setCoordinates(e) {\n        this.coordinates = e;\n        const i = e.map(t.MercatorCoordinate.fromLngLat);\n        this.tileID = function (e) {\n          let i = 1 / 0,\n              o = 1 / 0,\n              a = -1 / 0,\n              s = -1 / 0;\n\n          for (const t of e) i = Math.min(i, t.x), o = Math.min(o, t.y), a = Math.max(a, t.x), s = Math.max(s, t.y);\n\n          const r = Math.max(a - i, s - o),\n                n = Math.max(0, Math.floor(-Math.log(r) / Math.LN2)),\n                l = Math.pow(2, n);\n          return new t.CanonicalTileID(n, Math.floor((i + a) / 2 * l), Math.floor((o + s) / 2 * l));\n        }(i), this.minzoom = this.maxzoom = this.tileID.z;\n        const o = i.map(t => this.tileID.getTilePoint(t)._round());\n        return this._boundsArray = new t.RasterBoundsArray(), this._boundsArray.emplaceBack(o[0].x, o[0].y, 0, 0), this._boundsArray.emplaceBack(o[1].x, o[1].y, t.EXTENT, 0), this._boundsArray.emplaceBack(o[3].x, o[3].y, 0, t.EXTENT), this._boundsArray.emplaceBack(o[2].x, o[2].y, t.EXTENT, t.EXTENT), this.boundsBuffer && (this.boundsBuffer.destroy(), delete this.boundsBuffer), this.fire(new t.Event(\"data\", {\n          dataType: \"source\",\n          sourceDataType: \"content\"\n        })), this;\n      }\n\n      prepare() {\n        if (0 === Object.keys(this.tiles).length || !this.image) return;\n        const e = this.map.painter.context,\n              i = e.gl;\n        this.boundsBuffer || (this.boundsBuffer = e.createVertexBuffer(this._boundsArray, M.members)), this.boundsSegments || (this.boundsSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2)), this.texture || (this.texture = new m(e, this.image, i.RGBA), this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE));\n\n        for (const t in this.tiles) {\n          const e = this.tiles[t];\n          \"loaded\" !== e.state && (e.state = \"loaded\", e.texture = this.texture);\n        }\n      }\n\n      loadTile(t, e) {\n        this.tileID && this.tileID.equals(t.tileID.canonical) ? (this.tiles[String(t.tileID.wrap)] = t, t.buckets = {}, e(null)) : (t.state = \"errored\", e(null));\n      }\n\n      serialize() {\n        return {\n          type: \"image\",\n          url: this.options.url,\n          coordinates: this.coordinates\n        };\n      }\n\n      hasTransition() {\n        return !1;\n      }\n\n    }\n\n    class R extends L {\n      constructor(t, e, i, o) {\n        super(t, e, i, o), this.roundZoom = !0, this.type = \"video\", this.options = e;\n      }\n\n      load() {\n        this._loaded = !1;\n        const e = this.options;\n        this.urls = [];\n\n        for (const i of e.urls) this.urls.push(this.map._requestManager.transformRequest(i, t.ResourceType.Source).url);\n\n        t.getVideo(this.urls, (e, i) => {\n          this._loaded = !0, e ? this.fire(new t.ErrorEvent(e)) : i && (this.video = i, this.video.loop = !0, this.video.addEventListener(\"playing\", () => {\n            this.map.triggerRepaint();\n          }), this.map && this.video.play(), this._finishLoading());\n        });\n      }\n\n      pause() {\n        this.video && this.video.pause();\n      }\n\n      play() {\n        this.video && this.video.play();\n      }\n\n      seek(e) {\n        if (this.video) {\n          const i = this.video.seekable;\n          e < i.start(0) || e > i.end(0) ? this.fire(new t.ErrorEvent(new t.ValidationError(`sources.${this.id}`, null, `Playback for this video can be set only between the ${i.start(0)} and ${i.end(0)}-second mark.`))) : this.video.currentTime = e;\n        }\n      }\n\n      getVideo() {\n        return this.video;\n      }\n\n      onAdd(t) {\n        this.map || (this.map = t, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));\n      }\n\n      prepare() {\n        if (0 === Object.keys(this.tiles).length || this.video.readyState < 2) return;\n        const e = this.map.painter.context,\n              i = e.gl;\n        this.boundsBuffer || (this.boundsBuffer = e.createVertexBuffer(this._boundsArray, M.members)), this.boundsSegments || (this.boundsSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2)), this.texture ? this.video.paused || (this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE), i.texSubImage2D(i.TEXTURE_2D, 0, 0, 0, i.RGBA, i.UNSIGNED_BYTE, this.video)) : (this.texture = new m(e, this.video, i.RGBA), this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE));\n\n        for (const t in this.tiles) {\n          const e = this.tiles[t];\n          \"loaded\" !== e.state && (e.state = \"loaded\", e.texture = this.texture);\n        }\n      }\n\n      serialize() {\n        return {\n          type: \"video\",\n          urls: this.urls,\n          coordinates: this.coordinates\n        };\n      }\n\n      hasTransition() {\n        return this.video && !this.video.paused;\n      }\n\n    }\n\n    class k extends L {\n      constructor(e, i, o, a) {\n        super(e, i, o, a), i.coordinates ? Array.isArray(i.coordinates) && 4 === i.coordinates.length && !i.coordinates.some(t => !Array.isArray(t) || 2 !== t.length || t.some(t => \"number\" != typeof t)) || this.fire(new t.ErrorEvent(new t.ValidationError(`sources.${e}`, null, '\"coordinates\" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new t.ErrorEvent(new t.ValidationError(`sources.${e}`, null, 'missing required property \"coordinates\"'))), i.animate && \"boolean\" != typeof i.animate && this.fire(new t.ErrorEvent(new t.ValidationError(`sources.${e}`, null, 'optional \"animate\" property must be a boolean value'))), i.canvas ? \"string\" == typeof i.canvas || i.canvas instanceof HTMLCanvasElement || this.fire(new t.ErrorEvent(new t.ValidationError(`sources.${e}`, null, '\"canvas\" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new t.ErrorEvent(new t.ValidationError(`sources.${e}`, null, 'missing required property \"canvas\"'))), this.options = i, this.animate = void 0 === i.animate || i.animate;\n      }\n\n      load() {\n        this._loaded = !0, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new t.ErrorEvent(new Error(\"Canvas dimensions cannot be less than or equal to zero.\"))) : (this.play = function () {\n          this._playing = !0, this.map.triggerRepaint();\n        }, this.pause = function () {\n          this._playing && (this.prepare(), this._playing = !1);\n        }, this._finishLoading());\n      }\n\n      getCanvas() {\n        return this.canvas;\n      }\n\n      onAdd(t) {\n        this.map = t, this.load(), this.canvas && this.animate && this.play();\n      }\n\n      onRemove() {\n        this.pause();\n      }\n\n      prepare() {\n        let e = !1;\n        if (this.canvas.width !== this.width && (this.width = this.canvas.width, e = !0), this.canvas.height !== this.height && (this.height = this.canvas.height, e = !0), this._hasInvalidDimensions()) return;\n        if (0 === Object.keys(this.tiles).length) return;\n        const i = this.map.painter.context,\n              o = i.gl;\n        this.boundsBuffer || (this.boundsBuffer = i.createVertexBuffer(this._boundsArray, M.members)), this.boundsSegments || (this.boundsSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2)), this.texture ? (e || this._playing) && this.texture.update(this.canvas, {\n          premultiply: !0\n        }) : this.texture = new m(i, this.canvas, o.RGBA, {\n          premultiply: !0\n        });\n\n        for (const t in this.tiles) {\n          const e = this.tiles[t];\n          \"loaded\" !== e.state && (e.state = \"loaded\", e.texture = this.texture);\n        }\n      }\n\n      serialize() {\n        return {\n          type: \"canvas\",\n          coordinates: this.coordinates\n        };\n      }\n\n      hasTransition() {\n        return this._playing;\n      }\n\n      _hasInvalidDimensions() {\n        for (const t of [this.canvas.width, this.canvas.height]) if (isNaN(t) || t <= 0) return !0;\n\n        return !1;\n      }\n\n    }\n\n    const B = {\n      vector: C,\n      raster: P,\n      \"raster-dem\": D,\n      geojson: A,\n      video: R,\n      image: L,\n      canvas: k\n    };\n\n    function F(e, i) {\n      const o = t.create();\n      return t.translate(o, o, [1, 1, 0]), t.scale(o, o, [.5 * e.width, .5 * e.height, 1]), t.multiply(o, o, e.calculatePosMatrix(i.toUnwrapped()));\n    }\n\n    function O(t, e, i, o, a, s) {\n      const r = function (t, e, i) {\n        if (t) for (const o of t) {\n          const t = e[o];\n          if (t && t.source === i && \"fill-extrusion\" === t.type) return !0;\n        } else for (const t in e) {\n          const o = e[t];\n          if (o.source === i && \"fill-extrusion\" === o.type) return !0;\n        }\n        return !1;\n      }(a && a.layers, e, t.id),\n            n = s.maxPitchScaleFactor(),\n            l = t.tilesIn(o, n, r);\n\n      l.sort(U);\n      const c = [];\n\n      for (const o of l) c.push({\n        wrappedTileID: o.tileID.wrapped().key,\n        queryResults: o.tile.queryRenderedFeatures(e, i, t._state, o.queryGeometry, o.cameraQueryGeometry, o.scale, a, s, n, F(t.transform, o.tileID))\n      });\n\n      const h = function (t) {\n        const e = {},\n              i = {};\n\n        for (const o of t) {\n          const t = o.queryResults,\n                a = o.wrappedTileID,\n                s = i[a] = i[a] || {};\n\n          for (const i in t) {\n            const o = t[i],\n                  a = s[i] = s[i] || {},\n                  r = e[i] = e[i] || [];\n\n            for (const t of o) a[t.featureIndex] || (a[t.featureIndex] = !0, r.push(t));\n          }\n        }\n\n        return e;\n      }(c);\n\n      for (const e in h) h[e].forEach(e => {\n        const i = e.feature,\n              o = t.getFeatureState(i.layer[\"source-layer\"], i.id);\n        i.source = i.layer.source, i.layer[\"source-layer\"] && (i.sourceLayer = i.layer[\"source-layer\"]), i.state = o;\n      });\n\n      return h;\n    }\n\n    function U(t, e) {\n      const i = t.tileID,\n            o = e.tileID;\n      return i.overscaledZ - o.overscaledZ || i.canonical.y - o.canonical.y || i.wrap - o.wrap || i.canonical.x - o.canonical.x;\n    }\n\n    class N {\n      constructor(e, i) {\n        this.tileID = e, this.uid = t.uniqueId(), this.uses = 0, this.tileSize = i, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = !1, this.hasRTLText = !1, this.dependencies = {}, this.expiredRequestCount = 0, this.state = \"loading\";\n      }\n\n      registerFadeDuration(e) {\n        const i = e + this.timeAdded;\n        i < t.exported.now() || this.fadeEndTime && i < this.fadeEndTime || (this.fadeEndTime = i);\n      }\n\n      wasRequested() {\n        return \"errored\" === this.state || \"loaded\" === this.state || \"reloading\" === this.state;\n      }\n\n      loadVectorData(e, i, o) {\n        if (this.hasData() && this.unloadVectorData(), this.state = \"loaded\", e) {\n          e.featureIndex && (this.latestFeatureIndex = e.featureIndex, e.rawTileData ? (this.latestRawTileData = e.rawTileData, this.latestFeatureIndex.rawTileData = e.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = e.collisionBoxArray, this.buckets = function (t, e) {\n            const i = {};\n            if (!e) return i;\n\n            for (const o of t) {\n              const t = o.layerIds.map(t => e.getLayer(t)).filter(Boolean);\n\n              if (0 !== t.length) {\n                o.layers = t, o.stateDependentLayerIds && (o.stateDependentLayers = o.stateDependentLayerIds.map(e => t.filter(t => t.id === e)[0]));\n\n                for (const e of t) i[e.id] = o;\n              }\n            }\n\n            return i;\n          }(e.buckets, i.style), this.hasSymbolBuckets = !1;\n\n          for (const e in this.buckets) {\n            const i = this.buckets[e];\n\n            if (i instanceof t.SymbolBucket) {\n              if (this.hasSymbolBuckets = !0, !o) break;\n              i.justReloaded = !0;\n            }\n          }\n\n          if (this.hasRTLText = !1, this.hasSymbolBuckets) for (const e in this.buckets) {\n            const i = this.buckets[e];\n\n            if (i instanceof t.SymbolBucket && i.hasRTLText) {\n              this.hasRTLText = !0, t.lazyLoadRTLTextPlugin();\n              break;\n            }\n          }\n          this.queryPadding = 0;\n\n          for (const t in this.buckets) {\n            const e = this.buckets[t];\n            this.queryPadding = Math.max(this.queryPadding, i.style.getLayer(t).queryRadius(e));\n          }\n\n          e.imageAtlas && (this.imageAtlas = e.imageAtlas), e.glyphAtlasImage && (this.glyphAtlasImage = e.glyphAtlasImage);\n        } else this.collisionBoxArray = new t.CollisionBoxArray();\n      }\n\n      unloadVectorData() {\n        for (const t in this.buckets) this.buckets[t].destroy();\n\n        this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.latestFeatureIndex = null, this.state = \"unloaded\";\n      }\n\n      getBucket(t) {\n        return this.buckets[t.id];\n      }\n\n      upload(t) {\n        for (const e in this.buckets) {\n          const i = this.buckets[e];\n          i.uploadPending() && i.upload(t);\n        }\n\n        const e = t.gl;\n        this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new m(t, this.imageAtlas.image, e.RGBA), this.imageAtlas.uploaded = !0), this.glyphAtlasImage && (this.glyphAtlasTexture = new m(t, this.glyphAtlasImage, e.ALPHA), this.glyphAtlasImage = null);\n      }\n\n      prepare(t) {\n        this.imageAtlas && this.imageAtlas.patchUpdatedImages(t, this.imageAtlasTexture);\n      }\n\n      queryRenderedFeatures(t, e, i, o, a, s, r, n, l, c) {\n        return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({\n          queryGeometry: o,\n          cameraQueryGeometry: a,\n          scale: s,\n          tileSize: this.tileSize,\n          pixelPosMatrix: c,\n          transform: n,\n          params: r,\n          queryPadding: this.queryPadding * l\n        }, t, e, i) : {};\n      }\n\n      querySourceFeatures(e, i) {\n        const o = this.latestFeatureIndex;\n        if (!o || !o.rawTileData) return;\n        const a = o.loadVTLayers(),\n              s = i ? i.sourceLayer : \"\",\n              r = a._geojsonTileLayer || a[s];\n        if (!r) return;\n        const n = t.createFilter(i && i.filter),\n              {\n          z: l,\n          x: c,\n          y: h\n        } = this.tileID.canonical,\n              u = {\n          z: l,\n          x: c,\n          y: h\n        };\n\n        for (let i = 0; i < r.length; i++) {\n          const a = r.feature(i);\n\n          if (n.needGeometry) {\n            const e = t.toEvaluationFeature(a, !0);\n            if (!n.filter(new t.EvaluationParameters(this.tileID.overscaledZ), e, this.tileID.canonical)) continue;\n          } else if (!n.filter(new t.EvaluationParameters(this.tileID.overscaledZ), a)) continue;\n\n          const d = o.getId(a, s),\n                m = new t.GeoJSONFeature(a, l, c, h, d);\n          m.tile = u, e.push(m);\n        }\n      }\n\n      hasData() {\n        return \"loaded\" === this.state || \"reloading\" === this.state || \"expired\" === this.state;\n      }\n\n      patternsLoaded() {\n        return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;\n      }\n\n      setExpiryData(e) {\n        const i = this.expirationTime;\n\n        if (e.cacheControl) {\n          const i = t.parseCacheControl(e.cacheControl);\n          i[\"max-age\"] && (this.expirationTime = Date.now() + 1e3 * i[\"max-age\"]);\n        } else e.expires && (this.expirationTime = new Date(e.expires).getTime());\n\n        if (this.expirationTime) {\n          const t = Date.now();\n          let e = !1;\n          if (this.expirationTime > t) e = !1;else if (i) {\n            if (this.expirationTime < i) e = !0;else {\n              const o = this.expirationTime - i;\n              o ? this.expirationTime = t + Math.max(o, 3e4) : e = !0;\n            }\n          } else e = !0;\n          e ? (this.expiredRequestCount++, this.state = \"expired\") : this.expiredRequestCount = 0;\n        }\n      }\n\n      getExpiryTimeout() {\n        if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - new Date().getTime(), Math.pow(2, 31) - 1);\n      }\n\n      setFeatureState(t, e) {\n        if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || 0 === Object.keys(t).length) return;\n        const i = this.latestFeatureIndex.loadVTLayers();\n\n        for (const o in this.buckets) {\n          if (!e.style.hasLayer(o)) continue;\n          const a = this.buckets[o],\n                s = a.layers[0].sourceLayer || \"_geojsonTileLayer\",\n                r = i[s],\n                n = t[s];\n          if (!r || !n || 0 === Object.keys(n).length) continue;\n          a.update(n, r, this.imageAtlas && this.imageAtlas.patternPositions || {});\n          const l = e && e.style && e.style.getLayer(o);\n          l && (this.queryPadding = Math.max(this.queryPadding, l.queryRadius(a)));\n        }\n      }\n\n      holdingForFade() {\n        return void 0 !== this.symbolFadeHoldUntil;\n      }\n\n      symbolFadeFinished() {\n        return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < t.exported.now();\n      }\n\n      clearFadeHold() {\n        this.symbolFadeHoldUntil = void 0;\n      }\n\n      setHoldDuration(e) {\n        this.symbolFadeHoldUntil = t.exported.now() + e;\n      }\n\n      setDependencies(t, e) {\n        const i = {};\n\n        for (const t of e) i[t] = !0;\n\n        this.dependencies[t] = i;\n      }\n\n      hasDependency(t, e) {\n        for (const i of t) {\n          const t = this.dependencies[i];\n          if (t) for (const i of e) if (t[i]) return !0;\n        }\n\n        return !1;\n      }\n\n    }\n\n    class G {\n      constructor(t, e) {\n        this.max = t, this.onRemove = e, this.reset();\n      }\n\n      reset() {\n        for (const t in this.data) for (const e of this.data[t]) e.timeout && clearTimeout(e.timeout), this.onRemove(e.value);\n\n        return this.data = {}, this.order = [], this;\n      }\n\n      add(t, e, i) {\n        const o = t.wrapped().key;\n        void 0 === this.data[o] && (this.data[o] = []);\n        const a = {\n          value: e,\n          timeout: void 0\n        };\n\n        if (void 0 !== i && (a.timeout = setTimeout(() => {\n          this.remove(t, a);\n        }, i)), this.data[o].push(a), this.order.push(o), this.order.length > this.max) {\n          const t = this._getAndRemoveByKey(this.order[0]);\n\n          t && this.onRemove(t);\n        }\n\n        return this;\n      }\n\n      has(t) {\n        return t.wrapped().key in this.data;\n      }\n\n      getAndRemove(t) {\n        return this.has(t) ? this._getAndRemoveByKey(t.wrapped().key) : null;\n      }\n\n      _getAndRemoveByKey(t) {\n        const e = this.data[t].shift();\n        return e.timeout && clearTimeout(e.timeout), 0 === this.data[t].length && delete this.data[t], this.order.splice(this.order.indexOf(t), 1), e.value;\n      }\n\n      getByKey(t) {\n        const e = this.data[t];\n        return e ? e[0].value : null;\n      }\n\n      get(t) {\n        return this.has(t) ? this.data[t.wrapped().key][0].value : null;\n      }\n\n      remove(t, e) {\n        if (!this.has(t)) return this;\n        const i = t.wrapped().key,\n              o = void 0 === e ? 0 : this.data[i].indexOf(e),\n              a = this.data[i][o];\n        return this.data[i].splice(o, 1), a.timeout && clearTimeout(a.timeout), 0 === this.data[i].length && delete this.data[i], this.onRemove(a.value), this.order.splice(this.order.indexOf(i), 1), this;\n      }\n\n      setMaxSize(t) {\n        for (this.max = t; this.order.length > this.max;) {\n          const t = this._getAndRemoveByKey(this.order[0]);\n\n          t && this.onRemove(t);\n        }\n\n        return this;\n      }\n\n      filter(t) {\n        const e = [];\n\n        for (const i in this.data) for (const o of this.data[i]) t(o.value) || e.push(o);\n\n        for (const t of e) this.remove(t.value.tileID, t);\n      }\n\n    }\n\n    class Z {\n      constructor() {\n        this.state = {}, this.stateChanges = {}, this.deletedStates = {};\n      }\n\n      updateState(e, i, o) {\n        const a = String(i);\n\n        if (this.stateChanges[e] = this.stateChanges[e] || {}, this.stateChanges[e][a] = this.stateChanges[e][a] || {}, t.extend(this.stateChanges[e][a], o), null === this.deletedStates[e]) {\n          this.deletedStates[e] = {};\n\n          for (const t in this.state[e]) t !== a && (this.deletedStates[e][t] = null);\n        } else if (this.deletedStates[e] && null === this.deletedStates[e][a]) {\n          this.deletedStates[e][a] = {};\n\n          for (const t in this.state[e][a]) o[t] || (this.deletedStates[e][a][t] = null);\n        } else for (const t in o) this.deletedStates[e] && this.deletedStates[e][a] && null === this.deletedStates[e][a][t] && delete this.deletedStates[e][a][t];\n      }\n\n      removeFeatureState(t, e, i) {\n        if (null === this.deletedStates[t]) return;\n        const o = String(e);\n        if (this.deletedStates[t] = this.deletedStates[t] || {}, i && void 0 !== e) null !== this.deletedStates[t][o] && (this.deletedStates[t][o] = this.deletedStates[t][o] || {}, this.deletedStates[t][o][i] = null);else if (void 0 !== e) {\n          if (this.stateChanges[t] && this.stateChanges[t][o]) for (i in this.deletedStates[t][o] = {}, this.stateChanges[t][o]) this.deletedStates[t][o][i] = null;else this.deletedStates[t][o] = null;\n        } else this.deletedStates[t] = null;\n      }\n\n      getState(e, i) {\n        const o = String(i),\n              a = t.extend({}, (this.state[e] || {})[o], (this.stateChanges[e] || {})[o]);\n        if (null === this.deletedStates[e]) return {};\n\n        if (this.deletedStates[e]) {\n          const t = this.deletedStates[e][i];\n          if (null === t) return {};\n\n          for (const e in t) delete a[e];\n        }\n\n        return a;\n      }\n\n      initializeTileState(t, e) {\n        t.setFeatureState(this.state, e);\n      }\n\n      coalesceChanges(e, i) {\n        const o = {};\n\n        for (const e in this.stateChanges) {\n          this.state[e] = this.state[e] || {};\n          const i = {};\n\n          for (const o in this.stateChanges[e]) this.state[e][o] || (this.state[e][o] = {}), t.extend(this.state[e][o], this.stateChanges[e][o]), i[o] = this.state[e][o];\n\n          o[e] = i;\n        }\n\n        for (const e in this.deletedStates) {\n          this.state[e] = this.state[e] || {};\n          const i = {};\n          if (null === this.deletedStates[e]) for (const t in this.state[e]) i[t] = {}, this.state[e][t] = {};else for (const t in this.deletedStates[e]) {\n            if (null === this.deletedStates[e][t]) this.state[e][t] = {};else for (const i of Object.keys(this.deletedStates[e][t])) delete this.state[e][t][i];\n            i[t] = this.state[e][t];\n          }\n          o[e] = o[e] || {}, t.extend(o[e], i);\n        }\n\n        if (this.stateChanges = {}, this.deletedStates = {}, 0 !== Object.keys(o).length) for (const t in e) e[t].setFeatureState(o, i);\n      }\n\n    }\n\n    class q extends t.Evented {\n      constructor(e, i, o) {\n        super(), this.id = e, this.dispatcher = o, this.on(\"data\", t => {\n          \"source\" === t.dataType && \"metadata\" === t.sourceDataType && (this._sourceLoaded = !0), this._sourceLoaded && !this._paused && \"source\" === t.dataType && \"content\" === t.sourceDataType && (this.reload(), this.transform && this.update(this.transform));\n        }), this.on(\"error\", () => {\n          this._sourceErrored = !0;\n        }), this._source = function (e, i, o, a) {\n          const s = new B[i.type](e, i, o, a);\n          if (s.id !== e) throw new Error(`Expected Source id to be ${e} instead of ${s.id}`);\n          return t.bindAll([\"load\", \"abort\", \"unload\", \"serialize\", \"prepare\"], s), s;\n        }(e, i, o, this), this._tiles = {}, this._cache = new G(0, this._unloadTile.bind(this)), this._timers = {}, this._cacheTimers = {}, this._maxTileCacheSize = null, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new Z();\n      }\n\n      onAdd(t) {\n        this.map = t, this._maxTileCacheSize = t ? t._maxTileCacheSize : null, this._source && this._source.onAdd && this._source.onAdd(t);\n      }\n\n      onRemove(t) {\n        this._source && this._source.onRemove && this._source.onRemove(t);\n      }\n\n      loaded() {\n        if (this._sourceErrored) return !0;\n        if (!this._sourceLoaded) return !1;\n        if (!this._source.loaded()) return !1;\n\n        for (const t in this._tiles) {\n          const e = this._tiles[t];\n          if (\"loaded\" !== e.state && \"errored\" !== e.state) return !1;\n        }\n\n        return !0;\n      }\n\n      getSource() {\n        return this._source;\n      }\n\n      pause() {\n        this._paused = !0;\n      }\n\n      resume() {\n        if (!this._paused) return;\n        const t = this._shouldReloadOnResume;\n        this._paused = !1, this._shouldReloadOnResume = !1, t && this.reload(), this.transform && this.update(this.transform);\n      }\n\n      _loadTile(t, e) {\n        return this._source.loadTile(t, e);\n      }\n\n      _unloadTile(t) {\n        if (this._source.unloadTile) return this._source.unloadTile(t, () => {});\n      }\n\n      _abortTile(e) {\n        this._source.abortTile && this._source.abortTile(e, () => {}), this._source.fire(new t.Event(\"dataabort\", {\n          tile: e,\n          coord: e.tileID,\n          dataType: \"source\"\n        }));\n      }\n\n      serialize() {\n        return this._source.serialize();\n      }\n\n      prepare(t) {\n        this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);\n\n        for (const e in this._tiles) {\n          const i = this._tiles[e];\n          i.upload(t), i.prepare(this.map.style.imageManager);\n        }\n      }\n\n      getIds() {\n        return Object.values(this._tiles).map(t => t.tileID).sort(V).map(t => t.key);\n      }\n\n      getRenderableIds(e) {\n        const i = [];\n\n        for (const t in this._tiles) this._isIdRenderable(t, e) && i.push(this._tiles[t]);\n\n        return e ? i.sort((e, i) => {\n          const o = e.tileID,\n                a = i.tileID,\n                s = new t.pointGeometry(o.canonical.x, o.canonical.y)._rotate(this.transform.angle),\n                r = new t.pointGeometry(a.canonical.x, a.canonical.y)._rotate(this.transform.angle);\n\n          return o.overscaledZ - a.overscaledZ || r.y - s.y || r.x - s.x;\n        }).map(t => t.tileID.key) : i.map(t => t.tileID).sort(V).map(t => t.key);\n      }\n\n      hasRenderableParent(t) {\n        const e = this.findLoadedParent(t, 0);\n        return !!e && this._isIdRenderable(e.tileID.key);\n      }\n\n      _isIdRenderable(t, e) {\n        return this._tiles[t] && this._tiles[t].hasData() && !this._coveredTiles[t] && (e || !this._tiles[t].holdingForFade());\n      }\n\n      reload() {\n        if (this._paused) this._shouldReloadOnResume = !0;else {\n          this._cache.reset();\n\n          for (const t in this._tiles) \"errored\" !== this._tiles[t].state && this._reloadTile(t, \"reloading\");\n        }\n      }\n\n      _reloadTile(t, e) {\n        const i = this._tiles[t];\n        i && (\"loading\" !== i.state && (i.state = e), this._loadTile(i, this._tileLoaded.bind(this, i, t, e)));\n      }\n\n      _tileLoaded(e, i, o, a) {\n        if (a) return e.state = \"errored\", void (404 !== a.status ? this._source.fire(new t.ErrorEvent(a, {\n          tile: e\n        })) : this.update(this.transform));\n        e.timeAdded = t.exported.now(), \"expired\" === o && (e.refreshedUponExpiration = !0), this._setTileReloadTimer(i, e), \"raster-dem\" === this.getSource().type && e.dem && this._backfillDEM(e), this._state.initializeTileState(e, this.map ? this.map.painter : null), this._source.fire(new t.Event(\"data\", {\n          dataType: \"source\",\n          tile: e,\n          coord: e.tileID\n        }));\n      }\n\n      _backfillDEM(t) {\n        const e = this.getRenderableIds();\n\n        for (let o = 0; o < e.length; o++) {\n          const a = e[o];\n\n          if (t.neighboringTiles && t.neighboringTiles[a]) {\n            const e = this.getTileByID(a);\n            i(t, e), i(e, t);\n          }\n        }\n\n        function i(t, e) {\n          t.needsHillshadePrepare = !0;\n          let i = e.tileID.canonical.x - t.tileID.canonical.x;\n          const o = e.tileID.canonical.y - t.tileID.canonical.y,\n                a = Math.pow(2, t.tileID.canonical.z),\n                s = e.tileID.key;\n          0 === i && 0 === o || Math.abs(o) > 1 || (Math.abs(i) > 1 && (1 === Math.abs(i + a) ? i += a : 1 === Math.abs(i - a) && (i -= a)), e.dem && t.dem && (t.dem.backfillBorder(e.dem, i, o), t.neighboringTiles && t.neighboringTiles[s] && (t.neighboringTiles[s].backfilled = !0)));\n        }\n      }\n\n      getTile(t) {\n        return this.getTileByID(t.key);\n      }\n\n      getTileByID(t) {\n        return this._tiles[t];\n      }\n\n      _retainLoadedChildren(t, e, i, o) {\n        for (const a in this._tiles) {\n          let s = this._tiles[a];\n          if (o[a] || !s.hasData() || s.tileID.overscaledZ <= e || s.tileID.overscaledZ > i) continue;\n          let r = s.tileID;\n\n          for (; s && s.tileID.overscaledZ > e + 1;) {\n            const t = s.tileID.scaledTo(s.tileID.overscaledZ - 1);\n            s = this._tiles[t.key], s && s.hasData() && (r = t);\n          }\n\n          let n = r;\n\n          for (; n.overscaledZ > e;) if (n = n.scaledTo(n.overscaledZ - 1), t[n.key]) {\n            o[r.key] = r;\n            break;\n          }\n        }\n      }\n\n      findLoadedParent(t, e) {\n        if (t.key in this._loadedParentTiles) {\n          const i = this._loadedParentTiles[t.key];\n          return i && i.tileID.overscaledZ >= e ? i : null;\n        }\n\n        for (let i = t.overscaledZ - 1; i >= e; i--) {\n          const e = t.scaledTo(i),\n                o = this._getLoadedTile(e);\n\n          if (o) return o;\n        }\n      }\n\n      _getLoadedTile(t) {\n        const e = this._tiles[t.key];\n        return e && e.hasData() ? e : this._cache.getByKey(t.wrapped().key);\n      }\n\n      updateCacheSize(t) {\n        const e = Math.ceil(t.width / this._source.tileSize) + 1,\n              i = Math.ceil(t.height / this._source.tileSize) + 1,\n              o = Math.floor(e * i * 5),\n              a = \"number\" == typeof this._maxTileCacheSize ? Math.min(this._maxTileCacheSize, o) : o;\n\n        this._cache.setMaxSize(a);\n      }\n\n      handleWrapJump(t) {\n        const e = Math.round((t - (void 0 === this._prevLng ? t : this._prevLng)) / 360);\n\n        if (this._prevLng = t, e) {\n          const t = {};\n\n          for (const i in this._tiles) {\n            const o = this._tiles[i];\n            o.tileID = o.tileID.unwrapTo(o.tileID.wrap + e), t[o.tileID.key] = o;\n          }\n\n          this._tiles = t;\n\n          for (const t in this._timers) clearTimeout(this._timers[t]), delete this._timers[t];\n\n          for (const t in this._tiles) this._setTileReloadTimer(t, this._tiles[t]);\n        }\n      }\n\n      update(e) {\n        if (this.transform = e, !this._sourceLoaded || this._paused) return;\n        let i;\n        this.updateCacheSize(e), this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used ? this._source.tileID ? i = e.getVisibleUnwrappedCoordinates(this._source.tileID).map(e => new t.OverscaledTileID(e.canonical.z, e.wrap, e.canonical.z, e.canonical.x, e.canonical.y)) : (i = e.coveringTiles({\n          tileSize: this._source.tileSize,\n          minzoom: this._source.minzoom,\n          maxzoom: this._source.maxzoom,\n          roundZoom: this._source.roundZoom,\n          reparseOverscaled: this._source.reparseOverscaled\n        }), this._source.hasTile && (i = i.filter(t => this._source.hasTile(t)))) : i = [];\n\n        const o = e.coveringZoomLevel(this._source),\n              a = Math.max(o - q.maxOverzooming, this._source.minzoom),\n              s = Math.max(o + q.maxUnderzooming, this._source.minzoom),\n              r = this._updateRetainedTiles(i, o);\n\n        if (j(this._source.type)) {\n          const e = {},\n                i = {},\n                n = Object.keys(r);\n\n          for (const o of n) {\n            const s = r[o],\n                  n = this._tiles[o];\n            if (!n || n.fadeEndTime && n.fadeEndTime <= t.exported.now()) continue;\n            const l = this.findLoadedParent(s, a);\n            l && (this._addTile(l.tileID), e[l.tileID.key] = l.tileID), i[o] = s;\n          }\n\n          this._retainLoadedChildren(i, o, s, r);\n\n          for (const t in e) r[t] || (this._coveredTiles[t] = !0, r[t] = e[t]);\n        }\n\n        for (const t in r) this._tiles[t].clearFadeHold();\n\n        const n = t.keysDifference(this._tiles, r);\n\n        for (const t of n) {\n          const e = this._tiles[t];\n          e.hasSymbolBuckets && !e.holdingForFade() ? e.setHoldDuration(this.map._fadeDuration) : e.hasSymbolBuckets && !e.symbolFadeFinished() || this._removeTile(t);\n        }\n\n        this._updateLoadedParentTileCache();\n      }\n\n      releaseSymbolFadeTiles() {\n        for (const t in this._tiles) this._tiles[t].holdingForFade() && this._removeTile(t);\n      }\n\n      _updateRetainedTiles(t, e) {\n        const i = {},\n              o = {},\n              a = Math.max(e - q.maxOverzooming, this._source.minzoom),\n              s = Math.max(e + q.maxUnderzooming, this._source.minzoom),\n              r = {};\n\n        for (const o of t) {\n          const t = this._addTile(o);\n\n          i[o.key] = o, t.hasData() || e < this._source.maxzoom && (r[o.key] = o);\n        }\n\n        this._retainLoadedChildren(r, e, s, i);\n\n        for (const s of t) {\n          let t = this._tiles[s.key];\n          if (t.hasData()) continue;\n\n          if (e + 1 > this._source.maxzoom) {\n            const t = s.children(this._source.maxzoom)[0],\n                  e = this.getTile(t);\n\n            if (e && e.hasData()) {\n              i[t.key] = t;\n              continue;\n            }\n          } else {\n            const t = s.children(this._source.maxzoom);\n            if (i[t[0].key] && i[t[1].key] && i[t[2].key] && i[t[3].key]) continue;\n          }\n\n          let r = t.wasRequested();\n\n          for (let e = s.overscaledZ - 1; e >= a; --e) {\n            const a = s.scaledTo(e);\n            if (o[a.key]) break;\n            if (o[a.key] = !0, t = this.getTile(a), !t && r && (t = this._addTile(a)), t && (i[a.key] = a, r = t.wasRequested(), t.hasData())) break;\n          }\n        }\n\n        return i;\n      }\n\n      _updateLoadedParentTileCache() {\n        this._loadedParentTiles = {};\n\n        for (const t in this._tiles) {\n          const e = [];\n          let i,\n              o = this._tiles[t].tileID;\n\n          for (; o.overscaledZ > 0;) {\n            if (o.key in this._loadedParentTiles) {\n              i = this._loadedParentTiles[o.key];\n              break;\n            }\n\n            e.push(o.key);\n            const t = o.scaledTo(o.overscaledZ - 1);\n            if (i = this._getLoadedTile(t), i) break;\n            o = t;\n          }\n\n          for (const t of e) this._loadedParentTiles[t] = i;\n        }\n      }\n\n      _addTile(e) {\n        let i = this._tiles[e.key];\n        if (i) return i;\n        i = this._cache.getAndRemove(e), i && (this._setTileReloadTimer(e.key, i), i.tileID = e, this._state.initializeTileState(i, this.map ? this.map.painter : null), this._cacheTimers[e.key] && (clearTimeout(this._cacheTimers[e.key]), delete this._cacheTimers[e.key], this._setTileReloadTimer(e.key, i)));\n        const o = i;\n        return i || (i = new N(e, this._source.tileSize * e.overscaleFactor()), this._loadTile(i, this._tileLoaded.bind(this, i, e.key, i.state))), i.uses++, this._tiles[e.key] = i, o || this._source.fire(new t.Event(\"dataloading\", {\n          tile: i,\n          coord: i.tileID,\n          dataType: \"source\"\n        })), i;\n      }\n\n      _setTileReloadTimer(t, e) {\n        t in this._timers && (clearTimeout(this._timers[t]), delete this._timers[t]);\n        const i = e.getExpiryTimeout();\n        i && (this._timers[t] = setTimeout(() => {\n          this._reloadTile(t, \"expired\"), delete this._timers[t];\n        }, i));\n      }\n\n      _removeTile(t) {\n        const e = this._tiles[t];\n        e && (e.uses--, delete this._tiles[t], this._timers[t] && (clearTimeout(this._timers[t]), delete this._timers[t]), e.uses > 0 || (e.hasData() && \"reloading\" !== e.state ? this._cache.add(e.tileID, e, e.getExpiryTimeout()) : (e.aborted = !0, this._abortTile(e), this._unloadTile(e))));\n      }\n\n      clearTiles() {\n        this._shouldReloadOnResume = !1, this._paused = !1;\n\n        for (const t in this._tiles) this._removeTile(t);\n\n        this._cache.reset();\n      }\n\n      tilesIn(e, i, o) {\n        const a = [],\n              s = this.transform;\n        if (!s) return a;\n        const r = o ? s.getCameraQueryGeometry(e) : e,\n              n = e.map(t => s.pointCoordinate(t)),\n              l = r.map(t => s.pointCoordinate(t)),\n              c = this.getIds();\n        let h = 1 / 0,\n            u = 1 / 0,\n            d = -1 / 0,\n            m = -1 / 0;\n\n        for (const t of l) h = Math.min(h, t.x), u = Math.min(u, t.y), d = Math.max(d, t.x), m = Math.max(m, t.y);\n\n        for (let e = 0; e < c.length; e++) {\n          const o = this._tiles[c[e]];\n          if (o.holdingForFade()) continue;\n\n          const r = o.tileID,\n                _ = Math.pow(2, s.zoom - o.tileID.overscaledZ),\n                p = i * o.queryPadding * t.EXTENT / o.tileSize / _,\n                f = [r.getTilePoint(new t.MercatorCoordinate(h, u)), r.getTilePoint(new t.MercatorCoordinate(d, m))];\n\n          if (f[0].x - p < t.EXTENT && f[0].y - p < t.EXTENT && f[1].x + p >= 0 && f[1].y + p >= 0) {\n            const t = n.map(t => r.getTilePoint(t)),\n                  e = l.map(t => r.getTilePoint(t));\n            a.push({\n              tile: o,\n              tileID: r,\n              queryGeometry: t,\n              cameraQueryGeometry: e,\n              scale: _\n            });\n          }\n        }\n\n        return a;\n      }\n\n      getVisibleCoordinates(t) {\n        const e = this.getRenderableIds(t).map(t => this._tiles[t].tileID);\n\n        for (const t of e) t.posMatrix = this.transform.calculatePosMatrix(t.toUnwrapped());\n\n        return e;\n      }\n\n      hasTransition() {\n        if (this._source.hasTransition()) return !0;\n        if (j(this._source.type)) for (const e in this._tiles) {\n          const i = this._tiles[e];\n          if (void 0 !== i.fadeEndTime && i.fadeEndTime >= t.exported.now()) return !0;\n        }\n        return !1;\n      }\n\n      setFeatureState(t, e, i) {\n        this._state.updateState(t = t || \"_geojsonTileLayer\", e, i);\n      }\n\n      removeFeatureState(t, e, i) {\n        this._state.removeFeatureState(t = t || \"_geojsonTileLayer\", e, i);\n      }\n\n      getFeatureState(t, e) {\n        return this._state.getState(t = t || \"_geojsonTileLayer\", e);\n      }\n\n      setDependencies(t, e, i) {\n        const o = this._tiles[t];\n        o && o.setDependencies(e, i);\n      }\n\n      reloadTilesForDependencies(t, e) {\n        for (const i in this._tiles) this._tiles[i].hasDependency(t, e) && this._reloadTile(i, \"reloading\");\n\n        this._cache.filter(i => !i.hasDependency(t, e));\n      }\n\n    }\n\n    function V(t, e) {\n      const i = Math.abs(2 * t.wrap) - +(t.wrap < 0),\n            o = Math.abs(2 * e.wrap) - +(e.wrap < 0);\n      return t.overscaledZ - e.overscaledZ || o - i || e.canonical.y - t.canonical.y || e.canonical.x - t.canonical.x;\n    }\n\n    function j(t) {\n      return \"raster\" === t || \"image\" === t || \"video\" === t;\n    }\n\n    q.maxOverzooming = 10, q.maxUnderzooming = 3;\n    const $ = \"mapboxgl_preloaded_worker_pool\";\n\n    class W {\n      constructor() {\n        this.active = {};\n      }\n\n      acquire(t) {\n        if (!this.workers) for (this.workers = []; this.workers.length < W.workerCount;) this.workers.push(new Worker(ya.workerUrl));\n        return this.active[t] = !0, this.workers.slice();\n      }\n\n      release(t) {\n        delete this.active[t], 0 === this.numActive() && (this.workers.forEach(t => {\n          t.terminate();\n        }), this.workers = null);\n      }\n\n      isPreloaded() {\n        return !!this.active[$];\n      }\n\n      numActive() {\n        return Object.keys(this.active).length;\n      }\n\n    }\n\n    const X = Math.floor(t.exported.hardwareConcurrency / 2);\n    let H;\n\n    function K() {\n      return H || (H = new W()), H;\n    }\n\n    function Y(e, i) {\n      const o = {};\n\n      for (const t in e) \"ref\" !== t && (o[t] = e[t]);\n\n      return t.refProperties.forEach(t => {\n        t in i && (o[t] = i[t]);\n      }), o;\n    }\n\n    function J(t) {\n      t = t.slice();\n      const e = Object.create(null);\n\n      for (let i = 0; i < t.length; i++) e[t[i].id] = t[i];\n\n      for (let i = 0; i < t.length; i++) \"ref\" in t[i] && (t[i] = Y(t[i], e[t[i].ref]));\n\n      return t;\n    }\n\n    W.workerCount = Math.max(Math.min(X, 6), 1);\n    const Q = {\n      setStyle: \"setStyle\",\n      addLayer: \"addLayer\",\n      removeLayer: \"removeLayer\",\n      setPaintProperty: \"setPaintProperty\",\n      setLayoutProperty: \"setLayoutProperty\",\n      setFilter: \"setFilter\",\n      addSource: \"addSource\",\n      removeSource: \"removeSource\",\n      setGeoJSONSourceData: \"setGeoJSONSourceData\",\n      setLayerZoomRange: \"setLayerZoomRange\",\n      setLayerProperty: \"setLayerProperty\",\n      setCenter: \"setCenter\",\n      setZoom: \"setZoom\",\n      setBearing: \"setBearing\",\n      setPitch: \"setPitch\",\n      setSprite: \"setSprite\",\n      setGlyphs: \"setGlyphs\",\n      setTransition: \"setTransition\",\n      setLight: \"setLight\"\n    };\n\n    function tt(t, e, i) {\n      i.push({\n        command: Q.addSource,\n        args: [t, e[t]]\n      });\n    }\n\n    function et(t, e, i) {\n      e.push({\n        command: Q.removeSource,\n        args: [t]\n      }), i[t] = !0;\n    }\n\n    function it(t, e, i, o) {\n      et(t, i, o), tt(t, e, i);\n    }\n\n    function ot(t, e, i) {\n      let o;\n\n      for (o in t[i]) if (Object.prototype.hasOwnProperty.call(t[i], o) && \"data\" !== o && !a(t[i][o], e[i][o])) return !1;\n\n      for (o in e[i]) if (Object.prototype.hasOwnProperty.call(e[i], o) && \"data\" !== o && !a(t[i][o], e[i][o])) return !1;\n\n      return !0;\n    }\n\n    function at(t, e, i, o, s, r) {\n      let n;\n\n      for (n in e = e || {}, t = t || {}) Object.prototype.hasOwnProperty.call(t, n) && (a(t[n], e[n]) || i.push({\n        command: r,\n        args: [o, n, e[n], s]\n      }));\n\n      for (n in e) Object.prototype.hasOwnProperty.call(e, n) && !Object.prototype.hasOwnProperty.call(t, n) && (a(t[n], e[n]) || i.push({\n        command: r,\n        args: [o, n, e[n], s]\n      }));\n    }\n\n    function st(t) {\n      return t.id;\n    }\n\n    function rt(t, e) {\n      return t[e.id] = e, t;\n    }\n\n    class nt {\n      constructor(t, e) {\n        this.reset(t, e);\n      }\n\n      reset(t, e) {\n        this.points = t || [], this._distances = [0];\n\n        for (let t = 1; t < this.points.length; t++) this._distances[t] = this._distances[t - 1] + this.points[t].dist(this.points[t - 1]);\n\n        this.length = this._distances[this._distances.length - 1], this.padding = Math.min(e || 0, .5 * this.length), this.paddedLength = this.length - 2 * this.padding;\n      }\n\n      lerp(e) {\n        if (1 === this.points.length) return this.points[0];\n        e = t.clamp(e, 0, 1);\n        let i = 1,\n            o = this._distances[i];\n        const a = e * this.paddedLength + this.padding;\n\n        for (; o < a && i < this._distances.length;) o = this._distances[++i];\n\n        const s = i - 1,\n              r = this._distances[s],\n              n = o - r,\n              l = n > 0 ? (a - r) / n : 0;\n        return this.points[s].mult(1 - l).add(this.points[i].mult(l));\n      }\n\n    }\n\n    function lt(t, e) {\n      let i = !0;\n      return \"always\" === t || \"never\" !== t && \"never\" !== e || (i = !1), i;\n    }\n\n    class ct {\n      constructor(t, e, i) {\n        const o = this.boxCells = [],\n              a = this.circleCells = [];\n        this.xCellCount = Math.ceil(t / i), this.yCellCount = Math.ceil(e / i);\n\n        for (let t = 0; t < this.xCellCount * this.yCellCount; t++) o.push([]), a.push([]);\n\n        this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = t, this.height = e, this.xScale = this.xCellCount / t, this.yScale = this.yCellCount / e, this.boxUid = 0, this.circleUid = 0;\n      }\n\n      keysLength() {\n        return this.boxKeys.length + this.circleKeys.length;\n      }\n\n      insert(t, e, i, o, a) {\n        this._forEachCell(e, i, o, a, this._insertBoxCell, this.boxUid++), this.boxKeys.push(t), this.bboxes.push(e), this.bboxes.push(i), this.bboxes.push(o), this.bboxes.push(a);\n      }\n\n      insertCircle(t, e, i, o) {\n        this._forEachCell(e - o, i - o, e + o, i + o, this._insertCircleCell, this.circleUid++), this.circleKeys.push(t), this.circles.push(e), this.circles.push(i), this.circles.push(o);\n      }\n\n      _insertBoxCell(t, e, i, o, a, s) {\n        this.boxCells[a].push(s);\n      }\n\n      _insertCircleCell(t, e, i, o, a, s) {\n        this.circleCells[a].push(s);\n      }\n\n      _query(t, e, i, o, a, s, r) {\n        if (i < 0 || t > this.width || o < 0 || e > this.height) return [];\n        const n = [];\n\n        if (t <= 0 && e <= 0 && this.width <= i && this.height <= o) {\n          if (a) return [{\n            key: null,\n            x1: t,\n            y1: e,\n            x2: i,\n            y2: o\n          }];\n\n          for (let t = 0; t < this.boxKeys.length; t++) n.push({\n            key: this.boxKeys[t],\n            x1: this.bboxes[4 * t],\n            y1: this.bboxes[4 * t + 1],\n            x2: this.bboxes[4 * t + 2],\n            y2: this.bboxes[4 * t + 3]\n          });\n\n          for (let t = 0; t < this.circleKeys.length; t++) {\n            const e = this.circles[3 * t],\n                  i = this.circles[3 * t + 1],\n                  o = this.circles[3 * t + 2];\n            n.push({\n              key: this.circleKeys[t],\n              x1: e - o,\n              y1: i - o,\n              x2: e + o,\n              y2: i + o\n            });\n          }\n        } else this._forEachCell(t, e, i, o, this._queryCell, n, {\n          hitTest: a,\n          overlapMode: s,\n          seenUids: {\n            box: {},\n            circle: {}\n          }\n        }, r);\n\n        return n;\n      }\n\n      query(t, e, i, o) {\n        return this._query(t, e, i, o, !1, null);\n      }\n\n      hitTest(t, e, i, o, a, s) {\n        return this._query(t, e, i, o, !0, a, s).length > 0;\n      }\n\n      hitTestCircle(t, e, i, o, a) {\n        const s = t - i,\n              r = t + i,\n              n = e - i,\n              l = e + i;\n        if (r < 0 || s > this.width || l < 0 || n > this.height) return !1;\n        const c = [];\n        return this._forEachCell(s, n, r, l, this._queryCellCircle, c, {\n          hitTest: !0,\n          overlapMode: o,\n          circle: {\n            x: t,\n            y: e,\n            radius: i\n          },\n          seenUids: {\n            box: {},\n            circle: {}\n          }\n        }, a), c.length > 0;\n      }\n\n      _queryCell(t, e, i, o, a, s, r, n) {\n        const {\n          seenUids: l,\n          hitTest: c,\n          overlapMode: h\n        } = r,\n              u = this.boxCells[a];\n\n        if (null !== u) {\n          const a = this.bboxes;\n\n          for (const r of u) if (!l.box[r]) {\n            l.box[r] = !0;\n            const u = 4 * r,\n                  d = this.boxKeys[r];\n            if (t <= a[u + 2] && e <= a[u + 3] && i >= a[u + 0] && o >= a[u + 1] && (!n || n(d)) && (!c || !lt(h, d.overlapMode)) && (s.push({\n              key: d,\n              x1: a[u],\n              y1: a[u + 1],\n              x2: a[u + 2],\n              y2: a[u + 3]\n            }), c)) return !0;\n          }\n        }\n\n        const d = this.circleCells[a];\n\n        if (null !== d) {\n          const a = this.circles;\n\n          for (const r of d) if (!l.circle[r]) {\n            l.circle[r] = !0;\n            const u = 3 * r,\n                  d = this.circleKeys[r];\n\n            if (this._circleAndRectCollide(a[u], a[u + 1], a[u + 2], t, e, i, o) && (!n || n(d)) && (!c || !lt(h, d.overlapMode))) {\n              const t = a[u],\n                    e = a[u + 1],\n                    i = a[u + 2];\n              if (s.push({\n                key: d,\n                x1: t - i,\n                y1: e - i,\n                x2: t + i,\n                y2: e + i\n              }), c) return !0;\n            }\n          }\n        }\n\n        return !1;\n      }\n\n      _queryCellCircle(t, e, i, o, a, s, r, n) {\n        const {\n          circle: l,\n          seenUids: c,\n          overlapMode: h\n        } = r,\n              u = this.boxCells[a];\n\n        if (null !== u) {\n          const t = this.bboxes;\n\n          for (const e of u) if (!c.box[e]) {\n            c.box[e] = !0;\n            const i = 4 * e,\n                  o = this.boxKeys[e];\n            if (this._circleAndRectCollide(l.x, l.y, l.radius, t[i + 0], t[i + 1], t[i + 2], t[i + 3]) && (!n || n(o)) && !lt(h, o.overlapMode)) return s.push(!0), !0;\n          }\n        }\n\n        const d = this.circleCells[a];\n\n        if (null !== d) {\n          const t = this.circles;\n\n          for (const e of d) if (!c.circle[e]) {\n            c.circle[e] = !0;\n            const i = 3 * e,\n                  o = this.circleKeys[e];\n            if (this._circlesCollide(t[i], t[i + 1], t[i + 2], l.x, l.y, l.radius) && (!n || n(o)) && !lt(h, o.overlapMode)) return s.push(!0), !0;\n          }\n        }\n      }\n\n      _forEachCell(t, e, i, o, a, s, r, n) {\n        const l = this._convertToXCellCoord(t),\n              c = this._convertToYCellCoord(e),\n              h = this._convertToXCellCoord(i),\n              u = this._convertToYCellCoord(o);\n\n        for (let d = l; d <= h; d++) for (let l = c; l <= u; l++) if (a.call(this, t, e, i, o, this.xCellCount * l + d, s, r, n)) return;\n      }\n\n      _convertToXCellCoord(t) {\n        return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(t * this.xScale)));\n      }\n\n      _convertToYCellCoord(t) {\n        return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(t * this.yScale)));\n      }\n\n      _circlesCollide(t, e, i, o, a, s) {\n        const r = o - t,\n              n = a - e,\n              l = i + s;\n        return l * l > r * r + n * n;\n      }\n\n      _circleAndRectCollide(t, e, i, o, a, s, r) {\n        const n = (s - o) / 2,\n              l = Math.abs(t - (o + n));\n        if (l > n + i) return !1;\n        const c = (r - a) / 2,\n              h = Math.abs(e - (a + c));\n        if (h > c + i) return !1;\n        if (l <= n || h <= c) return !0;\n        const u = l - n,\n              d = h - c;\n        return u * u + d * d <= i * i;\n      }\n\n    }\n\n    function ht(e, i, o, a, s) {\n      const r = t.create();\n      return i ? (t.scale(r, r, [1 / s, 1 / s, 1]), o || t.rotateZ(r, r, a.angle)) : t.multiply(r, a.labelPlaneMatrix, e), r;\n    }\n\n    function ut(e, i, o, a, s) {\n      if (i) {\n        const i = t.clone(e);\n        return t.scale(i, i, [s, s, 1]), o || t.rotateZ(i, i, -a.angle), i;\n      }\n\n      return a.glCoordMatrix;\n    }\n\n    function dt(e, i) {\n      const o = t.fromValues(e.x, e.y, 0, 1);\n      Tt(o, o, i);\n      const a = o[3];\n      return {\n        point: new t.pointGeometry(o[0] / a, o[1] / a),\n        signedDistanceFromCamera: a\n      };\n    }\n\n    function mt(t, e) {\n      return .5 + t / e * .5;\n    }\n\n    function _t(t, e) {\n      const i = t[0] / t[3],\n            o = t[1] / t[3];\n      return i >= -e[0] && i <= e[0] && o >= -e[1] && o <= e[1];\n    }\n\n    function pt(e, i, o, a, s, r, n, l) {\n      const c = a ? e.textSizeData : e.iconSizeData,\n            h = t.evaluateSizeForZoom(c, o.transform.zoom),\n            u = [256 / o.width * 2 + 1, 256 / o.height * 2 + 1],\n            d = a ? e.text.dynamicLayoutVertexArray : e.icon.dynamicLayoutVertexArray;\n      d.clear();\n\n      const m = e.lineVertexArray,\n            _ = a ? e.text.placedSymbolArray : e.icon.placedSymbolArray,\n            p = o.transform.width / o.transform.height;\n\n      let f = !1;\n\n      for (let a = 0; a < _.length; a++) {\n        const g = _.get(a);\n\n        if (g.hidden || g.writingMode === t.WritingMode.vertical && !f) {\n          wt(g.numGlyphs, d);\n          continue;\n        }\n\n        f = !1;\n        const x = t.fromValues(g.anchorX, g.anchorY, 0, 1);\n\n        if (t.transformMat4(x, x, i), !_t(x, u)) {\n          wt(g.numGlyphs, d);\n          continue;\n        }\n\n        const v = mt(o.transform.cameraToCenterDistance, x[3]),\n              y = t.evaluateSizeForFeature(c, h, g),\n              b = n ? y / v : y * v,\n              w = new t.pointGeometry(g.anchorX, g.anchorY),\n              T = dt(w, s).point,\n              E = {},\n              I = xt(g, b, !1, l, i, s, r, e.glyphOffsetArray, m, d, T, w, E, p);\n        f = I.useVertical, (I.notEnoughRoom || f || I.needsFlipping && xt(g, b, !0, l, i, s, r, e.glyphOffsetArray, m, d, T, w, E, p).notEnoughRoom) && wt(g.numGlyphs, d);\n      }\n\n      a ? e.text.dynamicLayoutVertexBuffer.updateData(d) : e.icon.dynamicLayoutVertexBuffer.updateData(d);\n    }\n\n    function ft(t, e, i, o, a, s, r, n, l, c, h) {\n      const u = n.glyphStartIndex + n.numGlyphs,\n            d = n.lineStartIndex,\n            m = n.lineStartIndex + n.lineLength,\n            _ = e.getoffsetX(n.glyphStartIndex),\n            p = e.getoffsetX(u - 1),\n            f = yt(t * _, i, o, a, s, r, n.segment, d, m, l, c, h);\n\n      if (!f) return null;\n      const g = yt(t * p, i, o, a, s, r, n.segment, d, m, l, c, h);\n      return g ? {\n        first: f,\n        last: g\n      } : null;\n    }\n\n    function gt(e, i, o, a) {\n      return e === t.WritingMode.horizontal && Math.abs(o.y - i.y) > Math.abs(o.x - i.x) * a ? {\n        useVertical: !0\n      } : (e === t.WritingMode.vertical ? i.y < o.y : i.x > o.x) ? {\n        needsFlipping: !0\n      } : null;\n    }\n\n    function xt(e, i, o, a, s, r, n, l, c, h, u, d, m, _) {\n      const p = i / 24,\n            f = e.lineOffsetX * p,\n            g = e.lineOffsetY * p;\n      let x;\n\n      if (e.numGlyphs > 1) {\n        const t = e.glyphStartIndex + e.numGlyphs,\n              i = e.lineStartIndex,\n              s = e.lineStartIndex + e.lineLength,\n              h = ft(p, l, f, g, o, u, d, e, c, r, m);\n        if (!h) return {\n          notEnoughRoom: !0\n        };\n        const v = dt(h.first.point, n).point,\n              y = dt(h.last.point, n).point;\n\n        if (a && !o) {\n          const t = gt(e.writingMode, v, y, _);\n          if (t) return t;\n        }\n\n        x = [h.first];\n\n        for (let a = e.glyphStartIndex + 1; a < t - 1; a++) x.push(yt(p * l.getoffsetX(a), f, g, o, u, d, e.segment, i, s, c, r, m));\n\n        x.push(h.last);\n      } else {\n        if (a && !o) {\n          const i = dt(d, s).point,\n                o = e.lineStartIndex + e.segment + 1,\n                a = new t.pointGeometry(c.getx(o), c.gety(o)),\n                r = dt(a, s),\n                n = r.signedDistanceFromCamera > 0 ? r.point : vt(d, a, i, 1, s),\n                l = gt(e.writingMode, i, n, _);\n          if (l) return l;\n        }\n\n        const i = yt(p * l.getoffsetX(e.glyphStartIndex), f, g, o, u, d, e.segment, e.lineStartIndex, e.lineStartIndex + e.lineLength, c, r, m);\n        if (!i) return {\n          notEnoughRoom: !0\n        };\n        x = [i];\n      }\n\n      for (const e of x) t.addDynamicAttributes(h, e.point, e.angle);\n\n      return {};\n    }\n\n    function vt(t, e, i, o, a) {\n      const s = dt(t.add(t.sub(e)._unit()), a).point,\n            r = i.sub(s);\n      return i.add(r._mult(o / r.mag()));\n    }\n\n    function yt(e, i, o, a, s, r, n, l, c, h, u, d) {\n      const m = a ? e - i : e + i;\n\n      let _ = m > 0 ? 1 : -1,\n          p = 0;\n\n      a && (_ *= -1, p = Math.PI), _ < 0 && (p += Math.PI);\n      let f = _ > 0 ? l + n : l + n + 1,\n          g = s,\n          x = s,\n          v = 0,\n          y = 0;\n      const b = Math.abs(m),\n            w = [];\n\n      for (; v + y <= b;) {\n        if (f += _, f < l || f >= c) return null;\n\n        if (x = g, w.push(g), g = d[f], void 0 === g) {\n          const e = new t.pointGeometry(h.getx(f), h.gety(f)),\n                i = dt(e, u);\n          if (i.signedDistanceFromCamera > 0) g = d[f] = i.point;else {\n            const i = f - _;\n            g = vt(0 === v ? r : new t.pointGeometry(h.getx(i), h.gety(i)), e, x, b - v + 1, u);\n          }\n        }\n\n        v += y, y = x.dist(g);\n      }\n\n      const T = (b - v) / y,\n            E = g.sub(x),\n            I = E.mult(T)._add(x);\n\n      I._add(E._unit()._perp()._mult(o * _));\n\n      const S = p + Math.atan2(g.y - x.y, g.x - x.x);\n      return w.push(I), {\n        point: I,\n        angle: S,\n        path: w\n      };\n    }\n\n    const bt = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);\n\n    function wt(t, e) {\n      for (let i = 0; i < t; i++) {\n        const t = e.length;\n        e.resize(t + 4), e.float32.set(bt, 3 * t);\n      }\n    }\n\n    function Tt(t, e, i) {\n      const o = e[0],\n            a = e[1];\n      return t[0] = i[0] * o + i[4] * a + i[12], t[1] = i[1] * o + i[5] * a + i[13], t[3] = i[3] * o + i[7] * a + i[15], t;\n    }\n\n    const Et = 100;\n\n    class It {\n      constructor(t) {\n        let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new ct(t.width + 200, t.height + 200, 25);\n        let i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new ct(t.width + 200, t.height + 200, 25);\n        this.transform = t, this.grid = e, this.ignoredGrid = i, this.pitchfactor = Math.cos(t._pitch) * t.cameraToCenterDistance, this.screenRightBoundary = t.width + Et, this.screenBottomBoundary = t.height + Et, this.gridRightBoundary = t.width + 200, this.gridBottomBoundary = t.height + 200;\n      }\n\n      placeCollisionBox(t, e, i, o, a) {\n        const s = this.projectAndGetPerspectiveRatio(o, t.anchorPointX, t.anchorPointY),\n              r = i * s.perspectiveRatio,\n              n = t.x1 * r + s.point.x,\n              l = t.y1 * r + s.point.y,\n              c = t.x2 * r + s.point.x,\n              h = t.y2 * r + s.point.y;\n        return !this.isInsideGrid(n, l, c, h) || \"always\" !== e && this.grid.hitTest(n, l, c, h, e, a) ? {\n          box: [],\n          offscreen: !1\n        } : {\n          box: [n, l, c, h],\n          offscreen: this.isOffscreen(n, l, c, h)\n        };\n      }\n\n      placeCollisionCircles(e, i, o, a, s, r, n, l, c, h, u, d, m) {\n        const _ = [],\n              p = new t.pointGeometry(i.anchorX, i.anchorY),\n              f = dt(p, r),\n              g = mt(this.transform.cameraToCenterDistance, f.signedDistanceFromCamera),\n              x = (h ? s / g : s * g) / t.ONE_EM,\n              v = dt(p, n).point,\n              y = ft(x, a, i.lineOffsetX * x, i.lineOffsetY * x, !1, v, p, i, o, n, {});\n        let b = !1,\n            w = !1,\n            T = !0;\n\n        if (y) {\n          const i = .5 * d * g + m,\n                o = new t.pointGeometry(-100, -100),\n                a = new t.pointGeometry(this.screenRightBoundary, this.screenBottomBoundary),\n                s = new nt(),\n                r = y.first,\n                n = y.last;\n          let h = [];\n\n          for (let t = r.path.length - 1; t >= 1; t--) h.push(r.path[t]);\n\n          for (let t = 1; t < n.path.length; t++) h.push(n.path[t]);\n\n          const p = 2.5 * i;\n\n          if (l) {\n            const t = h.map(t => dt(t, l));\n            h = t.some(t => t.signedDistanceFromCamera <= 0) ? [] : t.map(t => t.point);\n          }\n\n          let f = [];\n\n          if (h.length > 0) {\n            const e = h[0].clone(),\n                  i = h[0].clone();\n\n            for (let t = 1; t < h.length; t++) e.x = Math.min(e.x, h[t].x), e.y = Math.min(e.y, h[t].y), i.x = Math.max(i.x, h[t].x), i.y = Math.max(i.y, h[t].y);\n\n            f = e.x >= o.x && i.x <= a.x && e.y >= o.y && i.y <= a.y ? [h] : i.x < o.x || e.x > a.x || i.y < o.y || e.y > a.y ? [] : t.clipLine([h], o.x, o.y, a.x, a.y);\n          }\n\n          for (const t of f) {\n            s.reset(t, .25 * i);\n            let o = 0;\n            o = s.length <= .5 * i ? 1 : Math.ceil(s.paddedLength / p) + 1;\n\n            for (let t = 0; t < o; t++) {\n              const a = t / Math.max(o - 1, 1),\n                    r = s.lerp(a),\n                    n = r.x + Et,\n                    l = r.y + Et;\n\n              _.push(n, l, i, 0);\n\n              const h = n - i,\n                    d = l - i,\n                    m = n + i,\n                    p = l + i;\n              if (T = T && this.isOffscreen(h, d, m, p), w = w || this.isInsideGrid(h, d, m, p), \"always\" !== e && this.grid.hitTestCircle(n, l, i, e, u) && (b = !0, !c)) return {\n                circles: [],\n                offscreen: !1,\n                collisionDetected: b\n              };\n            }\n          }\n        }\n\n        return {\n          circles: !c && b || !w ? [] : _,\n          offscreen: T,\n          collisionDetected: b\n        };\n      }\n\n      queryRenderedSymbols(e) {\n        if (0 === e.length || 0 === this.grid.keysLength() && 0 === this.ignoredGrid.keysLength()) return {};\n        const i = [];\n        let o = 1 / 0,\n            a = 1 / 0,\n            s = -1 / 0,\n            r = -1 / 0;\n\n        for (const n of e) {\n          const e = new t.pointGeometry(n.x + Et, n.y + Et);\n          o = Math.min(o, e.x), a = Math.min(a, e.y), s = Math.max(s, e.x), r = Math.max(r, e.y), i.push(e);\n        }\n\n        const n = this.grid.query(o, a, s, r).concat(this.ignoredGrid.query(o, a, s, r)),\n              l = {},\n              c = {};\n\n        for (const e of n) {\n          const o = e.key;\n          if (void 0 === l[o.bucketInstanceId] && (l[o.bucketInstanceId] = {}), l[o.bucketInstanceId][o.featureIndex]) continue;\n          const a = [new t.pointGeometry(e.x1, e.y1), new t.pointGeometry(e.x2, e.y1), new t.pointGeometry(e.x2, e.y2), new t.pointGeometry(e.x1, e.y2)];\n          t.polygonIntersectsPolygon(i, a) && (l[o.bucketInstanceId][o.featureIndex] = !0, void 0 === c[o.bucketInstanceId] && (c[o.bucketInstanceId] = []), c[o.bucketInstanceId].push(o.featureIndex));\n        }\n\n        return c;\n      }\n\n      insertCollisionBox(t, e, i, o, a, s) {\n        (i ? this.ignoredGrid : this.grid).insert({\n          bucketInstanceId: o,\n          featureIndex: a,\n          collisionGroupID: s,\n          overlapMode: e\n        }, t[0], t[1], t[2], t[3]);\n      }\n\n      insertCollisionCircles(t, e, i, o, a, s) {\n        const r = i ? this.ignoredGrid : this.grid,\n              n = {\n          bucketInstanceId: o,\n          featureIndex: a,\n          collisionGroupID: s,\n          overlapMode: e\n        };\n\n        for (let e = 0; e < t.length; e += 4) r.insertCircle(n, t[e], t[e + 1], t[e + 2]);\n      }\n\n      projectAndGetPerspectiveRatio(e, i, o) {\n        const a = t.fromValues(i, o, 0, 1);\n        return Tt(a, a, e), {\n          point: new t.pointGeometry((a[0] / a[3] + 1) / 2 * this.transform.width + Et, (-a[1] / a[3] + 1) / 2 * this.transform.height + Et),\n          perspectiveRatio: .5 + this.transform.cameraToCenterDistance / a[3] * .5\n        };\n      }\n\n      isOffscreen(t, e, i, o) {\n        return i < Et || t >= this.screenRightBoundary || o < Et || e > this.screenBottomBoundary;\n      }\n\n      isInsideGrid(t, e, i, o) {\n        return i >= 0 && t < this.gridRightBoundary && o >= 0 && e < this.gridBottomBoundary;\n      }\n\n      getViewportMatrix() {\n        const e = t.identity([]);\n        return t.translate(e, e, [-100, -100, 0]), e;\n      }\n\n    }\n\n    function St(e, i, o) {\n      return i * (t.EXTENT / (e.tileSize * Math.pow(2, o - e.tileID.overscaledZ)));\n    }\n\n    class Ct {\n      constructor(t, e, i, o) {\n        this.opacity = t ? Math.max(0, Math.min(1, t.opacity + (t.placed ? e : -e))) : o && i ? 1 : 0, this.placed = i;\n      }\n\n      isHidden() {\n        return 0 === this.opacity && !this.placed;\n      }\n\n    }\n\n    class Pt {\n      constructor(t, e, i, o, a) {\n        this.text = new Ct(t ? t.text : null, e, i, a), this.icon = new Ct(t ? t.icon : null, e, o, a);\n      }\n\n      isHidden() {\n        return this.text.isHidden() && this.icon.isHidden();\n      }\n\n    }\n\n    class zt {\n      constructor(t, e, i) {\n        this.text = t, this.icon = e, this.skipFade = i;\n      }\n\n    }\n\n    class Dt {\n      constructor() {\n        this.invProjMatrix = t.create(), this.viewportMatrix = t.create(), this.circles = [];\n      }\n\n    }\n\n    class At {\n      constructor(t, e, i, o, a) {\n        this.bucketInstanceId = t, this.featureIndex = e, this.sourceLayerIndex = i, this.bucketIndex = o, this.tileID = a;\n      }\n\n    }\n\n    class Mt {\n      constructor(t) {\n        this.crossSourceCollisions = t, this.maxGroupID = 0, this.collisionGroups = {};\n      }\n\n      get(t) {\n        if (this.crossSourceCollisions) return {\n          ID: 0,\n          predicate: null\n        };\n\n        if (!this.collisionGroups[t]) {\n          const e = ++this.maxGroupID;\n          this.collisionGroups[t] = {\n            ID: e,\n            predicate: t => t.collisionGroupID === e\n          };\n        }\n\n        return this.collisionGroups[t];\n      }\n\n    }\n\n    function Lt(e, i, o, a, s) {\n      const {\n        horizontalAlign: r,\n        verticalAlign: n\n      } = t.getAnchorAlignment(e),\n            l = -(r - .5) * i,\n            c = -(n - .5) * o,\n            h = t.evaluateVariableOffset(e, a);\n      return new t.pointGeometry(l + h[0] * s, c + h[1] * s);\n    }\n\n    function Rt(e, i, o, a, s, r) {\n      const {\n        x1: n,\n        x2: l,\n        y1: c,\n        y2: h,\n        anchorPointX: u,\n        anchorPointY: d\n      } = e,\n            m = new t.pointGeometry(i, o);\n      return a && m._rotate(s ? r : -r), {\n        x1: n + m.x,\n        y1: c + m.y,\n        x2: l + m.x,\n        y2: h + m.y,\n        anchorPointX: u,\n        anchorPointY: d\n      };\n    }\n\n    class kt {\n      constructor(t, e, i, o) {\n        this.transform = t.clone(), this.collisionIndex = new It(this.transform), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = !1, this.commitTime = 0, this.fadeDuration = e, this.retainedQueryData = {}, this.collisionGroups = new Mt(i), this.collisionCircleArrays = {}, this.prevPlacement = o, o && (o.prevPlacement = void 0), this.placedOrientations = {};\n      }\n\n      getBucketParts(e, i, o, a) {\n        const s = o.getBucket(i),\n              r = o.latestFeatureIndex;\n        if (!s || !r || i.id !== s.layerIds[0]) return;\n\n        const n = o.collisionBoxArray,\n              l = s.layers[0].layout,\n              c = Math.pow(2, this.transform.zoom - o.tileID.overscaledZ),\n              h = o.tileSize / t.EXTENT,\n              u = this.transform.calculatePosMatrix(o.tileID.toUnwrapped()),\n              d = \"map\" === l.get(\"text-pitch-alignment\"),\n              m = \"map\" === l.get(\"text-rotation-alignment\"),\n              _ = St(o, 1, this.transform.zoom),\n              p = ht(u, d, m, this.transform, _);\n\n        let f = null;\n\n        if (d) {\n          const e = ut(u, d, m, this.transform, _);\n          f = t.multiply([], this.transform.labelPlaneMatrix, e);\n        }\n\n        this.retainedQueryData[s.bucketInstanceId] = new At(s.bucketInstanceId, r, s.sourceLayerIndex, s.index, o.tileID);\n        const g = {\n          bucket: s,\n          layout: l,\n          posMatrix: u,\n          textLabelPlaneMatrix: p,\n          labelToScreenMatrix: f,\n          scale: c,\n          textPixelRatio: h,\n          holdingForFade: o.holdingForFade(),\n          collisionBoxArray: n,\n          partiallyEvaluatedTextSize: t.evaluateSizeForZoom(s.textSizeData, this.transform.zoom),\n          collisionGroup: this.collisionGroups.get(s.sourceID)\n        };\n        if (a) for (const t of s.sortKeyRanges) {\n          const {\n            sortKey: i,\n            symbolInstanceStart: o,\n            symbolInstanceEnd: a\n          } = t;\n          e.push({\n            sortKey: i,\n            symbolInstanceStart: o,\n            symbolInstanceEnd: a,\n            parameters: g\n          });\n        } else e.push({\n          symbolInstanceStart: 0,\n          symbolInstanceEnd: s.symbolInstances.length,\n          parameters: g\n        });\n      }\n\n      attemptAnchorPlacement(t, e, i, o, a, s, r, n, l, c, h, u, d, m, _) {\n        const p = [u.textOffset0, u.textOffset1],\n              f = Lt(t, i, o, p, a),\n              g = this.collisionIndex.placeCollisionBox(Rt(e, f.x, f.y, s, r, this.transform.angle), h, n, l, c.predicate);\n\n        if ((!_ || 0 !== this.collisionIndex.placeCollisionBox(Rt(_, f.x, f.y, s, r, this.transform.angle), h, n, l, c.predicate).box.length) && g.box.length > 0) {\n          let e;\n          return this.prevPlacement && this.prevPlacement.variableOffsets[u.crossTileID] && this.prevPlacement.placements[u.crossTileID] && this.prevPlacement.placements[u.crossTileID].text && (e = this.prevPlacement.variableOffsets[u.crossTileID].anchor), this.variableOffsets[u.crossTileID] = {\n            textOffset: p,\n            width: i,\n            height: o,\n            anchor: t,\n            textBoxScale: a,\n            prevAnchor: e\n          }, this.markUsedJustification(d, t, u, m), d.allowVerticalPlacement && (this.markUsedOrientation(d, m, u), this.placedOrientations[u.crossTileID] = m), {\n            shift: f,\n            placedGlyphBoxes: g\n          };\n        }\n      }\n\n      placeLayerBucketPart(e, i, o) {\n        const {\n          bucket: a,\n          layout: s,\n          posMatrix: r,\n          textLabelPlaneMatrix: n,\n          labelToScreenMatrix: l,\n          textPixelRatio: c,\n          holdingForFade: h,\n          collisionBoxArray: u,\n          partiallyEvaluatedTextSize: d,\n          collisionGroup: m\n        } = e.parameters,\n              _ = s.get(\"text-optional\"),\n              p = s.get(\"icon-optional\"),\n              f = t.getOverlapMode(s, \"text-overlap\", \"text-allow-overlap\"),\n              g = \"always\" === f,\n              x = t.getOverlapMode(s, \"icon-overlap\", \"icon-allow-overlap\"),\n              v = \"always\" === x,\n              y = \"map\" === s.get(\"text-rotation-alignment\"),\n              b = \"map\" === s.get(\"text-pitch-alignment\"),\n              w = \"none\" !== s.get(\"icon-text-fit\"),\n              T = \"viewport-y\" === s.get(\"symbol-z-order\"),\n              E = g && (v || !a.hasIconData() || p),\n              I = v && (g || !a.hasTextData() || _);\n\n        !a.collisionArrays && u && a.deserializeCollisionBoxes(u);\n\n        const S = (e, u) => {\n          if (i[e.crossTileID]) return;\n          if (h) return void (this.placements[e.crossTileID] = new zt(!1, !1, !1));\n          let v = !1,\n              T = !1,\n              S = !0,\n              C = null,\n              P = {\n            box: null,\n            offscreen: null\n          },\n              z = {\n            box: null,\n            offscreen: null\n          },\n              D = null,\n              A = null,\n              M = null,\n              L = 0,\n              R = 0,\n              k = 0;\n          u.textFeatureIndex ? L = u.textFeatureIndex : e.useRuntimeCollisionCircles && (L = e.featureIndex), u.verticalTextFeatureIndex && (R = u.verticalTextFeatureIndex);\n          const B = u.textBox;\n\n          if (B) {\n            const i = i => {\n              let o = t.WritingMode.horizontal;\n\n              if (a.allowVerticalPlacement && !i && this.prevPlacement) {\n                const t = this.prevPlacement.placedOrientations[e.crossTileID];\n                t && (this.placedOrientations[e.crossTileID] = t, o = t, this.markUsedOrientation(a, o, e));\n              }\n\n              return o;\n            },\n                  o = (i, o) => {\n              if (a.allowVerticalPlacement && e.numVerticalGlyphVertices > 0 && u.verticalTextBox) {\n                for (const e of a.writingModes) if (e === t.WritingMode.vertical ? (P = o(), z = P) : P = i(), P && P.box && P.box.length) break;\n              } else P = i();\n            };\n\n            if (s.get(\"text-variable-anchor\")) {\n              let n = s.get(\"text-variable-anchor\");\n\n              if (this.prevPlacement && this.prevPlacement.variableOffsets[e.crossTileID]) {\n                const t = this.prevPlacement.variableOffsets[e.crossTileID];\n                n.indexOf(t.anchor) > 0 && (n = n.filter(e => e !== t.anchor), n.unshift(t.anchor));\n              }\n\n              const l = (t, i, o) => {\n                const s = t.x2 - t.x1,\n                      l = t.y2 - t.y1,\n                      h = e.textBoxScale,\n                      u = w && \"never\" === x ? i : null;\n                let d = {\n                  box: [],\n                  offscreen: !1\n                };\n\n                const _ = \"never\" !== f ? 2 * n.length : n.length;\n\n                for (let i = 0; i < _; ++i) {\n                  const _ = this.attemptAnchorPlacement(n[i % n.length], t, s, l, h, y, b, c, r, m, i >= n.length ? f : \"never\", e, a, o, u);\n\n                  if (_ && (d = _.placedGlyphBoxes, d && d.box && d.box.length)) {\n                    v = !0, C = _.shift;\n                    break;\n                  }\n                }\n\n                return d;\n              };\n\n              o(() => l(B, u.iconBox, t.WritingMode.horizontal), () => {\n                const i = u.verticalTextBox;\n                return a.allowVerticalPlacement && !(P && P.box && P.box.length) && e.numVerticalGlyphVertices > 0 && i ? l(i, u.verticalIconBox, t.WritingMode.vertical) : {\n                  box: null,\n                  offscreen: null\n                };\n              }), P && (v = P.box, S = P.offscreen);\n              const h = i(P && P.box);\n\n              if (!v && this.prevPlacement) {\n                const t = this.prevPlacement.variableOffsets[e.crossTileID];\n                t && (this.variableOffsets[e.crossTileID] = t, this.markUsedJustification(a, t.anchor, e, h));\n              }\n            } else {\n              const s = (t, i) => {\n                const o = this.collisionIndex.placeCollisionBox(t, f, c, r, m.predicate);\n                return o && o.box && o.box.length && (this.markUsedOrientation(a, i, e), this.placedOrientations[e.crossTileID] = i), o;\n              };\n\n              o(() => s(B, t.WritingMode.horizontal), () => {\n                const i = u.verticalTextBox;\n                return a.allowVerticalPlacement && e.numVerticalGlyphVertices > 0 && i ? s(i, t.WritingMode.vertical) : {\n                  box: null,\n                  offscreen: null\n                };\n              }), i(P && P.box && P.box.length);\n            }\n          }\n\n          if (D = P, v = D && D.box && D.box.length > 0, S = D && D.offscreen, e.useRuntimeCollisionCircles) {\n            const i = a.text.placedSymbolArray.get(e.centerJustifiedTextSymbolIndex),\n                  c = t.evaluateSizeForFeature(a.textSizeData, d, i),\n                  h = s.get(\"text-padding\");\n            A = this.collisionIndex.placeCollisionCircles(f, i, a.lineVertexArray, a.glyphOffsetArray, c, r, n, l, o, b, m.predicate, e.collisionCircleDiameter, h), v = g || A.circles.length > 0 && !A.collisionDetected, S = S && A.offscreen;\n          }\n\n          if (u.iconFeatureIndex && (k = u.iconFeatureIndex), u.iconBox) {\n            const t = t => {\n              const e = w && C ? Rt(t, C.x, C.y, y, b, this.transform.angle) : t;\n              return this.collisionIndex.placeCollisionBox(e, x, c, r, m.predicate);\n            };\n\n            z && z.box && z.box.length && u.verticalIconBox ? (M = t(u.verticalIconBox), T = M.box.length > 0) : (M = t(u.iconBox), T = M.box.length > 0), S = S && M.offscreen;\n          }\n\n          const F = _ || 0 === e.numHorizontalGlyphVertices && 0 === e.numVerticalGlyphVertices,\n                O = p || 0 === e.numIconVertices;\n\n          if (F || O ? O ? F || (T = T && v) : v = T && v : T = v = T && v, v && D && D.box && this.collisionIndex.insertCollisionBox(D.box, f, s.get(\"text-ignore-placement\"), a.bucketInstanceId, z && z.box && R ? R : L, m.ID), T && M && this.collisionIndex.insertCollisionBox(M.box, x, s.get(\"icon-ignore-placement\"), a.bucketInstanceId, k, m.ID), A && (v && this.collisionIndex.insertCollisionCircles(A.circles, f, s.get(\"text-ignore-placement\"), a.bucketInstanceId, L, m.ID), o)) {\n            const t = a.bucketInstanceId;\n            let e = this.collisionCircleArrays[t];\n            void 0 === e && (e = this.collisionCircleArrays[t] = new Dt());\n\n            for (let t = 0; t < A.circles.length; t += 4) e.circles.push(A.circles[t + 0]), e.circles.push(A.circles[t + 1]), e.circles.push(A.circles[t + 2]), e.circles.push(A.collisionDetected ? 1 : 0);\n          }\n\n          this.placements[e.crossTileID] = new zt(v || E, T || I, S || a.justReloaded), i[e.crossTileID] = !0;\n        };\n\n        if (T) {\n          const t = a.getSortedSymbolIndexes(this.transform.angle);\n\n          for (let e = t.length - 1; e >= 0; --e) {\n            const i = t[e];\n            S(a.symbolInstances.get(i), a.collisionArrays[i]);\n          }\n        } else for (let t = e.symbolInstanceStart; t < e.symbolInstanceEnd; t++) S(a.symbolInstances.get(t), a.collisionArrays[t]);\n\n        if (o && a.bucketInstanceId in this.collisionCircleArrays) {\n          const e = this.collisionCircleArrays[a.bucketInstanceId];\n          t.invert(e.invProjMatrix, r), e.viewportMatrix = this.collisionIndex.getViewportMatrix();\n        }\n\n        a.justReloaded = !1;\n      }\n\n      markUsedJustification(e, i, o, a) {\n        let s;\n        s = a === t.WritingMode.vertical ? o.verticalPlacedTextSymbolIndex : {\n          left: o.leftJustifiedTextSymbolIndex,\n          center: o.centerJustifiedTextSymbolIndex,\n          right: o.rightJustifiedTextSymbolIndex\n        }[t.getAnchorJustification(i)];\n        const r = [o.leftJustifiedTextSymbolIndex, o.centerJustifiedTextSymbolIndex, o.rightJustifiedTextSymbolIndex, o.verticalPlacedTextSymbolIndex];\n\n        for (const t of r) t >= 0 && (e.text.placedSymbolArray.get(t).crossTileID = s >= 0 && t !== s ? 0 : o.crossTileID);\n      }\n\n      markUsedOrientation(e, i, o) {\n        const a = i === t.WritingMode.horizontal || i === t.WritingMode.horizontalOnly ? i : 0,\n              s = i === t.WritingMode.vertical ? i : 0,\n              r = [o.leftJustifiedTextSymbolIndex, o.centerJustifiedTextSymbolIndex, o.rightJustifiedTextSymbolIndex];\n\n        for (const t of r) e.text.placedSymbolArray.get(t).placedOrientation = a;\n\n        o.verticalPlacedTextSymbolIndex && (e.text.placedSymbolArray.get(o.verticalPlacedTextSymbolIndex).placedOrientation = s);\n      }\n\n      commit(t) {\n        this.commitTime = t, this.zoomAtLastRecencyCheck = this.transform.zoom;\n        const e = this.prevPlacement;\n        let i = !1;\n        this.prevZoomAdjustment = e ? e.zoomAdjustment(this.transform.zoom) : 0;\n        const o = e ? e.symbolFadeChange(t) : 1,\n              a = e ? e.opacities : {},\n              s = e ? e.variableOffsets : {},\n              r = e ? e.placedOrientations : {};\n\n        for (const t in this.placements) {\n          const e = this.placements[t],\n                s = a[t];\n          s ? (this.opacities[t] = new Pt(s, o, e.text, e.icon), i = i || e.text !== s.text.placed || e.icon !== s.icon.placed) : (this.opacities[t] = new Pt(null, o, e.text, e.icon, e.skipFade), i = i || e.text || e.icon);\n        }\n\n        for (const t in a) {\n          const e = a[t];\n\n          if (!this.opacities[t]) {\n            const a = new Pt(e, o, !1, !1);\n            a.isHidden() || (this.opacities[t] = a, i = i || e.text.placed || e.icon.placed);\n          }\n        }\n\n        for (const t in s) this.variableOffsets[t] || !this.opacities[t] || this.opacities[t].isHidden() || (this.variableOffsets[t] = s[t]);\n\n        for (const t in r) this.placedOrientations[t] || !this.opacities[t] || this.opacities[t].isHidden() || (this.placedOrientations[t] = r[t]);\n\n        i ? this.lastPlacementChangeTime = t : \"number\" != typeof this.lastPlacementChangeTime && (this.lastPlacementChangeTime = e ? e.lastPlacementChangeTime : t);\n      }\n\n      updateLayerOpacities(t, e) {\n        const i = {};\n\n        for (const o of e) {\n          const e = o.getBucket(t);\n          e && o.latestFeatureIndex && t.id === e.layerIds[0] && this.updateBucketOpacities(e, i, o.collisionBoxArray);\n        }\n      }\n\n      updateBucketOpacities(e, i, o) {\n        e.hasTextData() && e.text.opacityVertexArray.clear(), e.hasIconData() && e.icon.opacityVertexArray.clear(), e.hasIconCollisionBoxData() && e.iconCollisionBox.collisionVertexArray.clear(), e.hasTextCollisionBoxData() && e.textCollisionBox.collisionVertexArray.clear();\n        const a = e.layers[0].layout,\n              s = new Pt(null, 0, !1, !1, !0),\n              r = a.get(\"text-allow-overlap\"),\n              n = a.get(\"icon-allow-overlap\"),\n              l = a.get(\"text-variable-anchor\"),\n              c = \"map\" === a.get(\"text-rotation-alignment\"),\n              h = \"map\" === a.get(\"text-pitch-alignment\"),\n              u = \"none\" !== a.get(\"icon-text-fit\"),\n              d = new Pt(null, 0, r && (n || !e.hasIconData() || a.get(\"icon-optional\")), n && (r || !e.hasTextData() || a.get(\"text-optional\")), !0);\n        !e.collisionArrays && o && (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) && e.deserializeCollisionBoxes(o);\n\n        const m = (t, e, i) => {\n          for (let o = 0; o < e / 4; o++) t.opacityVertexArray.emplaceBack(i);\n        };\n\n        for (let o = 0; o < e.symbolInstances.length; o++) {\n          const a = e.symbolInstances.get(o),\n                {\n            numHorizontalGlyphVertices: r,\n            numVerticalGlyphVertices: n,\n            crossTileID: _\n          } = a;\n          let p = this.opacities[_];\n          i[_] ? p = s : p || (p = d, this.opacities[_] = p), i[_] = !0;\n          const f = a.numIconVertices > 0,\n                g = this.placedOrientations[a.crossTileID],\n                x = g === t.WritingMode.vertical,\n                v = g === t.WritingMode.horizontal || g === t.WritingMode.horizontalOnly;\n\n          if (r > 0 || n > 0) {\n            const t = Vt(p.text);\n            m(e.text, r, x ? jt : t), m(e.text, n, v ? jt : t);\n            const i = p.text.isHidden();\n            [a.rightJustifiedTextSymbolIndex, a.centerJustifiedTextSymbolIndex, a.leftJustifiedTextSymbolIndex].forEach(t => {\n              t >= 0 && (e.text.placedSymbolArray.get(t).hidden = i || x ? 1 : 0);\n            }), a.verticalPlacedTextSymbolIndex >= 0 && (e.text.placedSymbolArray.get(a.verticalPlacedTextSymbolIndex).hidden = i || v ? 1 : 0);\n            const o = this.variableOffsets[a.crossTileID];\n            o && this.markUsedJustification(e, o.anchor, a, g);\n            const s = this.placedOrientations[a.crossTileID];\n            s && (this.markUsedJustification(e, \"left\", a, s), this.markUsedOrientation(e, s, a));\n          }\n\n          if (f) {\n            const t = Vt(p.icon),\n                  i = !(u && a.verticalPlacedIconSymbolIndex && x);\n            a.placedIconSymbolIndex >= 0 && (m(e.icon, a.numIconVertices, i ? t : jt), e.icon.placedSymbolArray.get(a.placedIconSymbolIndex).hidden = p.icon.isHidden()), a.verticalPlacedIconSymbolIndex >= 0 && (m(e.icon, a.numVerticalIconVertices, i ? jt : t), e.icon.placedSymbolArray.get(a.verticalPlacedIconSymbolIndex).hidden = p.icon.isHidden());\n          }\n\n          if (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) {\n            const i = e.collisionArrays[o];\n\n            if (i) {\n              let o = new t.pointGeometry(0, 0);\n\n              if (i.textBox || i.verticalTextBox) {\n                let t = !0;\n\n                if (l) {\n                  const e = this.variableOffsets[_];\n                  e ? (o = Lt(e.anchor, e.width, e.height, e.textOffset, e.textBoxScale), c && o._rotate(h ? this.transform.angle : -this.transform.angle)) : t = !1;\n                }\n\n                i.textBox && Bt(e.textCollisionBox.collisionVertexArray, p.text.placed, !t || x, o.x, o.y), i.verticalTextBox && Bt(e.textCollisionBox.collisionVertexArray, p.text.placed, !t || v, o.x, o.y);\n              }\n\n              const a = Boolean(!v && i.verticalIconBox);\n              i.iconBox && Bt(e.iconCollisionBox.collisionVertexArray, p.icon.placed, a, u ? o.x : 0, u ? o.y : 0), i.verticalIconBox && Bt(e.iconCollisionBox.collisionVertexArray, p.icon.placed, !a, u ? o.x : 0, u ? o.y : 0);\n            }\n          }\n        }\n\n        if (e.sortFeatures(this.transform.angle), this.retainedQueryData[e.bucketInstanceId] && (this.retainedQueryData[e.bucketInstanceId].featureSortOrder = e.featureSortOrder), e.hasTextData() && e.text.opacityVertexBuffer && e.text.opacityVertexBuffer.updateData(e.text.opacityVertexArray), e.hasIconData() && e.icon.opacityVertexBuffer && e.icon.opacityVertexBuffer.updateData(e.icon.opacityVertexArray), e.hasIconCollisionBoxData() && e.iconCollisionBox.collisionVertexBuffer && e.iconCollisionBox.collisionVertexBuffer.updateData(e.iconCollisionBox.collisionVertexArray), e.hasTextCollisionBoxData() && e.textCollisionBox.collisionVertexBuffer && e.textCollisionBox.collisionVertexBuffer.updateData(e.textCollisionBox.collisionVertexArray), e.bucketInstanceId in this.collisionCircleArrays) {\n          const t = this.collisionCircleArrays[e.bucketInstanceId];\n          e.placementInvProjMatrix = t.invProjMatrix, e.placementViewportMatrix = t.viewportMatrix, e.collisionCircleArray = t.circles, delete this.collisionCircleArrays[e.bucketInstanceId];\n        }\n      }\n\n      symbolFadeChange(t) {\n        return 0 === this.fadeDuration ? 1 : (t - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;\n      }\n\n      zoomAdjustment(t) {\n        return Math.max(0, (this.transform.zoom - t) / 1.5);\n      }\n\n      hasTransitions(t) {\n        return this.stale || t - this.lastPlacementChangeTime < this.fadeDuration;\n      }\n\n      stillRecent(t, e) {\n        const i = this.zoomAtLastRecencyCheck === e ? 1 - this.zoomAdjustment(e) : 1;\n        return this.zoomAtLastRecencyCheck = e, this.commitTime + this.fadeDuration * i > t;\n      }\n\n      setStale() {\n        this.stale = !0;\n      }\n\n    }\n\n    function Bt(t, e, i, o, a) {\n      t.emplaceBack(e ? 1 : 0, i ? 1 : 0, o || 0, a || 0), t.emplaceBack(e ? 1 : 0, i ? 1 : 0, o || 0, a || 0), t.emplaceBack(e ? 1 : 0, i ? 1 : 0, o || 0, a || 0), t.emplaceBack(e ? 1 : 0, i ? 1 : 0, o || 0, a || 0);\n    }\n\n    const Ft = Math.pow(2, 25),\n          Ot = Math.pow(2, 24),\n          Ut = Math.pow(2, 17),\n          Nt = Math.pow(2, 16),\n          Gt = Math.pow(2, 9),\n          Zt = Math.pow(2, 8),\n          qt = Math.pow(2, 1);\n\n    function Vt(t) {\n      if (0 === t.opacity && !t.placed) return 0;\n      if (1 === t.opacity && t.placed) return 4294967295;\n      const e = t.placed ? 1 : 0,\n            i = Math.floor(127 * t.opacity);\n      return i * Ft + e * Ot + i * Ut + e * Nt + i * Gt + e * Zt + i * qt + e;\n    }\n\n    const jt = 0;\n\n    class $t {\n      constructor(t) {\n        this._sortAcrossTiles = \"viewport-y\" !== t.layout.get(\"symbol-z-order\") && !t.layout.get(\"symbol-sort-key\").isConstant(), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [];\n      }\n\n      continuePlacement(t, e, i, o, a) {\n        const s = this._bucketParts;\n\n        for (; this._currentTileIndex < t.length;) if (e.getBucketParts(s, o, t[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, a()) return !0;\n\n        for (this._sortAcrossTiles && (this._sortAcrossTiles = !1, s.sort((t, e) => t.sortKey - e.sortKey)); this._currentPartIndex < s.length;) if (e.placeLayerBucketPart(s[this._currentPartIndex], this._seenCrossTileIDs, i), this._currentPartIndex++, a()) return !0;\n\n        return !1;\n      }\n\n    }\n\n    class Wt {\n      constructor(t, e, i, o, a, s, r) {\n        this.placement = new kt(t, a, s, r), this._currentPlacementIndex = e.length - 1, this._forceFullPlacement = i, this._showCollisionBoxes = o, this._done = !1;\n      }\n\n      isDone() {\n        return this._done;\n      }\n\n      continuePlacement(e, i, o) {\n        const a = t.exported.now(),\n              s = () => {\n          const e = t.exported.now() - a;\n          return !this._forceFullPlacement && e > 2;\n        };\n\n        for (; this._currentPlacementIndex >= 0;) {\n          const t = i[e[this._currentPlacementIndex]],\n                a = this.placement.collisionIndex.transform.zoom;\n\n          if (\"symbol\" === t.type && (!t.minzoom || t.minzoom <= a) && (!t.maxzoom || t.maxzoom > a)) {\n            if (this._inProgressLayer || (this._inProgressLayer = new $t(t)), this._inProgressLayer.continuePlacement(o[t.source], this.placement, this._showCollisionBoxes, t, s)) return;\n            delete this._inProgressLayer;\n          }\n\n          this._currentPlacementIndex--;\n        }\n\n        this._done = !0;\n      }\n\n      commit(t) {\n        return this.placement.commit(t), this.placement;\n      }\n\n    }\n\n    const Xt = 512 / t.EXTENT / 2;\n\n    class Ht {\n      constructor(t, e, i) {\n        this.tileID = t, this.indexedSymbolInstances = {}, this.bucketInstanceId = i;\n\n        for (let i = 0; i < e.length; i++) {\n          const o = e.get(i),\n                a = o.key;\n          this.indexedSymbolInstances[a] || (this.indexedSymbolInstances[a] = []), this.indexedSymbolInstances[a].push({\n            crossTileID: o.crossTileID,\n            coord: this.getScaledCoordinates(o, t)\n          });\n        }\n      }\n\n      getScaledCoordinates(e, i) {\n        const o = Xt / Math.pow(2, i.canonical.z - this.tileID.canonical.z);\n        return {\n          x: Math.floor((i.canonical.x * t.EXTENT + e.anchorX) * o),\n          y: Math.floor((i.canonical.y * t.EXTENT + e.anchorY) * o)\n        };\n      }\n\n      findMatches(t, e, i) {\n        const o = this.tileID.canonical.z < e.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - e.canonical.z);\n\n        for (let a = 0; a < t.length; a++) {\n          const s = t.get(a);\n          if (s.crossTileID) continue;\n          const r = this.indexedSymbolInstances[s.key];\n          if (!r) continue;\n          const n = this.getScaledCoordinates(s, e);\n\n          for (const t of r) if (Math.abs(t.coord.x - n.x) <= o && Math.abs(t.coord.y - n.y) <= o && !i[t.crossTileID]) {\n            i[t.crossTileID] = !0, s.crossTileID = t.crossTileID;\n            break;\n          }\n        }\n      }\n\n    }\n\n    class Kt {\n      constructor() {\n        this.maxCrossTileID = 0;\n      }\n\n      generate() {\n        return ++this.maxCrossTileID;\n      }\n\n    }\n\n    class Yt {\n      constructor() {\n        this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;\n      }\n\n      handleWrapJump(t) {\n        const e = Math.round((t - this.lng) / 360);\n        if (0 !== e) for (const t in this.indexes) {\n          const i = this.indexes[t],\n                o = {};\n\n          for (const t in i) {\n            const a = i[t];\n            a.tileID = a.tileID.unwrapTo(a.tileID.wrap + e), o[a.tileID.key] = a;\n          }\n\n          this.indexes[t] = o;\n        }\n        this.lng = t;\n      }\n\n      addBucket(t, e, i) {\n        if (this.indexes[t.overscaledZ] && this.indexes[t.overscaledZ][t.key]) {\n          if (this.indexes[t.overscaledZ][t.key].bucketInstanceId === e.bucketInstanceId) return !1;\n          this.removeBucketCrossTileIDs(t.overscaledZ, this.indexes[t.overscaledZ][t.key]);\n        }\n\n        for (let t = 0; t < e.symbolInstances.length; t++) e.symbolInstances.get(t).crossTileID = 0;\n\n        this.usedCrossTileIDs[t.overscaledZ] || (this.usedCrossTileIDs[t.overscaledZ] = {});\n        const o = this.usedCrossTileIDs[t.overscaledZ];\n\n        for (const i in this.indexes) {\n          const a = this.indexes[i];\n          if (Number(i) > t.overscaledZ) for (const i in a) {\n            const s = a[i];\n            s.tileID.isChildOf(t) && s.findMatches(e.symbolInstances, t, o);\n          } else {\n            const s = a[t.scaledTo(Number(i)).key];\n            s && s.findMatches(e.symbolInstances, t, o);\n          }\n        }\n\n        for (let t = 0; t < e.symbolInstances.length; t++) {\n          const a = e.symbolInstances.get(t);\n          a.crossTileID || (a.crossTileID = i.generate(), o[a.crossTileID] = !0);\n        }\n\n        return void 0 === this.indexes[t.overscaledZ] && (this.indexes[t.overscaledZ] = {}), this.indexes[t.overscaledZ][t.key] = new Ht(t, e.symbolInstances, e.bucketInstanceId), !0;\n      }\n\n      removeBucketCrossTileIDs(t, e) {\n        for (const i in e.indexedSymbolInstances) for (const o of e.indexedSymbolInstances[i]) delete this.usedCrossTileIDs[t][o.crossTileID];\n      }\n\n      removeStaleBuckets(t) {\n        let e = !1;\n\n        for (const i in this.indexes) {\n          const o = this.indexes[i];\n\n          for (const a in o) t[o[a].bucketInstanceId] || (this.removeBucketCrossTileIDs(i, o[a]), delete o[a], e = !0);\n        }\n\n        return e;\n      }\n\n    }\n\n    class Jt {\n      constructor() {\n        this.layerIndexes = {}, this.crossTileIDs = new Kt(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};\n      }\n\n      addLayer(t, e, i) {\n        let o = this.layerIndexes[t.id];\n        void 0 === o && (o = this.layerIndexes[t.id] = new Yt());\n        let a = !1;\n        const s = {};\n        o.handleWrapJump(i);\n\n        for (const i of e) {\n          const e = i.getBucket(t);\n          e && t.id === e.layerIds[0] && (e.bucketInstanceId || (e.bucketInstanceId = ++this.maxBucketInstanceId), o.addBucket(i.tileID, e, this.crossTileIDs) && (a = !0), s[e.bucketInstanceId] = !0);\n        }\n\n        return o.removeStaleBuckets(s) && (a = !0), a;\n      }\n\n      pruneUnusedLayers(t) {\n        const e = {};\n        t.forEach(t => {\n          e[t] = !0;\n        });\n\n        for (const t in this.layerIndexes) e[t] || delete this.layerIndexes[t];\n      }\n\n    }\n\n    const Qt = (e, i) => t.emitValidationErrors(e, i && i.filter(t => \"source.canvas\" !== t.identifier)),\n          te = t.pick(Q, [\"addLayer\", \"removeLayer\", \"setPaintProperty\", \"setLayoutProperty\", \"setFilter\", \"addSource\", \"removeSource\", \"setLayerZoomRange\", \"setLight\", \"setTransition\", \"setGeoJSONSourceData\"]),\n          ee = t.pick(Q, [\"setCenter\", \"setZoom\", \"setBearing\", \"setPitch\"]),\n          ie = function () {\n      const e = {},\n            i = t.spec.$version;\n\n      for (const o in t.spec.$root) {\n        const a = t.spec.$root[o];\n\n        if (a.required) {\n          let t = null;\n          t = \"version\" === o ? i : \"array\" === a.type ? [] : {}, null != t && (e[o] = t);\n        }\n      }\n\n      return e;\n    }();\n\n    class oe extends t.Evented {\n      constructor(e) {\n        let i = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        super(), this.map = e, this.dispatcher = new E(K(), this), this.imageManager = new p(), this.imageManager.setEventedParent(this), this.glyphManager = new v(e._requestManager, i.localIdeographFontFamily), this.lineAtlas = new T(256, 512), this.crossTileSymbolIndex = new Jt(), this._layers = {}, this._serializedLayers = {}, this._order = [], this.sourceCaches = {}, this.zoomHistory = new t.ZoomHistory(), this._loaded = !1, this._availableImages = [], this._resetUpdates(), this.dispatcher.broadcast(\"setReferrer\", t.getReferrer());\n        const o = this;\n        this._rtlTextPluginCallback = oe.registerForPluginStateChange(e => {\n          o.dispatcher.broadcast(\"syncRTLPluginState\", {\n            pluginStatus: e.pluginStatus,\n            pluginURL: e.pluginURL\n          }, (e, i) => {\n            if (t.triggerPluginCompletionEvent(e), i && i.every(t => t)) for (const t in o.sourceCaches) o.sourceCaches[t].reload();\n          });\n        }), this.on(\"data\", t => {\n          if (\"source\" !== t.dataType || \"metadata\" !== t.sourceDataType) return;\n          const e = this.sourceCaches[t.sourceId];\n          if (!e) return;\n          const i = e.getSource();\n          if (i && i.vectorLayerIds) for (const t in this._layers) {\n            const e = this._layers[t];\n            e.source === i.id && this._validateLayer(e);\n          }\n        });\n      }\n\n      loadURL(e) {\n        let i = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        this.fire(new t.Event(\"dataloading\", {\n          dataType: \"style\"\n        }));\n\n        const o = \"boolean\" != typeof i.validate || i.validate,\n              a = this.map._requestManager.transformRequest(e, t.ResourceType.Style);\n\n        this._request = t.getJSON(a, (e, i) => {\n          this._request = null, e ? this.fire(new t.ErrorEvent(e)) : i && this._load(i, o);\n        });\n      }\n\n      loadJSON(e) {\n        let i = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        this.fire(new t.Event(\"dataloading\", {\n          dataType: \"style\"\n        })), this._request = t.exported.frame(() => {\n          this._request = null, this._load(e, !1 !== i.validate);\n        });\n      }\n\n      loadEmpty() {\n        this.fire(new t.Event(\"dataloading\", {\n          dataType: \"style\"\n        })), this._load(ie, !1);\n      }\n\n      _load(e, i) {\n        if (i && Qt(this, t.validateStyle(e))) return;\n        this._loaded = !0, this.stylesheet = e;\n\n        for (const t in e.sources) this.addSource(t, e.sources[t], {\n          validate: !1\n        });\n\n        e.sprite ? this._loadSprite(e.sprite) : this.imageManager.setLoaded(!0), this.glyphManager.setURL(e.glyphs);\n        const o = J(this.stylesheet.layers);\n        this._order = o.map(t => t.id), this._layers = {}, this._serializedLayers = {};\n\n        for (let e of o) e = t.createStyleLayer(e), e.setEventedParent(this, {\n          layer: {\n            id: e.id\n          }\n        }), this._layers[e.id] = e, this._serializedLayers[e.id] = e.serialize();\n\n        this.dispatcher.broadcast(\"setLayers\", this._serializeLayers(this._order)), this.light = new w(this.stylesheet.light), this.fire(new t.Event(\"data\", {\n          dataType: \"style\"\n        })), this.fire(new t.Event(\"style.load\"));\n      }\n\n      _loadSprite(e) {\n        this._spriteRequest = function (e, i, o, a) {\n          let s, r, n;\n          const l = o > 1 ? \"@2x\" : \"\";\n          let c = t.getJSON(i.transformRequest(i.normalizeSpriteURL(e, l, \".json\"), t.ResourceType.SpriteJSON), (t, e) => {\n            c = null, n || (n = t, s = e, u());\n          }),\n              h = t.getImage(i.transformRequest(i.normalizeSpriteURL(e, l, \".png\"), t.ResourceType.SpriteImage), (t, e) => {\n            h = null, n || (n = t, r = e, u());\n          });\n\n          function u() {\n            if (n) a(n);else if (s && r) {\n              const e = t.exported.getImageData(r),\n                    i = {};\n\n              for (const o in s) {\n                const {\n                  width: a,\n                  height: r,\n                  x: n,\n                  y: l,\n                  sdf: c,\n                  pixelRatio: h,\n                  stretchX: u,\n                  stretchY: d,\n                  content: m\n                } = s[o],\n                      _ = new t.RGBAImage({\n                  width: a,\n                  height: r\n                });\n\n                t.RGBAImage.copy(e, _, {\n                  x: n,\n                  y: l\n                }, {\n                  x: 0,\n                  y: 0\n                }, {\n                  width: a,\n                  height: r\n                }), i[o] = {\n                  data: _,\n                  pixelRatio: h,\n                  sdf: c,\n                  stretchX: u,\n                  stretchY: d,\n                  content: m\n                };\n              }\n\n              a(null, i);\n            }\n          }\n\n          return {\n            cancel() {\n              c && (c.cancel(), c = null), h && (h.cancel(), h = null);\n            }\n\n          };\n        }(e, this.map._requestManager, this.map.getPixelRatio(), (e, i) => {\n          if (this._spriteRequest = null, e) this.fire(new t.ErrorEvent(e));else if (i) for (const t in i) this.imageManager.addImage(t, i[t]);\n          this.imageManager.setLoaded(!0), this._availableImages = this.imageManager.listImages(), this.dispatcher.broadcast(\"setImages\", this._availableImages), this.fire(new t.Event(\"data\", {\n            dataType: \"style\"\n          }));\n        });\n      }\n\n      _validateLayer(e) {\n        const i = this.sourceCaches[e.source];\n        if (!i) return;\n        const o = e.sourceLayer;\n        if (!o) return;\n        const a = i.getSource();\n        (\"geojson\" === a.type || a.vectorLayerIds && -1 === a.vectorLayerIds.indexOf(o)) && this.fire(new t.ErrorEvent(new Error(`Source layer \"${o}\" does not exist on source \"${a.id}\" as specified by style layer \"${e.id}\".`)));\n      }\n\n      loaded() {\n        if (!this._loaded) return !1;\n        if (Object.keys(this._updatedSources).length) return !1;\n\n        for (const t in this.sourceCaches) if (!this.sourceCaches[t].loaded()) return !1;\n\n        return !!this.imageManager.isLoaded();\n      }\n\n      _serializeLayers(t) {\n        const e = [];\n\n        for (const i of t) {\n          const t = this._layers[i];\n          \"custom\" !== t.type && e.push(t.serialize());\n        }\n\n        return e;\n      }\n\n      hasTransitions() {\n        if (this.light && this.light.hasTransition()) return !0;\n\n        for (const t in this.sourceCaches) if (this.sourceCaches[t].hasTransition()) return !0;\n\n        for (const t in this._layers) if (this._layers[t].hasTransition()) return !0;\n\n        return !1;\n      }\n\n      _checkLoaded() {\n        if (!this._loaded) throw new Error(\"Style is not done loading.\");\n      }\n\n      update(e) {\n        if (!this._loaded) return;\n        const i = this._changed;\n\n        if (this._changed) {\n          const t = Object.keys(this._updatedLayers),\n                i = Object.keys(this._removedLayers);\n          (t.length || i.length) && this._updateWorkerLayers(t, i);\n\n          for (const t in this._updatedSources) {\n            const e = this._updatedSources[t];\n            \"reload\" === e ? this._reloadSource(t) : \"clear\" === e && this._clearSource(t);\n          }\n\n          this._updateTilesForChangedImages();\n\n          for (const t in this._updatedPaintProps) this._layers[t].updateTransitions(e);\n\n          this.light.updateTransitions(e), this._resetUpdates();\n        }\n\n        const o = {};\n\n        for (const t in this.sourceCaches) {\n          const e = this.sourceCaches[t];\n          o[t] = e.used, e.used = !1;\n        }\n\n        for (const t of this._order) {\n          const i = this._layers[t];\n          i.recalculate(e, this._availableImages), !i.isHidden(e.zoom) && i.source && (this.sourceCaches[i.source].used = !0);\n        }\n\n        for (const e in o) {\n          const i = this.sourceCaches[e];\n          o[e] !== i.used && i.fire(new t.Event(\"data\", {\n            sourceDataType: \"visibility\",\n            dataType: \"source\",\n            sourceId: e\n          }));\n        }\n\n        this.light.recalculate(e), this.z = e.zoom, i && this.fire(new t.Event(\"data\", {\n          dataType: \"style\"\n        }));\n      }\n\n      _updateTilesForChangedImages() {\n        const t = Object.keys(this._changedImages);\n\n        if (t.length) {\n          for (const e in this.sourceCaches) this.sourceCaches[e].reloadTilesForDependencies([\"icons\", \"patterns\"], t);\n\n          this._changedImages = {};\n        }\n      }\n\n      _updateWorkerLayers(t, e) {\n        this.dispatcher.broadcast(\"updateLayers\", {\n          layers: this._serializeLayers(t),\n          removedIds: e\n        });\n      }\n\n      _resetUpdates() {\n        this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {};\n      }\n\n      setState(e) {\n        if (this._checkLoaded(), Qt(this, t.validateStyle(e))) return !1;\n        (e = t.clone$1(e)).layers = J(e.layers);\n\n        const i = function (t, e) {\n          if (!t) return [{\n            command: Q.setStyle,\n            args: [e]\n          }];\n          let i = [];\n\n          try {\n            if (!a(t.version, e.version)) return [{\n              command: Q.setStyle,\n              args: [e]\n            }];\n            a(t.center, e.center) || i.push({\n              command: Q.setCenter,\n              args: [e.center]\n            }), a(t.zoom, e.zoom) || i.push({\n              command: Q.setZoom,\n              args: [e.zoom]\n            }), a(t.bearing, e.bearing) || i.push({\n              command: Q.setBearing,\n              args: [e.bearing]\n            }), a(t.pitch, e.pitch) || i.push({\n              command: Q.setPitch,\n              args: [e.pitch]\n            }), a(t.sprite, e.sprite) || i.push({\n              command: Q.setSprite,\n              args: [e.sprite]\n            }), a(t.glyphs, e.glyphs) || i.push({\n              command: Q.setGlyphs,\n              args: [e.glyphs]\n            }), a(t.transition, e.transition) || i.push({\n              command: Q.setTransition,\n              args: [e.transition]\n            }), a(t.light, e.light) || i.push({\n              command: Q.setLight,\n              args: [e.light]\n            });\n            const o = {},\n                  s = [];\n            !function (t, e, i, o) {\n              let s;\n\n              for (s in e = e || {}, t = t || {}) Object.prototype.hasOwnProperty.call(t, s) && (Object.prototype.hasOwnProperty.call(e, s) || et(s, i, o));\n\n              for (s in e) Object.prototype.hasOwnProperty.call(e, s) && (Object.prototype.hasOwnProperty.call(t, s) ? a(t[s], e[s]) || (\"geojson\" === t[s].type && \"geojson\" === e[s].type && ot(t, e, s) ? i.push({\n                command: Q.setGeoJSONSourceData,\n                args: [s, e[s].data]\n              }) : it(s, e, i, o)) : tt(s, e, i));\n            }(t.sources, e.sources, s, o);\n            const r = [];\n            t.layers && t.layers.forEach(t => {\n              o[t.source] ? i.push({\n                command: Q.removeLayer,\n                args: [t.id]\n              }) : r.push(t);\n            }), i = i.concat(s), function (t, e, i) {\n              e = e || [];\n              const o = (t = t || []).map(st),\n                    s = e.map(st),\n                    r = t.reduce(rt, {}),\n                    n = e.reduce(rt, {}),\n                    l = o.slice(),\n                    c = Object.create(null);\n\n              let h, u, d, m, _, p, f;\n\n              for (h = 0, u = 0; h < o.length; h++) d = o[h], Object.prototype.hasOwnProperty.call(n, d) ? u++ : (i.push({\n                command: Q.removeLayer,\n                args: [d]\n              }), l.splice(l.indexOf(d, u), 1));\n\n              for (h = 0, u = 0; h < s.length; h++) d = s[s.length - 1 - h], l[l.length - 1 - h] !== d && (Object.prototype.hasOwnProperty.call(r, d) ? (i.push({\n                command: Q.removeLayer,\n                args: [d]\n              }), l.splice(l.lastIndexOf(d, l.length - u), 1)) : u++, p = l[l.length - h], i.push({\n                command: Q.addLayer,\n                args: [n[d], p]\n              }), l.splice(l.length - h, 0, d), c[d] = !0);\n\n              for (h = 0; h < s.length; h++) if (d = s[h], m = r[d], _ = n[d], !c[d] && !a(m, _)) if (a(m.source, _.source) && a(m[\"source-layer\"], _[\"source-layer\"]) && a(m.type, _.type)) {\n                for (f in at(m.layout, _.layout, i, d, null, Q.setLayoutProperty), at(m.paint, _.paint, i, d, null, Q.setPaintProperty), a(m.filter, _.filter) || i.push({\n                  command: Q.setFilter,\n                  args: [d, _.filter]\n                }), a(m.minzoom, _.minzoom) && a(m.maxzoom, _.maxzoom) || i.push({\n                  command: Q.setLayerZoomRange,\n                  args: [d, _.minzoom, _.maxzoom]\n                }), m) Object.prototype.hasOwnProperty.call(m, f) && \"layout\" !== f && \"paint\" !== f && \"filter\" !== f && \"metadata\" !== f && \"minzoom\" !== f && \"maxzoom\" !== f && (0 === f.indexOf(\"paint.\") ? at(m[f], _[f], i, d, f.slice(6), Q.setPaintProperty) : a(m[f], _[f]) || i.push({\n                  command: Q.setLayerProperty,\n                  args: [d, f, _[f]]\n                }));\n\n                for (f in _) Object.prototype.hasOwnProperty.call(_, f) && !Object.prototype.hasOwnProperty.call(m, f) && \"layout\" !== f && \"paint\" !== f && \"filter\" !== f && \"metadata\" !== f && \"minzoom\" !== f && \"maxzoom\" !== f && (0 === f.indexOf(\"paint.\") ? at(m[f], _[f], i, d, f.slice(6), Q.setPaintProperty) : a(m[f], _[f]) || i.push({\n                  command: Q.setLayerProperty,\n                  args: [d, f, _[f]]\n                }));\n              } else i.push({\n                command: Q.removeLayer,\n                args: [d]\n              }), p = l[l.lastIndexOf(d) + 1], i.push({\n                command: Q.addLayer,\n                args: [_, p]\n              });\n            }(r, e.layers, i);\n          } catch (t) {\n            console.warn(\"Unable to compute style diff:\", t), i = [{\n              command: Q.setStyle,\n              args: [e]\n            }];\n          }\n\n          return i;\n        }(this.serialize(), e).filter(t => !(t.command in ee));\n\n        if (0 === i.length) return !1;\n        const o = i.filter(t => !(t.command in te));\n        if (o.length > 0) throw new Error(`Unimplemented: ${o.map(t => t.command).join(\", \")}.`);\n        return i.forEach(t => {\n          \"setTransition\" !== t.command && this[t.command].apply(this, t.args);\n        }), this.stylesheet = e, !0;\n      }\n\n      addImage(e, i) {\n        if (this.getImage(e)) return this.fire(new t.ErrorEvent(new Error(`An image named \"${e}\" already exists.`)));\n        this.imageManager.addImage(e, i), this._afterImageUpdated(e);\n      }\n\n      updateImage(t, e) {\n        this.imageManager.updateImage(t, e);\n      }\n\n      getImage(t) {\n        return this.imageManager.getImage(t);\n      }\n\n      removeImage(e) {\n        if (!this.getImage(e)) return this.fire(new t.ErrorEvent(new Error(`An image named \"${e}\" does not exist.`)));\n        this.imageManager.removeImage(e), this._afterImageUpdated(e);\n      }\n\n      _afterImageUpdated(e) {\n        this._availableImages = this.imageManager.listImages(), this._changedImages[e] = !0, this._changed = !0, this.dispatcher.broadcast(\"setImages\", this._availableImages), this.fire(new t.Event(\"data\", {\n          dataType: \"style\"\n        }));\n      }\n\n      listImages() {\n        return this._checkLoaded(), this.imageManager.listImages();\n      }\n\n      addSource(e, i) {\n        let o = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        if (this._checkLoaded(), void 0 !== this.sourceCaches[e]) throw new Error(`Source \"${e}\" already exists.`);\n        if (!i.type) throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(i).join(\", \")}.`);\n        if ([\"vector\", \"raster\", \"geojson\", \"video\", \"image\"].indexOf(i.type) >= 0 && this._validate(t.validateStyle.source, `sources.${e}`, i, null, o)) return;\n        this.map && this.map._collectResourceTiming && (i.collectResourceTiming = !0);\n        const a = this.sourceCaches[e] = new q(e, i, this.dispatcher);\n        a.style = this, a.setEventedParent(this, () => ({\n          isSourceLoaded: this.loaded(),\n          source: a.serialize(),\n          sourceId: e\n        })), a.onAdd(this.map), this._changed = !0;\n      }\n\n      removeSource(e) {\n        if (this._checkLoaded(), void 0 === this.sourceCaches[e]) throw new Error(\"There is no source with this ID\");\n\n        for (const i in this._layers) if (this._layers[i].source === e) return this.fire(new t.ErrorEvent(new Error(`Source \"${e}\" cannot be removed while layer \"${i}\" is using it.`)));\n\n        const i = this.sourceCaches[e];\n        delete this.sourceCaches[e], delete this._updatedSources[e], i.fire(new t.Event(\"data\", {\n          sourceDataType: \"metadata\",\n          dataType: \"source\",\n          sourceId: e\n        })), i.setEventedParent(null), i.clearTiles(), i.onRemove && i.onRemove(this.map), this._changed = !0;\n      }\n\n      setGeoJSONSourceData(t, e) {\n        this._checkLoaded(), this.sourceCaches[t].getSource().setData(e), this._changed = !0;\n      }\n\n      getSource(t) {\n        return this.sourceCaches[t] && this.sourceCaches[t].getSource();\n      }\n\n      addLayer(e, i) {\n        let o = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n        this._checkLoaded();\n\n        const a = e.id;\n        if (this.getLayer(a)) return void this.fire(new t.ErrorEvent(new Error(`Layer \"${a}\" already exists on this map.`)));\n        let s;\n\n        if (\"custom\" === e.type) {\n          if (Qt(this, t.validateCustomStyleLayer(e))) return;\n          s = t.createStyleLayer(e);\n        } else {\n          if (\"object\" == typeof e.source && (this.addSource(a, e.source), e = t.clone$1(e), e = t.extend(e, {\n            source: a\n          })), this._validate(t.validateStyle.layer, `layers.${a}`, e, {\n            arrayIndex: -1\n          }, o)) return;\n          s = t.createStyleLayer(e), this._validateLayer(s), s.setEventedParent(this, {\n            layer: {\n              id: a\n            }\n          }), this._serializedLayers[s.id] = s.serialize();\n        }\n\n        const r = i ? this._order.indexOf(i) : this._order.length;\n        if (i && -1 === r) this.fire(new t.ErrorEvent(new Error(`Cannot add layer \"${a}\" before non-existing layer \"${i}\".`)));else {\n          if (this._order.splice(r, 0, a), this._layerOrderChanged = !0, this._layers[a] = s, this._removedLayers[a] && s.source && \"custom\" !== s.type) {\n            const t = this._removedLayers[a];\n            delete this._removedLayers[a], t.type !== s.type ? this._updatedSources[s.source] = \"clear\" : (this._updatedSources[s.source] = \"reload\", this.sourceCaches[s.source].pause());\n          }\n\n          this._updateLayer(s), s.onAdd && s.onAdd(this.map);\n        }\n      }\n\n      moveLayer(e, i) {\n        if (this._checkLoaded(), this._changed = !0, !this._layers[e]) return void this.fire(new t.ErrorEvent(new Error(`The layer '${e}' does not exist in the map's style and cannot be moved.`)));\n        if (e === i) return;\n\n        const o = this._order.indexOf(e);\n\n        this._order.splice(o, 1);\n\n        const a = i ? this._order.indexOf(i) : this._order.length;\n        i && -1 === a ? this.fire(new t.ErrorEvent(new Error(`Cannot move layer \"${e}\" before non-existing layer \"${i}\".`))) : (this._order.splice(a, 0, e), this._layerOrderChanged = !0);\n      }\n\n      removeLayer(e) {\n        this._checkLoaded();\n\n        const i = this._layers[e];\n        if (!i) return void this.fire(new t.ErrorEvent(new Error(`Cannot remove non-existing layer \"${e}\".`)));\n        i.setEventedParent(null);\n\n        const o = this._order.indexOf(e);\n\n        this._order.splice(o, 1), this._layerOrderChanged = !0, this._changed = !0, this._removedLayers[e] = i, delete this._layers[e], delete this._serializedLayers[e], delete this._updatedLayers[e], delete this._updatedPaintProps[e], i.onRemove && i.onRemove(this.map);\n      }\n\n      getLayer(t) {\n        return this._layers[t];\n      }\n\n      hasLayer(t) {\n        return t in this._layers;\n      }\n\n      setLayerZoomRange(e, i, o) {\n        this._checkLoaded();\n\n        const a = this.getLayer(e);\n        a ? a.minzoom === i && a.maxzoom === o || (null != i && (a.minzoom = i), null != o && (a.maxzoom = o), this._updateLayer(a)) : this.fire(new t.ErrorEvent(new Error(`Cannot set the zoom range of non-existing layer \"${e}\".`)));\n      }\n\n      setFilter(e, i) {\n        let o = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n        this._checkLoaded();\n\n        const s = this.getLayer(e);\n\n        if (s) {\n          if (!a(s.filter, i)) return null == i ? (s.filter = void 0, void this._updateLayer(s)) : void (this._validate(t.validateStyle.filter, `layers.${s.id}.filter`, i, null, o) || (s.filter = t.clone$1(i), this._updateLayer(s)));\n        } else this.fire(new t.ErrorEvent(new Error(`Cannot filter non-existing layer \"${e}\".`)));\n      }\n\n      getFilter(e) {\n        return t.clone$1(this.getLayer(e).filter);\n      }\n\n      setLayoutProperty(e, i, o) {\n        let s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n        this._checkLoaded();\n\n        const r = this.getLayer(e);\n        r ? a(r.getLayoutProperty(i), o) || (r.setLayoutProperty(i, o, s), this._updateLayer(r)) : this.fire(new t.ErrorEvent(new Error(`Cannot style non-existing layer \"${e}\".`)));\n      }\n\n      getLayoutProperty(e, i) {\n        const o = this.getLayer(e);\n        if (o) return o.getLayoutProperty(i);\n        this.fire(new t.ErrorEvent(new Error(`Cannot get style of non-existing layer \"${e}\".`)));\n      }\n\n      setPaintProperty(e, i, o) {\n        let s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n        this._checkLoaded();\n\n        const r = this.getLayer(e);\n        r ? a(r.getPaintProperty(i), o) || (r.setPaintProperty(i, o, s) && this._updateLayer(r), this._changed = !0, this._updatedPaintProps[e] = !0) : this.fire(new t.ErrorEvent(new Error(`Cannot style non-existing layer \"${e}\".`)));\n      }\n\n      getPaintProperty(t, e) {\n        return this.getLayer(t).getPaintProperty(e);\n      }\n\n      setFeatureState(e, i) {\n        this._checkLoaded();\n\n        const o = e.source,\n              a = e.sourceLayer,\n              s = this.sourceCaches[o];\n        if (void 0 === s) return void this.fire(new t.ErrorEvent(new Error(`The source '${o}' does not exist in the map's style.`)));\n        const r = s.getSource().type;\n        \"geojson\" === r && a ? this.fire(new t.ErrorEvent(new Error(\"GeoJSON sources cannot have a sourceLayer parameter.\"))) : \"vector\" !== r || a ? (void 0 === e.id && this.fire(new t.ErrorEvent(new Error(\"The feature id parameter must be provided.\"))), s.setFeatureState(a, e.id, i)) : this.fire(new t.ErrorEvent(new Error(\"The sourceLayer parameter must be provided for vector source types.\")));\n      }\n\n      removeFeatureState(e, i) {\n        this._checkLoaded();\n\n        const o = e.source,\n              a = this.sourceCaches[o];\n        if (void 0 === a) return void this.fire(new t.ErrorEvent(new Error(`The source '${o}' does not exist in the map's style.`)));\n        const s = a.getSource().type,\n              r = \"vector\" === s ? e.sourceLayer : void 0;\n        \"vector\" !== s || r ? i && \"string\" != typeof e.id && \"number\" != typeof e.id ? this.fire(new t.ErrorEvent(new Error(\"A feature id is required to remove its specific state property.\"))) : a.removeFeatureState(r, e.id, i) : this.fire(new t.ErrorEvent(new Error(\"The sourceLayer parameter must be provided for vector source types.\")));\n      }\n\n      getFeatureState(e) {\n        this._checkLoaded();\n\n        const i = e.source,\n              o = e.sourceLayer,\n              a = this.sourceCaches[i];\n        if (void 0 !== a) return \"vector\" !== a.getSource().type || o ? (void 0 === e.id && this.fire(new t.ErrorEvent(new Error(\"The feature id parameter must be provided.\"))), a.getFeatureState(o, e.id)) : void this.fire(new t.ErrorEvent(new Error(\"The sourceLayer parameter must be provided for vector source types.\")));\n        this.fire(new t.ErrorEvent(new Error(`The source '${i}' does not exist in the map's style.`)));\n      }\n\n      getTransition() {\n        return t.extend({\n          duration: 300,\n          delay: 0\n        }, this.stylesheet && this.stylesheet.transition);\n      }\n\n      serialize() {\n        return t.filterObject({\n          version: this.stylesheet.version,\n          name: this.stylesheet.name,\n          metadata: this.stylesheet.metadata,\n          light: this.stylesheet.light,\n          center: this.stylesheet.center,\n          zoom: this.stylesheet.zoom,\n          bearing: this.stylesheet.bearing,\n          pitch: this.stylesheet.pitch,\n          sprite: this.stylesheet.sprite,\n          glyphs: this.stylesheet.glyphs,\n          transition: this.stylesheet.transition,\n          sources: t.mapObject(this.sourceCaches, t => t.serialize()),\n          layers: this._serializeLayers(this._order)\n        }, t => void 0 !== t);\n      }\n\n      _updateLayer(t) {\n        this._updatedLayers[t.id] = !0, t.source && !this._updatedSources[t.source] && \"raster\" !== this.sourceCaches[t.source].getSource().type && (this._updatedSources[t.source] = \"reload\", this.sourceCaches[t.source].pause()), this._changed = !0;\n      }\n\n      _flattenAndSortRenderedFeatures(t) {\n        const e = t => \"fill-extrusion\" === this._layers[t].type,\n              i = {},\n              o = [];\n\n        for (let a = this._order.length - 1; a >= 0; a--) {\n          const s = this._order[a];\n\n          if (e(s)) {\n            i[s] = a;\n\n            for (const e of t) {\n              const t = e[s];\n              if (t) for (const e of t) o.push(e);\n            }\n          }\n        }\n\n        o.sort((t, e) => e.intersectionZ - t.intersectionZ);\n        const a = [];\n\n        for (let s = this._order.length - 1; s >= 0; s--) {\n          const r = this._order[s];\n          if (e(r)) for (let t = o.length - 1; t >= 0; t--) {\n            const e = o[t].feature;\n            if (i[e.layer.id] < s) break;\n            a.push(e), o.pop();\n          } else for (const e of t) {\n            const t = e[r];\n            if (t) for (const e of t) a.push(e.feature);\n          }\n        }\n\n        return a;\n      }\n\n      queryRenderedFeatures(e, i, o) {\n        i && i.filter && this._validate(t.validateStyle.filter, \"queryRenderedFeatures.filter\", i.filter, null, i);\n        const a = {};\n\n        if (i && i.layers) {\n          if (!Array.isArray(i.layers)) return this.fire(new t.ErrorEvent(new Error(\"parameters.layers must be an Array.\"))), [];\n\n          for (const e of i.layers) {\n            const i = this._layers[e];\n            if (!i) return this.fire(new t.ErrorEvent(new Error(`The layer '${e}' does not exist in the map's style and cannot be queried for features.`))), [];\n            a[i.source] = !0;\n          }\n        }\n\n        const s = [];\n        i.availableImages = this._availableImages;\n\n        for (const t in this.sourceCaches) i.layers && !a[t] || s.push(O(this.sourceCaches[t], this._layers, this._serializedLayers, e, i, o));\n\n        return this.placement && s.push(function (t, e, i, o, a, s, r) {\n          const n = {},\n                l = s.queryRenderedSymbols(o),\n                c = [];\n\n          for (const t of Object.keys(l).map(Number)) c.push(r[t]);\n\n          c.sort(U);\n\n          for (const i of c) {\n            const o = i.featureIndex.lookupSymbolFeatures(l[i.bucketInstanceId], e, i.bucketIndex, i.sourceLayerIndex, a.filter, a.layers, a.availableImages, t);\n\n            for (const t in o) {\n              const e = n[t] = n[t] || [],\n                    a = o[t];\n              a.sort((t, e) => {\n                const o = i.featureSortOrder;\n\n                if (o) {\n                  const i = o.indexOf(t.featureIndex);\n                  return o.indexOf(e.featureIndex) - i;\n                }\n\n                return e.featureIndex - t.featureIndex;\n              });\n\n              for (const t of a) e.push(t);\n            }\n          }\n\n          for (const e in n) n[e].forEach(o => {\n            const a = o.feature,\n                  s = i[t[e].source].getFeatureState(a.layer[\"source-layer\"], a.id);\n            a.source = a.layer.source, a.layer[\"source-layer\"] && (a.sourceLayer = a.layer[\"source-layer\"]), a.state = s;\n          });\n\n          return n;\n        }(this._layers, this._serializedLayers, this.sourceCaches, e, i, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(s);\n      }\n\n      querySourceFeatures(e, i) {\n        i && i.filter && this._validate(t.validateStyle.filter, \"querySourceFeatures.filter\", i.filter, null, i);\n        const o = this.sourceCaches[e];\n        return o ? function (t, e) {\n          const i = t.getRenderableIds().map(e => t.getTileByID(e)),\n                o = [],\n                a = {};\n\n          for (let t = 0; t < i.length; t++) {\n            const s = i[t],\n                  r = s.tileID.canonical.key;\n            a[r] || (a[r] = !0, s.querySourceFeatures(o, e));\n          }\n\n          return o;\n        }(o, i) : [];\n      }\n\n      addSourceType(t, e, i) {\n        return oe.getSourceType(t) ? i(new Error(`A source type called \"${t}\" already exists.`)) : (oe.setSourceType(t, e), e.workerSourceURL ? void this.dispatcher.broadcast(\"loadWorkerSource\", {\n          name: t,\n          url: e.workerSourceURL\n        }, i) : i(null, null));\n      }\n\n      getLight() {\n        return this.light.getLight();\n      }\n\n      setLight(e) {\n        let i = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n        this._checkLoaded();\n\n        const o = this.light.getLight();\n        let s = !1;\n\n        for (const t in e) if (!a(e[t], o[t])) {\n          s = !0;\n          break;\n        }\n\n        if (!s) return;\n        const r = {\n          now: t.exported.now(),\n          transition: t.extend({\n            duration: 300,\n            delay: 0\n          }, this.stylesheet.transition)\n        };\n        this.light.setLight(e, i), this.light.updateTransitions(r);\n      }\n\n      _validate(e, i, o, a) {\n        let s = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n        return (!s || !1 !== s.validate) && Qt(this, e.call(t.validateStyle, t.extend({\n          key: i,\n          style: this.serialize(),\n          value: o,\n          styleSpec: t.spec\n        }, a)));\n      }\n\n      _remove() {\n        this._request && (this._request.cancel(), this._request = null), this._spriteRequest && (this._spriteRequest.cancel(), this._spriteRequest = null), t.evented.off(\"pluginStateChange\", this._rtlTextPluginCallback);\n\n        for (const t in this._layers) this._layers[t].setEventedParent(null);\n\n        for (const t in this.sourceCaches) this.sourceCaches[t].clearTiles(), this.sourceCaches[t].setEventedParent(null);\n\n        this.imageManager.setEventedParent(null), this.setEventedParent(null), this.dispatcher.remove();\n      }\n\n      _clearSource(t) {\n        this.sourceCaches[t].clearTiles();\n      }\n\n      _reloadSource(t) {\n        this.sourceCaches[t].resume(), this.sourceCaches[t].reload();\n      }\n\n      _updateSources(t) {\n        for (const e in this.sourceCaches) this.sourceCaches[e].update(t);\n      }\n\n      _generateCollisionBoxes() {\n        for (const t in this.sourceCaches) this._reloadSource(t);\n      }\n\n      _updatePlacement(e, i, o, a) {\n        let s = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : !1;\n        let r = !1,\n            n = !1;\n        const l = {};\n\n        for (const t of this._order) {\n          const i = this._layers[t];\n          if (\"symbol\" !== i.type) continue;\n\n          if (!l[i.source]) {\n            const t = this.sourceCaches[i.source];\n            l[i.source] = t.getRenderableIds(!0).map(e => t.getTileByID(e)).sort((t, e) => e.tileID.overscaledZ - t.tileID.overscaledZ || (t.tileID.isLessThan(e.tileID) ? -1 : 1));\n          }\n\n          const o = this.crossTileSymbolIndex.addLayer(i, l[i.source], e.center.lng);\n          r = r || o;\n        }\n\n        if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((s = s || this._layerOrderChanged || 0 === o) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(t.exported.now(), e.zoom)) && (this.pauseablePlacement = new Wt(e, this._order, s, i, o, a, this.placement), this._layerOrderChanged = !1), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, l), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(t.exported.now()), n = !0), r && this.pauseablePlacement.placement.setStale()), n || r) for (const t of this._order) {\n          const e = this._layers[t];\n          \"symbol\" === e.type && this.placement.updateLayerOpacities(e, l[e.source]);\n        }\n        return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(t.exported.now());\n      }\n\n      _releaseSymbolFadeTiles() {\n        for (const t in this.sourceCaches) this.sourceCaches[t].releaseSymbolFadeTiles();\n      }\n\n      getImages(t, e, i) {\n        this.imageManager.getImages(e.icons, i), this._updateTilesForChangedImages();\n        const o = this.sourceCaches[e.source];\n        o && o.setDependencies(e.tileID.key, e.type, e.icons);\n      }\n\n      getGlyphs(t, e, i) {\n        this.glyphManager.getGlyphs(e.stacks, i);\n      }\n\n      getResource(e, i, o) {\n        return t.makeRequest(i, o);\n      }\n\n    }\n\n    oe.getSourceType = function (t) {\n      return B[t];\n    }, oe.setSourceType = function (t, e) {\n      B[t] = e;\n    }, oe.registerForPluginStateChange = t.registerForPluginStateChange;\n    var ae = t.createLayout([{\n      name: \"a_pos\",\n      type: \"Int16\",\n      components: 2\n    }]),\n        se = {\n      prelude: re(\"#ifdef GL_ES\\nprecision mediump float;\\n#else\\n#if !defined(lowp)\\n#define lowp\\n#endif\\n#if !defined(mediump)\\n#define mediump\\n#endif\\n#if !defined(highp)\\n#define highp\\n#endif\\n#endif\", \"#ifdef GL_ES\\nprecision highp float;\\n#else\\n#if !defined(lowp)\\n#define lowp\\n#endif\\n#if !defined(mediump)\\n#define mediump\\n#endif\\n#if !defined(highp)\\n#define highp\\n#endif\\n#endif\\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}\"),\n      background: re(\"uniform vec4 u_color;uniform float u_opacity;void main() {gl_FragColor=u_color*u_opacity;\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}\", \"attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}\"),\n      backgroundPattern: re(\"uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_mix)*u_opacity;\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}\", \"uniform mat4 u_matrix;uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}\"),\n      circle: re(\"varying vec3 v_data;\\n#pragma mapbox: define highp vec4 color\\n#pragma mapbox: define mediump float radius\\n#pragma mapbox: define lowp float blur\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define highp vec4 stroke_color\\n#pragma mapbox: define mediump float stroke_width\\n#pragma mapbox: define lowp float stroke_opacity\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 color\\n#pragma mapbox: initialize mediump float radius\\n#pragma mapbox: initialize lowp float blur\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize highp vec4 stroke_color\\n#pragma mapbox: initialize mediump float stroke_width\\n#pragma mapbox: initialize lowp float stroke_opacity\\nvec2 extrude=v_data.xy;float extrude_length=length(extrude);lowp float antialiasblur=v_data.z;float antialiased_blur=-max(blur,antialiasblur);float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));gl_FragColor=opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}\", \"uniform mat4 u_matrix;uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;attribute vec2 a_pos;varying vec3 v_data;\\n#pragma mapbox: define highp vec4 color\\n#pragma mapbox: define mediump float radius\\n#pragma mapbox: define lowp float blur\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define highp vec4 stroke_color\\n#pragma mapbox: define mediump float stroke_width\\n#pragma mapbox: define lowp float stroke_opacity\\nvoid main(void) {\\n#pragma mapbox: initialize highp vec4 color\\n#pragma mapbox: initialize mediump float radius\\n#pragma mapbox: initialize lowp float blur\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize highp vec4 stroke_color\\n#pragma mapbox: initialize mediump float stroke_width\\n#pragma mapbox: initialize lowp float stroke_opacity\\nvec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);if (u_pitch_with_map) {vec2 corner_position=circle_center;if (u_scale_with_map) {corner_position+=extrude*(radius+stroke_width)*u_extrude_scale;} else {vec4 projected_center=u_matrix*vec4(circle_center,0,1);corner_position+=extrude*(radius+stroke_width)*u_extrude_scale*(projected_center.w/u_camera_to_center_distance);}gl_Position=u_matrix*vec4(corner_position,0,1);} else {gl_Position=u_matrix*vec4(circle_center,0,1);if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);}\"),\n      clippingMask: re(\"void main() {gl_FragColor=vec4(1.0);}\", \"attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}\"),\n      heatmap: re(\"uniform highp float u_intensity;varying vec2 v_extrude;\\n#pragma mapbox: define highp float weight\\n#define GAUSS_COEF 0.3989422804014327\\nvoid main() {\\n#pragma mapbox: initialize highp float weight\\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);gl_FragColor=vec4(val,1.0,1.0,1.0);\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}\", \"uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;attribute vec2 a_pos;varying vec2 v_extrude;\\n#pragma mapbox: define highp float weight\\n#pragma mapbox: define mediump float radius\\nconst highp float ZERO=1.0/255.0/16.0;\\n#define GAUSS_COEF 0.3989422804014327\\nvoid main(void) {\\n#pragma mapbox: initialize highp float weight\\n#pragma mapbox: initialize mediump float radius\\nvec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec4 pos=vec4(floor(a_pos*0.5)+extrude,0,1);gl_Position=u_matrix*pos;}\"),\n      heatmapTexture: re(\"uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;varying vec2 v_pos;void main() {float t=texture2D(u_image,v_pos).r;vec4 color=texture2D(u_color_ramp,vec2(t,0.5));gl_FragColor=color*u_opacity;\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(0.0);\\n#endif\\n}\", \"uniform mat4 u_matrix;uniform vec2 u_world;attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}\"),\n      collisionBox: re(\"varying float v_placed;varying float v_notUsed;void main() {float alpha=0.5;gl_FragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {gl_FragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {gl_FragColor*=.1;}}\", \"attribute vec2 a_pos;attribute vec2 a_anchor_pos;attribute vec2 a_extrude;attribute vec2 a_placed;attribute vec2 a_shift;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;varying float v_placed;varying float v_notUsed;void main() {vec4 projectedPoint=u_matrix*vec4(a_anchor_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);gl_Position=u_matrix*vec4(a_pos,0.0,1.0);gl_Position.xy+=(a_extrude+a_shift)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}\"),\n      collisionCircle: re(\"varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);gl_FragColor=color*alpha*opacity_t;}\", \"attribute vec2 a_pos;attribute float a_radius;attribute vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}\"),\n      debug: re(\"uniform highp vec4 u_color;uniform sampler2D u_overlay;varying vec2 v_uv;void main() {vec4 overlay_color=texture2D(u_overlay,v_uv);gl_FragColor=mix(u_color,overlay_color,overlay_color.a);}\", \"attribute vec2 a_pos;varying vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=u_matrix*vec4(a_pos*u_overlay_scale,0,1);}\"),\n      fill: re(\"#pragma mapbox: define highp vec4 color\\n#pragma mapbox: define lowp float opacity\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 color\\n#pragma mapbox: initialize lowp float opacity\\ngl_FragColor=color*opacity;\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}\", \"attribute vec2 a_pos;uniform mat4 u_matrix;\\n#pragma mapbox: define highp vec4 color\\n#pragma mapbox: define lowp float opacity\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 color\\n#pragma mapbox: initialize lowp float opacity\\ngl_Position=u_matrix*vec4(a_pos,0,1);}\"),\n      fillOutline: re(\"varying vec2 v_pos;\\n#pragma mapbox: define highp vec4 outline_color\\n#pragma mapbox: define lowp float opacity\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 outline_color\\n#pragma mapbox: initialize lowp float opacity\\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=outline_color*(alpha*opacity);\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}\", \"attribute vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;varying vec2 v_pos;\\n#pragma mapbox: define highp vec4 outline_color\\n#pragma mapbox: define lowp float opacity\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 outline_color\\n#pragma mapbox: initialize lowp float opacity\\ngl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}\"),\n      fillOutlinePattern: re(\"uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define lowp vec4 pattern_from\\n#pragma mapbox: define lowp vec4 pattern_to\\nvoid main() {\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize mediump vec4 pattern_from\\n#pragma mapbox: initialize mediump vec4 pattern_to\\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=mix(color1,color2,u_fade)*alpha*opacity;\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}\", \"uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define lowp vec4 pattern_from\\n#pragma mapbox: define lowp vec4 pattern_to\\n#pragma mapbox: define lowp float pixel_ratio_from\\n#pragma mapbox: define lowp float pixel_ratio_to\\nvoid main() {\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize mediump vec4 pattern_from\\n#pragma mapbox: initialize mediump vec4 pattern_to\\n#pragma mapbox: initialize lowp float pixel_ratio_from\\n#pragma mapbox: initialize lowp float pixel_ratio_to\\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}\"),\n      fillPattern: re(\"#ifdef GL_ES\\nprecision highp float;\\n#endif\\nuniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define lowp vec4 pattern_from\\n#pragma mapbox: define lowp vec4 pattern_to\\nvoid main() {\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize mediump vec4 pattern_from\\n#pragma mapbox: initialize mediump vec4 pattern_to\\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_fade)*opacity;\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}\", \"uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define lowp vec4 pattern_from\\n#pragma mapbox: define lowp vec4 pattern_to\\n#pragma mapbox: define lowp float pixel_ratio_from\\n#pragma mapbox: define lowp float pixel_ratio_to\\nvoid main() {\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize mediump vec4 pattern_from\\n#pragma mapbox: initialize mediump vec4 pattern_to\\n#pragma mapbox: initialize lowp float pixel_ratio_from\\n#pragma mapbox: initialize lowp float pixel_ratio_to\\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}\"),\n      fillExtrusion: re(\"varying vec4 v_color;void main() {gl_FragColor=v_color;\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}\", \"uniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;attribute vec2 a_pos;attribute vec4 a_normal_ed;varying vec4 v_color;\\n#pragma mapbox: define highp float base\\n#pragma mapbox: define highp float height\\n#pragma mapbox: define highp vec4 color\\nvoid main() {\\n#pragma mapbox: initialize highp float base\\n#pragma mapbox: initialize highp float height\\n#pragma mapbox: initialize highp vec4 color\\nvec3 normal=a_normal_ed.xyz;base=max(0.0,base);height=max(0.0,height);float t=mod(normal.x,2.0);gl_Position=u_matrix*vec4(a_pos,t > 0.0 ? height : base,1);float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;float directional=clamp(dot(normal/16384.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}\"),\n      fillExtrusionPattern: re(\"uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;\\n#pragma mapbox: define lowp float base\\n#pragma mapbox: define lowp float height\\n#pragma mapbox: define lowp vec4 pattern_from\\n#pragma mapbox: define lowp vec4 pattern_to\\n#pragma mapbox: define lowp float pixel_ratio_from\\n#pragma mapbox: define lowp float pixel_ratio_to\\nvoid main() {\\n#pragma mapbox: initialize lowp float base\\n#pragma mapbox: initialize lowp float height\\n#pragma mapbox: initialize mediump vec4 pattern_from\\n#pragma mapbox: initialize mediump vec4 pattern_to\\n#pragma mapbox: initialize lowp float pixel_ratio_from\\n#pragma mapbox: initialize lowp float pixel_ratio_to\\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);gl_FragColor=mixedColor*v_lighting;\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}\", \"uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;attribute vec2 a_pos;attribute vec4 a_normal_ed;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;\\n#pragma mapbox: define lowp float base\\n#pragma mapbox: define lowp float height\\n#pragma mapbox: define lowp vec4 pattern_from\\n#pragma mapbox: define lowp vec4 pattern_to\\n#pragma mapbox: define lowp float pixel_ratio_from\\n#pragma mapbox: define lowp float pixel_ratio_to\\nvoid main() {\\n#pragma mapbox: initialize lowp float base\\n#pragma mapbox: initialize lowp float height\\n#pragma mapbox: initialize mediump vec4 pattern_from\\n#pragma mapbox: initialize mediump vec4 pattern_to\\n#pragma mapbox: initialize lowp float pixel_ratio_from\\n#pragma mapbox: initialize lowp float pixel_ratio_to\\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;base=max(0.0,base);height=max(0.0,height);float t=mod(normal.x,2.0);float z=t > 0.0 ? height : base;gl_Position=u_matrix*vec4(a_pos,z,1);vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0\\n? a_pos\\n: vec2(edgedistance,z*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}\"),\n      hillshadePrepare: re(\"#ifdef GL_ES\\nprecision highp float;\\n#endif\\nuniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture2D(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))/pow(2.0,exaggeration+(19.2562-u_zoom));gl_FragColor=clamp(vec4(deriv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}\", \"uniform mat4 u_matrix;uniform vec2 u_dimension;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}\"),\n      hillshade: re(\"uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;\\n#define PI 3.141592653589793\\nvoid main() {vec4 pixel=texture2D(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);gl_FragColor=accent_color*(1.0-shade_color.a)+shade_color;\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}\", \"uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;}\"),\n      line: re(\"uniform lowp float u_device_pixel_ratio;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;\\n#pragma mapbox: define highp vec4 color\\n#pragma mapbox: define lowp float blur\\n#pragma mapbox: define lowp float opacity\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 color\\n#pragma mapbox: initialize lowp float blur\\n#pragma mapbox: initialize lowp float opacity\\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);gl_FragColor=color*(alpha*opacity);\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}\", \"\\n#define scale 0.015873016\\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp float v_linesofar;\\n#pragma mapbox: define highp vec4 color\\n#pragma mapbox: define lowp float blur\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define mediump float gapwidth\\n#pragma mapbox: define lowp float offset\\n#pragma mapbox: define mediump float width\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 color\\n#pragma mapbox: initialize lowp float blur\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize mediump float gapwidth\\n#pragma mapbox: initialize lowp float offset\\n#pragma mapbox: initialize mediump float width\\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_width2=vec2(outset,inset);}\"),\n      lineGradient: re(\"uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;varying highp vec2 v_uv;\\n#pragma mapbox: define lowp float blur\\n#pragma mapbox: define lowp float opacity\\nvoid main() {\\n#pragma mapbox: initialize lowp float blur\\n#pragma mapbox: initialize lowp float opacity\\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture2D(u_image,v_uv);gl_FragColor=color*(alpha*opacity);\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}\", \"\\n#define scale 0.015873016\\nattribute vec2 a_pos_normal;attribute vec4 a_data;attribute float a_uv_x;attribute float a_split_index;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp vec2 v_uv;\\n#pragma mapbox: define lowp float blur\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define mediump float gapwidth\\n#pragma mapbox: define lowp float offset\\n#pragma mapbox: define mediump float width\\nvoid main() {\\n#pragma mapbox: initialize lowp float blur\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize mediump float gapwidth\\n#pragma mapbox: initialize lowp float offset\\n#pragma mapbox: initialize mediump float width\\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_width2=vec2(outset,inset);}\"),\n      linePattern: re(\"#ifdef GL_ES\\nprecision highp float;\\n#endif\\nuniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\\n#pragma mapbox: define lowp vec4 pattern_from\\n#pragma mapbox: define lowp vec4 pattern_to\\n#pragma mapbox: define lowp float pixel_ratio_from\\n#pragma mapbox: define lowp float pixel_ratio_to\\n#pragma mapbox: define lowp float blur\\n#pragma mapbox: define lowp float opacity\\nvoid main() {\\n#pragma mapbox: initialize mediump vec4 pattern_from\\n#pragma mapbox: initialize mediump vec4 pattern_to\\n#pragma mapbox: initialize lowp float pixel_ratio_from\\n#pragma mapbox: initialize lowp float pixel_ratio_to\\n#pragma mapbox: initialize lowp float blur\\n#pragma mapbox: initialize lowp float opacity\\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture2D(u_image,pos_a),texture2D(u_image,pos_b),u_fade);gl_FragColor=color*alpha*opacity;\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}\", \"\\n#define scale 0.015873016\\n#define LINE_DISTANCE_SCALE 2.0\\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\\n#pragma mapbox: define lowp float blur\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define lowp float offset\\n#pragma mapbox: define mediump float gapwidth\\n#pragma mapbox: define mediump float width\\n#pragma mapbox: define lowp float floorwidth\\n#pragma mapbox: define lowp vec4 pattern_from\\n#pragma mapbox: define lowp vec4 pattern_to\\n#pragma mapbox: define lowp float pixel_ratio_from\\n#pragma mapbox: define lowp float pixel_ratio_to\\nvoid main() {\\n#pragma mapbox: initialize lowp float blur\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize lowp float offset\\n#pragma mapbox: initialize mediump float gapwidth\\n#pragma mapbox: initialize mediump float width\\n#pragma mapbox: initialize lowp float floorwidth\\n#pragma mapbox: initialize mediump vec4 pattern_from\\n#pragma mapbox: initialize mediump vec4 pattern_to\\n#pragma mapbox: initialize lowp float pixel_ratio_from\\n#pragma mapbox: initialize lowp float pixel_ratio_to\\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}\"),\n      lineSDF: re(\"uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform float u_sdfgamma;uniform float u_mix;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;\\n#pragma mapbox: define highp vec4 color\\n#pragma mapbox: define lowp float blur\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define mediump float width\\n#pragma mapbox: define lowp float floorwidth\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 color\\n#pragma mapbox: initialize lowp float blur\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize mediump float width\\n#pragma mapbox: initialize lowp float floorwidth\\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture2D(u_image,v_tex_a).a;float sdfdist_b=texture2D(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);alpha*=smoothstep(0.5-u_sdfgamma/floorwidth,0.5+u_sdfgamma/floorwidth,sdfdist);gl_FragColor=color*(alpha*opacity);\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}\", \"\\n#define scale 0.015873016\\n#define LINE_DISTANCE_SCALE 2.0\\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_patternscale_a;uniform float u_tex_y_a;uniform vec2 u_patternscale_b;uniform float u_tex_y_b;uniform vec2 u_units_to_pixels;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;\\n#pragma mapbox: define highp vec4 color\\n#pragma mapbox: define lowp float blur\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define mediump float gapwidth\\n#pragma mapbox: define lowp float offset\\n#pragma mapbox: define mediump float width\\n#pragma mapbox: define lowp float floorwidth\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 color\\n#pragma mapbox: initialize lowp float blur\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize mediump float gapwidth\\n#pragma mapbox: initialize lowp float offset\\n#pragma mapbox: initialize mediump float width\\n#pragma mapbox: initialize lowp float floorwidth\\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_tex_a=vec2(a_linesofar*u_patternscale_a.x/floorwidth,normal.y*u_patternscale_a.y+u_tex_y_a);v_tex_b=vec2(a_linesofar*u_patternscale_b.x/floorwidth,normal.y*u_patternscale_b.y+u_tex_y_b);v_width2=vec2(outset,inset);}\"),\n      raster: re(\"uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;varying vec2 v_pos0;varying vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture2D(u_image0,v_pos0);vec4 color1=texture2D(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);gl_FragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}\", \"uniform mat4 u_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;varying vec2 v_pos1;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos0=(((a_texture_pos/8192.0)-0.5)/u_buffer_scale )+0.5;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}\"),\n      symbolIcon: re(\"uniform sampler2D u_texture;varying vec2 v_tex;varying float v_fade_opacity;\\n#pragma mapbox: define lowp float opacity\\nvoid main() {\\n#pragma mapbox: initialize lowp float opacity\\nlowp float alpha=opacity*v_fade_opacity;gl_FragColor=texture2D(u_texture,v_tex)*alpha;\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}\", \"const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;varying vec2 v_tex;varying float v_fade_opacity;\\n#pragma mapbox: define lowp float opacity\\nvoid main() {\\n#pragma mapbox: initialize lowp float opacity\\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\\ncamera_to_anchor_distance/u_camera_to_center_distance :\\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,0.0,1.0);gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0),0.0,1.0);v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;v_fade_opacity=max(0.0,min(1.0,fade_opacity[0]+fade_change));}\"),\n      symbolSDF: re(\"#define SDF_PX 8.0\\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;varying vec2 v_data0;varying vec3 v_data1;\\n#pragma mapbox: define highp vec4 fill_color\\n#pragma mapbox: define highp vec4 halo_color\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define lowp float halo_width\\n#pragma mapbox: define lowp float halo_blur\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 fill_color\\n#pragma mapbox: initialize highp vec4 halo_color\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize lowp float halo_width\\n#pragma mapbox: initialize lowp float halo_blur\\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}\", \"const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;varying vec2 v_data0;varying vec3 v_data1;\\n#pragma mapbox: define highp vec4 fill_color\\n#pragma mapbox: define highp vec4 halo_color\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define lowp float halo_width\\n#pragma mapbox: define lowp float halo_blur\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 fill_color\\n#pragma mapbox: initialize highp vec4 halo_color\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize lowp float halo_width\\n#pragma mapbox: initialize lowp float halo_blur\\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\\ncamera_to_anchor_distance/u_camera_to_center_distance :\\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,0.0,1.0);gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset),0.0,1.0);float gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(1.0,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}\"),\n      symbolTextAndIcon: re(\"#define SDF_PX 8.0\\n#define SDF 1.0\\n#define ICON 0.0\\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;varying vec4 v_data0;varying vec4 v_data1;\\n#pragma mapbox: define highp vec4 fill_color\\n#pragma mapbox: define highp vec4 halo_color\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define lowp float halo_width\\n#pragma mapbox: define lowp float halo_blur\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 fill_color\\n#pragma mapbox: initialize highp vec4 halo_color\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize lowp float halo_width\\n#pragma mapbox: initialize lowp float halo_blur\\nfloat fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;gl_FragColor=texture2D(u_texture_icon,tex_icon)*alpha;\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\nreturn;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}\", \"const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;varying vec4 v_data0;varying vec4 v_data1;\\n#pragma mapbox: define highp vec4 fill_color\\n#pragma mapbox: define highp vec4 halo_color\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define lowp float halo_width\\n#pragma mapbox: define lowp float halo_blur\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 fill_color\\n#pragma mapbox: initialize highp vec4 halo_color\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize lowp float halo_width\\n#pragma mapbox: initialize lowp float halo_blur\\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\\ncamera_to_anchor_distance/u_camera_to_center_distance :\\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,0.0,1.0);gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale),0.0,1.0);float gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(1.0,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}\")\n    };\n\n    function re(t, e) {\n      const i = /#pragma mapbox: ([\\w]+) ([\\w]+) ([\\w]+) ([\\w]+)/g,\n            o = e.match(/attribute ([\\w]+) ([\\w]+)/g),\n            a = t.match(/uniform ([\\w]+) ([\\w]+)([\\s]*)([\\w]*)/g),\n            s = e.match(/uniform ([\\w]+) ([\\w]+)([\\s]*)([\\w]*)/g),\n            r = s ? s.concat(a) : a,\n            n = {};\n      return {\n        fragmentSource: t = t.replace(i, (t, e, i, o, a) => (n[a] = !0, \"define\" === e ? `\\n#ifndef HAS_UNIFORM_u_${a}\\nvarying ${i} ${o} ${a};\\n#else\\nuniform ${i} ${o} u_${a};\\n#endif\\n` : `\\n#ifdef HAS_UNIFORM_u_${a}\\n    ${i} ${o} ${a} = u_${a};\\n#endif\\n`)),\n        vertexSource: e = e.replace(i, (t, e, i, o, a) => {\n          const s = \"float\" === o ? \"vec2\" : \"vec4\",\n                r = a.match(/color/) ? \"color\" : s;\n          return n[a] ? \"define\" === e ? `\\n#ifndef HAS_UNIFORM_u_${a}\\nuniform lowp float u_${a}_t;\\nattribute ${i} ${s} a_${a};\\nvarying ${i} ${o} ${a};\\n#else\\nuniform ${i} ${o} u_${a};\\n#endif\\n` : \"vec4\" === r ? `\\n#ifndef HAS_UNIFORM_u_${a}\\n    ${a} = a_${a};\\n#else\\n    ${i} ${o} ${a} = u_${a};\\n#endif\\n` : `\\n#ifndef HAS_UNIFORM_u_${a}\\n    ${a} = unpack_mix_${r}(a_${a}, u_${a}_t);\\n#else\\n    ${i} ${o} ${a} = u_${a};\\n#endif\\n` : \"define\" === e ? `\\n#ifndef HAS_UNIFORM_u_${a}\\nuniform lowp float u_${a}_t;\\nattribute ${i} ${s} a_${a};\\n#else\\nuniform ${i} ${o} u_${a};\\n#endif\\n` : \"vec4\" === r ? `\\n#ifndef HAS_UNIFORM_u_${a}\\n    ${i} ${o} ${a} = a_${a};\\n#else\\n    ${i} ${o} ${a} = u_${a};\\n#endif\\n` : `\\n#ifndef HAS_UNIFORM_u_${a}\\n    ${i} ${o} ${a} = unpack_mix_${r}(a_${a}, u_${a}_t);\\n#else\\n    ${i} ${o} ${a} = u_${a};\\n#endif\\n`;\n        }),\n        staticAttributes: o,\n        staticUniforms: r\n      };\n    }\n\n    class ne {\n      constructor() {\n        this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null;\n      }\n\n      bind(t, e, i, o, a, s, r, n) {\n        this.context = t;\n        let l = this.boundPaintVertexBuffers.length !== o.length;\n\n        for (let t = 0; !l && t < o.length; t++) this.boundPaintVertexBuffers[t] !== o[t] && (l = !0);\n\n        t.extVertexArrayObject && this.vao && this.boundProgram === e && this.boundLayoutVertexBuffer === i && !l && this.boundIndexBuffer === a && this.boundVertexOffset === s && this.boundDynamicVertexBuffer === r && this.boundDynamicVertexBuffer2 === n ? (t.bindVertexArrayOES.set(this.vao), r && r.bind(), a && a.dynamicDraw && a.bind(), n && n.bind()) : this.freshBind(e, i, o, a, s, r, n);\n      }\n\n      freshBind(t, e, i, o, a, s, r) {\n        let n;\n        const l = t.numAttributes,\n              c = this.context,\n              h = c.gl;\n        if (c.extVertexArrayObject) this.vao && this.destroy(), this.vao = c.extVertexArrayObject.createVertexArrayOES(), c.bindVertexArrayOES.set(this.vao), n = 0, this.boundProgram = t, this.boundLayoutVertexBuffer = e, this.boundPaintVertexBuffers = i, this.boundIndexBuffer = o, this.boundVertexOffset = a, this.boundDynamicVertexBuffer = s, this.boundDynamicVertexBuffer2 = r;else {\n          n = c.currentNumAttributes || 0;\n\n          for (let t = l; t < n; t++) h.disableVertexAttribArray(t);\n        }\n        e.enableAttributes(h, t);\n\n        for (const e of i) e.enableAttributes(h, t);\n\n        s && s.enableAttributes(h, t), r && r.enableAttributes(h, t), e.bind(), e.setVertexAttribPointers(h, t, a);\n\n        for (const e of i) e.bind(), e.setVertexAttribPointers(h, t, a);\n\n        s && (s.bind(), s.setVertexAttribPointers(h, t, a)), o && o.bind(), r && (r.bind(), r.setVertexAttribPointers(h, t, a)), c.currentNumAttributes = l;\n      }\n\n      destroy() {\n        this.vao && (this.context.extVertexArrayObject.deleteVertexArrayOES(this.vao), this.vao = null);\n      }\n\n    }\n\n    function le(t) {\n      const e = [];\n\n      for (let i = 0; i < t.length; i++) {\n        if (null === t[i]) continue;\n        const o = t[i].split(\" \");\n        e.push(o.pop());\n      }\n\n      return e;\n    }\n\n    class ce {\n      constructor(t, e, i, o, a, s) {\n        const r = t.gl;\n        this.program = r.createProgram();\n        const n = le(i.staticAttributes),\n              l = o ? o.getBinderAttributes() : [],\n              c = n.concat(l),\n              h = i.staticUniforms ? le(i.staticUniforms) : [],\n              u = o ? o.getBinderUniforms() : [],\n              d = h.concat(u),\n              m = [];\n\n        for (const t of d) m.indexOf(t) < 0 && m.push(t);\n\n        const _ = o ? o.defines() : [];\n\n        s && _.push(\"#define OVERDRAW_INSPECTOR;\");\n\n        const p = _.concat(se.prelude.fragmentSource, i.fragmentSource).join(\"\\n\"),\n              f = _.concat(se.prelude.vertexSource, i.vertexSource).join(\"\\n\"),\n              g = r.createShader(r.FRAGMENT_SHADER);\n\n        if (r.isContextLost()) return void (this.failedToCreate = !0);\n        r.shaderSource(g, p), r.compileShader(g), r.attachShader(this.program, g);\n        const x = r.createShader(r.VERTEX_SHADER);\n        if (r.isContextLost()) return void (this.failedToCreate = !0);\n        r.shaderSource(x, f), r.compileShader(x), r.attachShader(this.program, x), this.attributes = {};\n        const v = {};\n        this.numAttributes = c.length;\n\n        for (let t = 0; t < this.numAttributes; t++) c[t] && (r.bindAttribLocation(this.program, t, c[t]), this.attributes[c[t]] = t);\n\n        r.linkProgram(this.program), r.deleteShader(x), r.deleteShader(g);\n\n        for (let t = 0; t < m.length; t++) {\n          const e = m[t];\n\n          if (e && !v[e]) {\n            const t = r.getUniformLocation(this.program, e);\n            t && (v[e] = t);\n          }\n        }\n\n        this.fixedUniforms = a(t, v), this.binderUniforms = o ? o.getUniforms(t, v) : [];\n      }\n\n      draw(t, e, i, o, a, s, r, n, l, c, h, u, d, m, _, p) {\n        const f = t.gl;\n        if (this.failedToCreate) return;\n        t.program.set(this.program), t.setDepthMode(i), t.setStencilMode(o), t.setColorMode(a), t.setCullFace(s);\n\n        for (const t in this.fixedUniforms) this.fixedUniforms[t].set(r[t]);\n\n        m && m.setUniforms(t, this.binderUniforms, u, {\n          zoom: d\n        });\n        const g = {\n          [f.LINES]: 2,\n          [f.TRIANGLES]: 3,\n          [f.LINE_STRIP]: 1\n        }[e];\n\n        for (const i of h.get()) {\n          const o = i.vaos || (i.vaos = {});\n          (o[n] || (o[n] = new ne())).bind(t, this, l, m ? m.getPaintVertexBuffers() : [], c, i.vertexOffset, _, p), f.drawElements(e, i.primitiveLength * g, f.UNSIGNED_SHORT, i.primitiveOffset * g * 2);\n        }\n      }\n\n    }\n\n    function he(t, e, i) {\n      const o = 1 / St(i, 1, e.transform.tileZoom),\n            a = Math.pow(2, i.tileID.overscaledZ),\n            s = i.tileSize * Math.pow(2, e.transform.tileZoom) / a,\n            r = s * (i.tileID.canonical.x + i.tileID.wrap * a),\n            n = s * i.tileID.canonical.y;\n      return {\n        u_image: 0,\n        u_texsize: i.imageAtlasTexture.size,\n        u_scale: [o, t.fromScale, t.toScale],\n        u_fade: t.t,\n        u_pixel_coord_upper: [r >> 16, n >> 16],\n        u_pixel_coord_lower: [65535 & r, 65535 & n]\n      };\n    }\n\n    const ue = (e, i, o, a) => {\n      const s = i.style.light,\n            r = s.properties.get(\"position\"),\n            n = c(r.x, r.y, r.z),\n            l = function () {\n        var e = new t.ARRAY_TYPE(9);\n        return t.ARRAY_TYPE != Float32Array && (e[1] = 0, e[2] = 0, e[3] = 0, e[5] = 0, e[6] = 0, e[7] = 0), e[0] = 1, e[4] = 1, e[8] = 1, e;\n      }();\n\n      \"viewport\" === s.properties.get(\"anchor\") && function (t, e) {\n        var i = Math.sin(e),\n            o = Math.cos(e);\n        t[0] = o, t[1] = i, t[2] = 0, t[3] = -i, t[4] = o, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1;\n      }(l, -i.transform.angle), function (t, e, i) {\n        var o = e[0],\n            a = e[1],\n            s = e[2];\n        t[0] = o * i[0] + a * i[3] + s * i[6], t[1] = o * i[1] + a * i[4] + s * i[7], t[2] = o * i[2] + a * i[5] + s * i[8];\n      }(n, n, l);\n      const h = s.properties.get(\"color\");\n      return {\n        u_matrix: e,\n        u_lightpos: n,\n        u_lightintensity: s.properties.get(\"intensity\"),\n        u_lightcolor: [h.r, h.g, h.b],\n        u_vertical_gradient: +o,\n        u_opacity: a\n      };\n    },\n          de = (e, i, o, a, s, r, n) => t.extend(ue(e, i, o, a), he(r, i, n), {\n      u_height_factor: -Math.pow(2, s.overscaledZ) / n.tileSize / 8\n    }),\n          me = t => ({\n      u_matrix: t\n    }),\n          _e = (e, i, o, a) => t.extend(me(e), he(o, i, a)),\n          pe = (t, e) => ({\n      u_matrix: t,\n      u_world: e\n    }),\n          fe = (e, i, o, a, s) => t.extend(_e(e, i, o, a), {\n      u_world: s\n    }),\n          ge = (t, e, i, o) => {\n      const a = t.transform;\n      let s, r;\n\n      if (\"map\" === o.paint.get(\"circle-pitch-alignment\")) {\n        const t = St(i, 1, a.zoom);\n        s = !0, r = [t, t];\n      } else s = !1, r = a.pixelsToGLUnits;\n\n      return {\n        u_camera_to_center_distance: a.cameraToCenterDistance,\n        u_scale_with_map: +(\"map\" === o.paint.get(\"circle-pitch-scale\")),\n        u_matrix: t.translatePosMatrix(e.posMatrix, i, o.paint.get(\"circle-translate\"), o.paint.get(\"circle-translate-anchor\")),\n        u_pitch_with_map: +s,\n        u_device_pixel_ratio: t.pixelRatio,\n        u_extrude_scale: r\n      };\n    },\n          xe = (t, e, i) => {\n      const o = St(i, 1, e.zoom),\n            a = Math.pow(2, e.zoom - i.tileID.overscaledZ),\n            s = i.tileID.overscaleFactor();\n      return {\n        u_matrix: t,\n        u_camera_to_center_distance: e.cameraToCenterDistance,\n        u_pixels_to_tile_units: o,\n        u_extrude_scale: [e.pixelsToGLUnits[0] / (o * a), e.pixelsToGLUnits[1] / (o * a)],\n        u_overscale_factor: s\n      };\n    },\n          ve = function (t, e) {\n      let i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n      return {\n        u_matrix: t,\n        u_color: e,\n        u_overlay: 0,\n        u_overlay_scale: i\n      };\n    },\n          ye = t => ({\n      u_matrix: t\n    }),\n          be = (t, e, i, o) => ({\n      u_matrix: t,\n      u_extrude_scale: St(e, 1, i),\n      u_intensity: o\n    });\n\n    function we(e, i) {\n      const o = Math.pow(2, i.canonical.z),\n            a = i.canonical.y;\n      return [new t.MercatorCoordinate(0, a / o).toLngLat().lat, new t.MercatorCoordinate(0, (a + 1) / o).toLngLat().lat];\n    }\n\n    const Te = (t, e, i) => {\n      const o = t.transform;\n      return {\n        u_matrix: Pe(t, e, i),\n        u_ratio: 1 / St(e, 1, o.zoom),\n        u_device_pixel_ratio: t.pixelRatio,\n        u_units_to_pixels: [1 / o.pixelsToGLUnits[0], 1 / o.pixelsToGLUnits[1]]\n      };\n    },\n          Ee = (e, i, o, a) => t.extend(Te(e, i, o), {\n      u_image: 0,\n      u_image_height: a\n    }),\n          Ie = (t, e, i, o) => {\n      const a = t.transform,\n            s = Ce(e, a);\n      return {\n        u_matrix: Pe(t, e, i),\n        u_texsize: e.imageAtlasTexture.size,\n        u_ratio: 1 / St(e, 1, a.zoom),\n        u_device_pixel_ratio: t.pixelRatio,\n        u_image: 0,\n        u_scale: [s, o.fromScale, o.toScale],\n        u_fade: o.t,\n        u_units_to_pixels: [1 / a.pixelsToGLUnits[0], 1 / a.pixelsToGLUnits[1]]\n      };\n    },\n          Se = (e, i, o, a, s) => {\n      const r = e.lineAtlas,\n            n = Ce(i, e.transform),\n            l = \"round\" === o.layout.get(\"line-cap\"),\n            c = r.getDash(a.from, l),\n            h = r.getDash(a.to, l),\n            u = c.width * s.fromScale,\n            d = h.width * s.toScale;\n      return t.extend(Te(e, i, o), {\n        u_patternscale_a: [n / u, -c.height / 2],\n        u_patternscale_b: [n / d, -h.height / 2],\n        u_sdfgamma: r.width / (256 * Math.min(u, d) * e.pixelRatio) / 2,\n        u_image: 0,\n        u_tex_y_a: c.y,\n        u_tex_y_b: h.y,\n        u_mix: s.t\n      });\n    };\n\n    function Ce(t, e) {\n      return 1 / St(t, 1, e.tileZoom);\n    }\n\n    function Pe(t, e, i) {\n      return t.translatePosMatrix(e.tileID.posMatrix, e, i.paint.get(\"line-translate\"), i.paint.get(\"line-translate-anchor\"));\n    }\n\n    const ze = (t, e, i, o, a) => {\n      return {\n        u_matrix: t,\n        u_tl_parent: e,\n        u_scale_parent: i,\n        u_buffer_scale: 1,\n        u_fade_t: o.mix,\n        u_opacity: o.opacity * a.paint.get(\"raster-opacity\"),\n        u_image0: 0,\n        u_image1: 1,\n        u_brightness_low: a.paint.get(\"raster-brightness-min\"),\n        u_brightness_high: a.paint.get(\"raster-brightness-max\"),\n        u_saturation_factor: (r = a.paint.get(\"raster-saturation\"), r > 0 ? 1 - 1 / (1.001 - r) : -r),\n        u_contrast_factor: (s = a.paint.get(\"raster-contrast\"), s > 0 ? 1 / (1 - s) : 1 + s),\n        u_spin_weights: De(a.paint.get(\"raster-hue-rotate\"))\n      };\n      var s, r;\n    };\n\n    function De(t) {\n      t *= Math.PI / 180;\n      const e = Math.sin(t),\n            i = Math.cos(t);\n      return [(2 * i + 1) / 3, (-Math.sqrt(3) * e - i + 1) / 3, (Math.sqrt(3) * e - i + 1) / 3];\n    }\n\n    const Ae = (t, e, i, o, a, s, r, n, l, c) => {\n      const h = a.transform;\n      return {\n        u_is_size_zoom_constant: +(\"constant\" === t || \"source\" === t),\n        u_is_size_feature_constant: +(\"constant\" === t || \"camera\" === t),\n        u_size_t: e ? e.uSizeT : 0,\n        u_size: e ? e.uSize : 0,\n        u_camera_to_center_distance: h.cameraToCenterDistance,\n        u_pitch: h.pitch / 360 * 2 * Math.PI,\n        u_rotate_symbol: +i,\n        u_aspect_ratio: h.width / h.height,\n        u_fade_change: a.options.fadeDuration ? a.symbolFadeChange : 1,\n        u_matrix: s,\n        u_label_plane_matrix: r,\n        u_coord_matrix: n,\n        u_is_text: +l,\n        u_pitch_with_map: +o,\n        u_texsize: c,\n        u_texture: 0\n      };\n    },\n          Me = (e, i, o, a, s, r, n, l, c, h, u) => {\n      const d = s.transform;\n      return t.extend(Ae(e, i, o, a, s, r, n, l, c, h), {\n        u_gamma_scale: a ? Math.cos(d._pitch) * d.cameraToCenterDistance : 1,\n        u_device_pixel_ratio: s.pixelRatio,\n        u_is_halo: +u\n      });\n    },\n          Le = (e, i, o, a, s, r, n, l, c, h) => t.extend(Me(e, i, o, a, s, r, n, l, !0, c, !0), {\n      u_texsize_icon: h,\n      u_texture_icon: 1\n    }),\n          Re = (t, e, i) => ({\n      u_matrix: t,\n      u_opacity: e,\n      u_color: i\n    }),\n          ke = (e, i, o, a, s, r) => t.extend(function (t, e, i, o) {\n      const a = i.imageManager.getPattern(t.from.toString()),\n            s = i.imageManager.getPattern(t.to.toString()),\n            {\n        width: r,\n        height: n\n      } = i.imageManager.getPixelSize(),\n            l = Math.pow(2, o.tileID.overscaledZ),\n            c = o.tileSize * Math.pow(2, i.transform.tileZoom) / l,\n            h = c * (o.tileID.canonical.x + o.tileID.wrap * l),\n            u = c * o.tileID.canonical.y;\n      return {\n        u_image: 0,\n        u_pattern_tl_a: a.tl,\n        u_pattern_br_a: a.br,\n        u_pattern_tl_b: s.tl,\n        u_pattern_br_b: s.br,\n        u_texsize: [r, n],\n        u_mix: e.t,\n        u_pattern_size_a: a.displaySize,\n        u_pattern_size_b: s.displaySize,\n        u_scale_a: e.fromScale,\n        u_scale_b: e.toScale,\n        u_tile_units_to_pixels: 1 / St(o, 1, i.transform.tileZoom),\n        u_pixel_coord_upper: [h >> 16, u >> 16],\n        u_pixel_coord_lower: [65535 & h, 65535 & u]\n      };\n    }(a, r, o, s), {\n      u_matrix: e,\n      u_opacity: i\n    }),\n          Be = {\n      fillExtrusion: (e, i) => ({\n        u_matrix: new t.UniformMatrix4f(e, i.u_matrix),\n        u_lightpos: new t.Uniform3f(e, i.u_lightpos),\n        u_lightintensity: new t.Uniform1f(e, i.u_lightintensity),\n        u_lightcolor: new t.Uniform3f(e, i.u_lightcolor),\n        u_vertical_gradient: new t.Uniform1f(e, i.u_vertical_gradient),\n        u_opacity: new t.Uniform1f(e, i.u_opacity)\n      }),\n      fillExtrusionPattern: (e, i) => ({\n        u_matrix: new t.UniformMatrix4f(e, i.u_matrix),\n        u_lightpos: new t.Uniform3f(e, i.u_lightpos),\n        u_lightintensity: new t.Uniform1f(e, i.u_lightintensity),\n        u_lightcolor: new t.Uniform3f(e, i.u_lightcolor),\n        u_vertical_gradient: new t.Uniform1f(e, i.u_vertical_gradient),\n        u_height_factor: new t.Uniform1f(e, i.u_height_factor),\n        u_image: new t.Uniform1i(e, i.u_image),\n        u_texsize: new t.Uniform2f(e, i.u_texsize),\n        u_pixel_coord_upper: new t.Uniform2f(e, i.u_pixel_coord_upper),\n        u_pixel_coord_lower: new t.Uniform2f(e, i.u_pixel_coord_lower),\n        u_scale: new t.Uniform3f(e, i.u_scale),\n        u_fade: new t.Uniform1f(e, i.u_fade),\n        u_opacity: new t.Uniform1f(e, i.u_opacity)\n      }),\n      fill: (e, i) => ({\n        u_matrix: new t.UniformMatrix4f(e, i.u_matrix)\n      }),\n      fillPattern: (e, i) => ({\n        u_matrix: new t.UniformMatrix4f(e, i.u_matrix),\n        u_image: new t.Uniform1i(e, i.u_image),\n        u_texsize: new t.Uniform2f(e, i.u_texsize),\n        u_pixel_coord_upper: new t.Uniform2f(e, i.u_pixel_coord_upper),\n        u_pixel_coord_lower: new t.Uniform2f(e, i.u_pixel_coord_lower),\n        u_scale: new t.Uniform3f(e, i.u_scale),\n        u_fade: new t.Uniform1f(e, i.u_fade)\n      }),\n      fillOutline: (e, i) => ({\n        u_matrix: new t.UniformMatrix4f(e, i.u_matrix),\n        u_world: new t.Uniform2f(e, i.u_world)\n      }),\n      fillOutlinePattern: (e, i) => ({\n        u_matrix: new t.UniformMatrix4f(e, i.u_matrix),\n        u_world: new t.Uniform2f(e, i.u_world),\n        u_image: new t.Uniform1i(e, i.u_image),\n        u_texsize: new t.Uniform2f(e, i.u_texsize),\n        u_pixel_coord_upper: new t.Uniform2f(e, i.u_pixel_coord_upper),\n        u_pixel_coord_lower: new t.Uniform2f(e, i.u_pixel_coord_lower),\n        u_scale: new t.Uniform3f(e, i.u_scale),\n        u_fade: new t.Uniform1f(e, i.u_fade)\n      }),\n      circle: (e, i) => ({\n        u_camera_to_center_distance: new t.Uniform1f(e, i.u_camera_to_center_distance),\n        u_scale_with_map: new t.Uniform1i(e, i.u_scale_with_map),\n        u_pitch_with_map: new t.Uniform1i(e, i.u_pitch_with_map),\n        u_extrude_scale: new t.Uniform2f(e, i.u_extrude_scale),\n        u_device_pixel_ratio: new t.Uniform1f(e, i.u_device_pixel_ratio),\n        u_matrix: new t.UniformMatrix4f(e, i.u_matrix)\n      }),\n      collisionBox: (e, i) => ({\n        u_matrix: new t.UniformMatrix4f(e, i.u_matrix),\n        u_camera_to_center_distance: new t.Uniform1f(e, i.u_camera_to_center_distance),\n        u_pixels_to_tile_units: new t.Uniform1f(e, i.u_pixels_to_tile_units),\n        u_extrude_scale: new t.Uniform2f(e, i.u_extrude_scale),\n        u_overscale_factor: new t.Uniform1f(e, i.u_overscale_factor)\n      }),\n      collisionCircle: (e, i) => ({\n        u_matrix: new t.UniformMatrix4f(e, i.u_matrix),\n        u_inv_matrix: new t.UniformMatrix4f(e, i.u_inv_matrix),\n        u_camera_to_center_distance: new t.Uniform1f(e, i.u_camera_to_center_distance),\n        u_viewport_size: new t.Uniform2f(e, i.u_viewport_size)\n      }),\n      debug: (e, i) => ({\n        u_color: new t.UniformColor(e, i.u_color),\n        u_matrix: new t.UniformMatrix4f(e, i.u_matrix),\n        u_overlay: new t.Uniform1i(e, i.u_overlay),\n        u_overlay_scale: new t.Uniform1f(e, i.u_overlay_scale)\n      }),\n      clippingMask: (e, i) => ({\n        u_matrix: new t.UniformMatrix4f(e, i.u_matrix)\n      }),\n      heatmap: (e, i) => ({\n        u_extrude_scale: new t.Uniform1f(e, i.u_extrude_scale),\n        u_intensity: new t.Uniform1f(e, i.u_intensity),\n        u_matrix: new t.UniformMatrix4f(e, i.u_matrix)\n      }),\n      heatmapTexture: (e, i) => ({\n        u_matrix: new t.UniformMatrix4f(e, i.u_matrix),\n        u_world: new t.Uniform2f(e, i.u_world),\n        u_image: new t.Uniform1i(e, i.u_image),\n        u_color_ramp: new t.Uniform1i(e, i.u_color_ramp),\n        u_opacity: new t.Uniform1f(e, i.u_opacity)\n      }),\n      hillshade: (e, i) => ({\n        u_matrix: new t.UniformMatrix4f(e, i.u_matrix),\n        u_image: new t.Uniform1i(e, i.u_image),\n        u_latrange: new t.Uniform2f(e, i.u_latrange),\n        u_light: new t.Uniform2f(e, i.u_light),\n        u_shadow: new t.UniformColor(e, i.u_shadow),\n        u_highlight: new t.UniformColor(e, i.u_highlight),\n        u_accent: new t.UniformColor(e, i.u_accent)\n      }),\n      hillshadePrepare: (e, i) => ({\n        u_matrix: new t.UniformMatrix4f(e, i.u_matrix),\n        u_image: new t.Uniform1i(e, i.u_image),\n        u_dimension: new t.Uniform2f(e, i.u_dimension),\n        u_zoom: new t.Uniform1f(e, i.u_zoom),\n        u_unpack: new t.Uniform4f(e, i.u_unpack)\n      }),\n      line: (e, i) => ({\n        u_matrix: new t.UniformMatrix4f(e, i.u_matrix),\n        u_ratio: new t.Uniform1f(e, i.u_ratio),\n        u_device_pixel_ratio: new t.Uniform1f(e, i.u_device_pixel_ratio),\n        u_units_to_pixels: new t.Uniform2f(e, i.u_units_to_pixels)\n      }),\n      lineGradient: (e, i) => ({\n        u_matrix: new t.UniformMatrix4f(e, i.u_matrix),\n        u_ratio: new t.Uniform1f(e, i.u_ratio),\n        u_device_pixel_ratio: new t.Uniform1f(e, i.u_device_pixel_ratio),\n        u_units_to_pixels: new t.Uniform2f(e, i.u_units_to_pixels),\n        u_image: new t.Uniform1i(e, i.u_image),\n        u_image_height: new t.Uniform1f(e, i.u_image_height)\n      }),\n      linePattern: (e, i) => ({\n        u_matrix: new t.UniformMatrix4f(e, i.u_matrix),\n        u_texsize: new t.Uniform2f(e, i.u_texsize),\n        u_ratio: new t.Uniform1f(e, i.u_ratio),\n        u_device_pixel_ratio: new t.Uniform1f(e, i.u_device_pixel_ratio),\n        u_image: new t.Uniform1i(e, i.u_image),\n        u_units_to_pixels: new t.Uniform2f(e, i.u_units_to_pixels),\n        u_scale: new t.Uniform3f(e, i.u_scale),\n        u_fade: new t.Uniform1f(e, i.u_fade)\n      }),\n      lineSDF: (e, i) => ({\n        u_matrix: new t.UniformMatrix4f(e, i.u_matrix),\n        u_ratio: new t.Uniform1f(e, i.u_ratio),\n        u_device_pixel_ratio: new t.Uniform1f(e, i.u_device_pixel_ratio),\n        u_units_to_pixels: new t.Uniform2f(e, i.u_units_to_pixels),\n        u_patternscale_a: new t.Uniform2f(e, i.u_patternscale_a),\n        u_patternscale_b: new t.Uniform2f(e, i.u_patternscale_b),\n        u_sdfgamma: new t.Uniform1f(e, i.u_sdfgamma),\n        u_image: new t.Uniform1i(e, i.u_image),\n        u_tex_y_a: new t.Uniform1f(e, i.u_tex_y_a),\n        u_tex_y_b: new t.Uniform1f(e, i.u_tex_y_b),\n        u_mix: new t.Uniform1f(e, i.u_mix)\n      }),\n      raster: (e, i) => ({\n        u_matrix: new t.UniformMatrix4f(e, i.u_matrix),\n        u_tl_parent: new t.Uniform2f(e, i.u_tl_parent),\n        u_scale_parent: new t.Uniform1f(e, i.u_scale_parent),\n        u_buffer_scale: new t.Uniform1f(e, i.u_buffer_scale),\n        u_fade_t: new t.Uniform1f(e, i.u_fade_t),\n        u_opacity: new t.Uniform1f(e, i.u_opacity),\n        u_image0: new t.Uniform1i(e, i.u_image0),\n        u_image1: new t.Uniform1i(e, i.u_image1),\n        u_brightness_low: new t.Uniform1f(e, i.u_brightness_low),\n        u_brightness_high: new t.Uniform1f(e, i.u_brightness_high),\n        u_saturation_factor: new t.Uniform1f(e, i.u_saturation_factor),\n        u_contrast_factor: new t.Uniform1f(e, i.u_contrast_factor),\n        u_spin_weights: new t.Uniform3f(e, i.u_spin_weights)\n      }),\n      symbolIcon: (e, i) => ({\n        u_is_size_zoom_constant: new t.Uniform1i(e, i.u_is_size_zoom_constant),\n        u_is_size_feature_constant: new t.Uniform1i(e, i.u_is_size_feature_constant),\n        u_size_t: new t.Uniform1f(e, i.u_size_t),\n        u_size: new t.Uniform1f(e, i.u_size),\n        u_camera_to_center_distance: new t.Uniform1f(e, i.u_camera_to_center_distance),\n        u_pitch: new t.Uniform1f(e, i.u_pitch),\n        u_rotate_symbol: new t.Uniform1i(e, i.u_rotate_symbol),\n        u_aspect_ratio: new t.Uniform1f(e, i.u_aspect_ratio),\n        u_fade_change: new t.Uniform1f(e, i.u_fade_change),\n        u_matrix: new t.UniformMatrix4f(e, i.u_matrix),\n        u_label_plane_matrix: new t.UniformMatrix4f(e, i.u_label_plane_matrix),\n        u_coord_matrix: new t.UniformMatrix4f(e, i.u_coord_matrix),\n        u_is_text: new t.Uniform1i(e, i.u_is_text),\n        u_pitch_with_map: new t.Uniform1i(e, i.u_pitch_with_map),\n        u_texsize: new t.Uniform2f(e, i.u_texsize),\n        u_texture: new t.Uniform1i(e, i.u_texture)\n      }),\n      symbolSDF: (e, i) => ({\n        u_is_size_zoom_constant: new t.Uniform1i(e, i.u_is_size_zoom_constant),\n        u_is_size_feature_constant: new t.Uniform1i(e, i.u_is_size_feature_constant),\n        u_size_t: new t.Uniform1f(e, i.u_size_t),\n        u_size: new t.Uniform1f(e, i.u_size),\n        u_camera_to_center_distance: new t.Uniform1f(e, i.u_camera_to_center_distance),\n        u_pitch: new t.Uniform1f(e, i.u_pitch),\n        u_rotate_symbol: new t.Uniform1i(e, i.u_rotate_symbol),\n        u_aspect_ratio: new t.Uniform1f(e, i.u_aspect_ratio),\n        u_fade_change: new t.Uniform1f(e, i.u_fade_change),\n        u_matrix: new t.UniformMatrix4f(e, i.u_matrix),\n        u_label_plane_matrix: new t.UniformMatrix4f(e, i.u_label_plane_matrix),\n        u_coord_matrix: new t.UniformMatrix4f(e, i.u_coord_matrix),\n        u_is_text: new t.Uniform1i(e, i.u_is_text),\n        u_pitch_with_map: new t.Uniform1i(e, i.u_pitch_with_map),\n        u_texsize: new t.Uniform2f(e, i.u_texsize),\n        u_texture: new t.Uniform1i(e, i.u_texture),\n        u_gamma_scale: new t.Uniform1f(e, i.u_gamma_scale),\n        u_device_pixel_ratio: new t.Uniform1f(e, i.u_device_pixel_ratio),\n        u_is_halo: new t.Uniform1i(e, i.u_is_halo)\n      }),\n      symbolTextAndIcon: (e, i) => ({\n        u_is_size_zoom_constant: new t.Uniform1i(e, i.u_is_size_zoom_constant),\n        u_is_size_feature_constant: new t.Uniform1i(e, i.u_is_size_feature_constant),\n        u_size_t: new t.Uniform1f(e, i.u_size_t),\n        u_size: new t.Uniform1f(e, i.u_size),\n        u_camera_to_center_distance: new t.Uniform1f(e, i.u_camera_to_center_distance),\n        u_pitch: new t.Uniform1f(e, i.u_pitch),\n        u_rotate_symbol: new t.Uniform1i(e, i.u_rotate_symbol),\n        u_aspect_ratio: new t.Uniform1f(e, i.u_aspect_ratio),\n        u_fade_change: new t.Uniform1f(e, i.u_fade_change),\n        u_matrix: new t.UniformMatrix4f(e, i.u_matrix),\n        u_label_plane_matrix: new t.UniformMatrix4f(e, i.u_label_plane_matrix),\n        u_coord_matrix: new t.UniformMatrix4f(e, i.u_coord_matrix),\n        u_is_text: new t.Uniform1i(e, i.u_is_text),\n        u_pitch_with_map: new t.Uniform1i(e, i.u_pitch_with_map),\n        u_texsize: new t.Uniform2f(e, i.u_texsize),\n        u_texsize_icon: new t.Uniform2f(e, i.u_texsize_icon),\n        u_texture: new t.Uniform1i(e, i.u_texture),\n        u_texture_icon: new t.Uniform1i(e, i.u_texture_icon),\n        u_gamma_scale: new t.Uniform1f(e, i.u_gamma_scale),\n        u_device_pixel_ratio: new t.Uniform1f(e, i.u_device_pixel_ratio),\n        u_is_halo: new t.Uniform1i(e, i.u_is_halo)\n      }),\n      background: (e, i) => ({\n        u_matrix: new t.UniformMatrix4f(e, i.u_matrix),\n        u_opacity: new t.Uniform1f(e, i.u_opacity),\n        u_color: new t.UniformColor(e, i.u_color)\n      }),\n      backgroundPattern: (e, i) => ({\n        u_matrix: new t.UniformMatrix4f(e, i.u_matrix),\n        u_opacity: new t.Uniform1f(e, i.u_opacity),\n        u_image: new t.Uniform1i(e, i.u_image),\n        u_pattern_tl_a: new t.Uniform2f(e, i.u_pattern_tl_a),\n        u_pattern_br_a: new t.Uniform2f(e, i.u_pattern_br_a),\n        u_pattern_tl_b: new t.Uniform2f(e, i.u_pattern_tl_b),\n        u_pattern_br_b: new t.Uniform2f(e, i.u_pattern_br_b),\n        u_texsize: new t.Uniform2f(e, i.u_texsize),\n        u_mix: new t.Uniform1f(e, i.u_mix),\n        u_pattern_size_a: new t.Uniform2f(e, i.u_pattern_size_a),\n        u_pattern_size_b: new t.Uniform2f(e, i.u_pattern_size_b),\n        u_scale_a: new t.Uniform1f(e, i.u_scale_a),\n        u_scale_b: new t.Uniform1f(e, i.u_scale_b),\n        u_pixel_coord_upper: new t.Uniform2f(e, i.u_pixel_coord_upper),\n        u_pixel_coord_lower: new t.Uniform2f(e, i.u_pixel_coord_lower),\n        u_tile_units_to_pixels: new t.Uniform1f(e, i.u_tile_units_to_pixels)\n      })\n    };\n\n    class Fe {\n      constructor(t, e, i) {\n        this.context = t;\n        const o = t.gl;\n        this.buffer = o.createBuffer(), this.dynamicDraw = Boolean(i), this.context.unbindVAO(), t.bindElementBuffer.set(this.buffer), o.bufferData(o.ELEMENT_ARRAY_BUFFER, e.arrayBuffer, this.dynamicDraw ? o.DYNAMIC_DRAW : o.STATIC_DRAW), this.dynamicDraw || delete e.arrayBuffer;\n      }\n\n      bind() {\n        this.context.bindElementBuffer.set(this.buffer);\n      }\n\n      updateData(t) {\n        const e = this.context.gl;\n        this.context.unbindVAO(), this.bind(), e.bufferSubData(e.ELEMENT_ARRAY_BUFFER, 0, t.arrayBuffer);\n      }\n\n      destroy() {\n        this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);\n      }\n\n    }\n\n    const Oe = {\n      Int8: \"BYTE\",\n      Uint8: \"UNSIGNED_BYTE\",\n      Int16: \"SHORT\",\n      Uint16: \"UNSIGNED_SHORT\",\n      Int32: \"INT\",\n      Uint32: \"UNSIGNED_INT\",\n      Float32: \"FLOAT\"\n    };\n\n    class Ue {\n      constructor(t, e, i, o) {\n        this.length = e.length, this.attributes = i, this.itemSize = e.bytesPerElement, this.dynamicDraw = o, this.context = t;\n        const a = t.gl;\n        this.buffer = a.createBuffer(), t.bindVertexBuffer.set(this.buffer), a.bufferData(a.ARRAY_BUFFER, e.arrayBuffer, this.dynamicDraw ? a.DYNAMIC_DRAW : a.STATIC_DRAW), this.dynamicDraw || delete e.arrayBuffer;\n      }\n\n      bind() {\n        this.context.bindVertexBuffer.set(this.buffer);\n      }\n\n      updateData(t) {\n        const e = this.context.gl;\n        this.bind(), e.bufferSubData(e.ARRAY_BUFFER, 0, t.arrayBuffer);\n      }\n\n      enableAttributes(t, e) {\n        for (let i = 0; i < this.attributes.length; i++) {\n          const o = e.attributes[this.attributes[i].name];\n          void 0 !== o && t.enableVertexAttribArray(o);\n        }\n      }\n\n      setVertexAttribPointers(t, e, i) {\n        for (let o = 0; o < this.attributes.length; o++) {\n          const a = this.attributes[o],\n                s = e.attributes[a.name];\n          void 0 !== s && t.vertexAttribPointer(s, a.components, t[Oe[a.type]], !1, this.itemSize, a.offset + this.itemSize * (i || 0));\n        }\n      }\n\n      destroy() {\n        this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);\n      }\n\n    }\n\n    class Ne {\n      constructor(t) {\n        this.gl = t.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = !1;\n      }\n\n      get() {\n        return this.current;\n      }\n\n      set(t) {}\n\n      getDefault() {\n        return this.default;\n      }\n\n      setDefault() {\n        this.set(this.default);\n      }\n\n    }\n\n    class Ge extends Ne {\n      getDefault() {\n        return t.Color.transparent;\n      }\n\n      set(t) {\n        const e = this.current;\n        (t.r !== e.r || t.g !== e.g || t.b !== e.b || t.a !== e.a || this.dirty) && (this.gl.clearColor(t.r, t.g, t.b, t.a), this.current = t, this.dirty = !1);\n      }\n\n    }\n\n    class Ze extends Ne {\n      getDefault() {\n        return 1;\n      }\n\n      set(t) {\n        (t !== this.current || this.dirty) && (this.gl.clearDepth(t), this.current = t, this.dirty = !1);\n      }\n\n    }\n\n    class qe extends Ne {\n      getDefault() {\n        return 0;\n      }\n\n      set(t) {\n        (t !== this.current || this.dirty) && (this.gl.clearStencil(t), this.current = t, this.dirty = !1);\n      }\n\n    }\n\n    class Ve extends Ne {\n      getDefault() {\n        return [!0, !0, !0, !0];\n      }\n\n      set(t) {\n        const e = this.current;\n        (t[0] !== e[0] || t[1] !== e[1] || t[2] !== e[2] || t[3] !== e[3] || this.dirty) && (this.gl.colorMask(t[0], t[1], t[2], t[3]), this.current = t, this.dirty = !1);\n      }\n\n    }\n\n    class je extends Ne {\n      getDefault() {\n        return !0;\n      }\n\n      set(t) {\n        (t !== this.current || this.dirty) && (this.gl.depthMask(t), this.current = t, this.dirty = !1);\n      }\n\n    }\n\n    class $e extends Ne {\n      getDefault() {\n        return 255;\n      }\n\n      set(t) {\n        (t !== this.current || this.dirty) && (this.gl.stencilMask(t), this.current = t, this.dirty = !1);\n      }\n\n    }\n\n    class We extends Ne {\n      getDefault() {\n        return {\n          func: this.gl.ALWAYS,\n          ref: 0,\n          mask: 255\n        };\n      }\n\n      set(t) {\n        const e = this.current;\n        (t.func !== e.func || t.ref !== e.ref || t.mask !== e.mask || this.dirty) && (this.gl.stencilFunc(t.func, t.ref, t.mask), this.current = t, this.dirty = !1);\n      }\n\n    }\n\n    class Xe extends Ne {\n      getDefault() {\n        const t = this.gl;\n        return [t.KEEP, t.KEEP, t.KEEP];\n      }\n\n      set(t) {\n        const e = this.current;\n        (t[0] !== e[0] || t[1] !== e[1] || t[2] !== e[2] || this.dirty) && (this.gl.stencilOp(t[0], t[1], t[2]), this.current = t, this.dirty = !1);\n      }\n\n    }\n\n    class He extends Ne {\n      getDefault() {\n        return !1;\n      }\n\n      set(t) {\n        if (t === this.current && !this.dirty) return;\n        const e = this.gl;\n        t ? e.enable(e.STENCIL_TEST) : e.disable(e.STENCIL_TEST), this.current = t, this.dirty = !1;\n      }\n\n    }\n\n    class Ke extends Ne {\n      getDefault() {\n        return [0, 1];\n      }\n\n      set(t) {\n        const e = this.current;\n        (t[0] !== e[0] || t[1] !== e[1] || this.dirty) && (this.gl.depthRange(t[0], t[1]), this.current = t, this.dirty = !1);\n      }\n\n    }\n\n    class Ye extends Ne {\n      getDefault() {\n        return !1;\n      }\n\n      set(t) {\n        if (t === this.current && !this.dirty) return;\n        const e = this.gl;\n        t ? e.enable(e.DEPTH_TEST) : e.disable(e.DEPTH_TEST), this.current = t, this.dirty = !1;\n      }\n\n    }\n\n    class Je extends Ne {\n      getDefault() {\n        return this.gl.LESS;\n      }\n\n      set(t) {\n        (t !== this.current || this.dirty) && (this.gl.depthFunc(t), this.current = t, this.dirty = !1);\n      }\n\n    }\n\n    class Qe extends Ne {\n      getDefault() {\n        return !1;\n      }\n\n      set(t) {\n        if (t === this.current && !this.dirty) return;\n        const e = this.gl;\n        t ? e.enable(e.BLEND) : e.disable(e.BLEND), this.current = t, this.dirty = !1;\n      }\n\n    }\n\n    class ti extends Ne {\n      getDefault() {\n        const t = this.gl;\n        return [t.ONE, t.ZERO];\n      }\n\n      set(t) {\n        const e = this.current;\n        (t[0] !== e[0] || t[1] !== e[1] || this.dirty) && (this.gl.blendFunc(t[0], t[1]), this.current = t, this.dirty = !1);\n      }\n\n    }\n\n    class ei extends Ne {\n      getDefault() {\n        return t.Color.transparent;\n      }\n\n      set(t) {\n        const e = this.current;\n        (t.r !== e.r || t.g !== e.g || t.b !== e.b || t.a !== e.a || this.dirty) && (this.gl.blendColor(t.r, t.g, t.b, t.a), this.current = t, this.dirty = !1);\n      }\n\n    }\n\n    class ii extends Ne {\n      getDefault() {\n        return this.gl.FUNC_ADD;\n      }\n\n      set(t) {\n        (t !== this.current || this.dirty) && (this.gl.blendEquation(t), this.current = t, this.dirty = !1);\n      }\n\n    }\n\n    class oi extends Ne {\n      getDefault() {\n        return !1;\n      }\n\n      set(t) {\n        if (t === this.current && !this.dirty) return;\n        const e = this.gl;\n        t ? e.enable(e.CULL_FACE) : e.disable(e.CULL_FACE), this.current = t, this.dirty = !1;\n      }\n\n    }\n\n    class ai extends Ne {\n      getDefault() {\n        return this.gl.BACK;\n      }\n\n      set(t) {\n        (t !== this.current || this.dirty) && (this.gl.cullFace(t), this.current = t, this.dirty = !1);\n      }\n\n    }\n\n    class si extends Ne {\n      getDefault() {\n        return this.gl.CCW;\n      }\n\n      set(t) {\n        (t !== this.current || this.dirty) && (this.gl.frontFace(t), this.current = t, this.dirty = !1);\n      }\n\n    }\n\n    class ri extends Ne {\n      getDefault() {\n        return null;\n      }\n\n      set(t) {\n        (t !== this.current || this.dirty) && (this.gl.useProgram(t), this.current = t, this.dirty = !1);\n      }\n\n    }\n\n    class ni extends Ne {\n      getDefault() {\n        return this.gl.TEXTURE0;\n      }\n\n      set(t) {\n        (t !== this.current || this.dirty) && (this.gl.activeTexture(t), this.current = t, this.dirty = !1);\n      }\n\n    }\n\n    class li extends Ne {\n      getDefault() {\n        const t = this.gl;\n        return [0, 0, t.drawingBufferWidth, t.drawingBufferHeight];\n      }\n\n      set(t) {\n        const e = this.current;\n        (t[0] !== e[0] || t[1] !== e[1] || t[2] !== e[2] || t[3] !== e[3] || this.dirty) && (this.gl.viewport(t[0], t[1], t[2], t[3]), this.current = t, this.dirty = !1);\n      }\n\n    }\n\n    class ci extends Ne {\n      getDefault() {\n        return null;\n      }\n\n      set(t) {\n        if (t === this.current && !this.dirty) return;\n        const e = this.gl;\n        e.bindFramebuffer(e.FRAMEBUFFER, t), this.current = t, this.dirty = !1;\n      }\n\n    }\n\n    class hi extends Ne {\n      getDefault() {\n        return null;\n      }\n\n      set(t) {\n        if (t === this.current && !this.dirty) return;\n        const e = this.gl;\n        e.bindRenderbuffer(e.RENDERBUFFER, t), this.current = t, this.dirty = !1;\n      }\n\n    }\n\n    class ui extends Ne {\n      getDefault() {\n        return null;\n      }\n\n      set(t) {\n        if (t === this.current && !this.dirty) return;\n        const e = this.gl;\n        e.bindTexture(e.TEXTURE_2D, t), this.current = t, this.dirty = !1;\n      }\n\n    }\n\n    class di extends Ne {\n      getDefault() {\n        return null;\n      }\n\n      set(t) {\n        if (t === this.current && !this.dirty) return;\n        const e = this.gl;\n        e.bindBuffer(e.ARRAY_BUFFER, t), this.current = t, this.dirty = !1;\n      }\n\n    }\n\n    class mi extends Ne {\n      getDefault() {\n        return null;\n      }\n\n      set(t) {\n        const e = this.gl;\n        e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, t), this.current = t, this.dirty = !1;\n      }\n\n    }\n\n    class _i extends Ne {\n      constructor(t) {\n        super(t), this.vao = t.extVertexArrayObject;\n      }\n\n      getDefault() {\n        return null;\n      }\n\n      set(t) {\n        this.vao && (t !== this.current || this.dirty) && (this.vao.bindVertexArrayOES(t), this.current = t, this.dirty = !1);\n      }\n\n    }\n\n    class pi extends Ne {\n      getDefault() {\n        return 4;\n      }\n\n      set(t) {\n        if (t === this.current && !this.dirty) return;\n        const e = this.gl;\n        e.pixelStorei(e.UNPACK_ALIGNMENT, t), this.current = t, this.dirty = !1;\n      }\n\n    }\n\n    class fi extends Ne {\n      getDefault() {\n        return !1;\n      }\n\n      set(t) {\n        if (t === this.current && !this.dirty) return;\n        const e = this.gl;\n        e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t), this.current = t, this.dirty = !1;\n      }\n\n    }\n\n    class gi extends Ne {\n      getDefault() {\n        return !1;\n      }\n\n      set(t) {\n        if (t === this.current && !this.dirty) return;\n        const e = this.gl;\n        e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, t), this.current = t, this.dirty = !1;\n      }\n\n    }\n\n    class xi extends Ne {\n      constructor(t, e) {\n        super(t), this.context = t, this.parent = e;\n      }\n\n      getDefault() {\n        return null;\n      }\n\n    }\n\n    class vi extends xi {\n      setDirty() {\n        this.dirty = !0;\n      }\n\n      set(t) {\n        if (t === this.current && !this.dirty) return;\n        this.context.bindFramebuffer.set(this.parent);\n        const e = this.gl;\n        e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, t, 0), this.current = t, this.dirty = !1;\n      }\n\n    }\n\n    class yi extends xi {\n      set(t) {\n        if (t === this.current && !this.dirty) return;\n        this.context.bindFramebuffer.set(this.parent);\n        const e = this.gl;\n        e.framebufferRenderbuffer(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.RENDERBUFFER, t), this.current = t, this.dirty = !1;\n      }\n\n    }\n\n    class bi {\n      constructor(t, e, i, o) {\n        this.context = t, this.width = e, this.height = i;\n        const a = this.framebuffer = t.gl.createFramebuffer();\n        this.colorAttachment = new vi(t, a), o && (this.depthAttachment = new yi(t, a));\n      }\n\n      destroy() {\n        const t = this.context.gl,\n              e = this.colorAttachment.get();\n\n        if (e && t.deleteTexture(e), this.depthAttachment) {\n          const e = this.depthAttachment.get();\n          e && t.deleteRenderbuffer(e);\n        }\n\n        t.deleteFramebuffer(this.framebuffer);\n      }\n\n    }\n\n    class wi {\n      constructor(t, e, i) {\n        this.blendFunction = t, this.blendColor = e, this.mask = i;\n      }\n\n    }\n\n    wi.Replace = [1, 0], wi.disabled = new wi(wi.Replace, t.Color.transparent, [!1, !1, !1, !1]), wi.unblended = new wi(wi.Replace, t.Color.transparent, [!0, !0, !0, !0]), wi.alphaBlended = new wi([1, 771], t.Color.transparent, [!0, !0, !0, !0]);\n\n    class Ti {\n      constructor(t) {\n        this.gl = t, this.extVertexArrayObject = this.gl.getExtension(\"OES_vertex_array_object\"), this.clearColor = new Ge(this), this.clearDepth = new Ze(this), this.clearStencil = new qe(this), this.colorMask = new Ve(this), this.depthMask = new je(this), this.stencilMask = new $e(this), this.stencilFunc = new We(this), this.stencilOp = new Xe(this), this.stencilTest = new He(this), this.depthRange = new Ke(this), this.depthTest = new Ye(this), this.depthFunc = new Je(this), this.blend = new Qe(this), this.blendFunc = new ti(this), this.blendColor = new ei(this), this.blendEquation = new ii(this), this.cullFace = new oi(this), this.cullFaceSide = new ai(this), this.frontFace = new si(this), this.program = new ri(this), this.activeTexture = new ni(this), this.viewport = new li(this), this.bindFramebuffer = new ci(this), this.bindRenderbuffer = new hi(this), this.bindTexture = new ui(this), this.bindVertexBuffer = new di(this), this.bindElementBuffer = new mi(this), this.bindVertexArrayOES = this.extVertexArrayObject && new _i(this), this.pixelStoreUnpack = new pi(this), this.pixelStoreUnpackPremultiplyAlpha = new fi(this), this.pixelStoreUnpackFlipY = new gi(this), this.extTextureFilterAnisotropic = t.getExtension(\"EXT_texture_filter_anisotropic\") || t.getExtension(\"MOZ_EXT_texture_filter_anisotropic\") || t.getExtension(\"WEBKIT_EXT_texture_filter_anisotropic\"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = t.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.extTextureHalfFloat = t.getExtension(\"OES_texture_half_float\"), this.extTextureHalfFloat && (t.getExtension(\"OES_texture_half_float_linear\"), this.extRenderToTextureHalfFloat = t.getExtension(\"EXT_color_buffer_half_float\")), this.extTimerQuery = t.getExtension(\"EXT_disjoint_timer_query\"), this.maxTextureSize = t.getParameter(t.MAX_TEXTURE_SIZE);\n      }\n\n      setDefault() {\n        this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();\n      }\n\n      setDirty() {\n        this.clearColor.dirty = !0, this.clearDepth.dirty = !0, this.clearStencil.dirty = !0, this.colorMask.dirty = !0, this.depthMask.dirty = !0, this.stencilMask.dirty = !0, this.stencilFunc.dirty = !0, this.stencilOp.dirty = !0, this.stencilTest.dirty = !0, this.depthRange.dirty = !0, this.depthTest.dirty = !0, this.depthFunc.dirty = !0, this.blend.dirty = !0, this.blendFunc.dirty = !0, this.blendColor.dirty = !0, this.blendEquation.dirty = !0, this.cullFace.dirty = !0, this.cullFaceSide.dirty = !0, this.frontFace.dirty = !0, this.program.dirty = !0, this.activeTexture.dirty = !0, this.viewport.dirty = !0, this.bindFramebuffer.dirty = !0, this.bindRenderbuffer.dirty = !0, this.bindTexture.dirty = !0, this.bindVertexBuffer.dirty = !0, this.bindElementBuffer.dirty = !0, this.extVertexArrayObject && (this.bindVertexArrayOES.dirty = !0), this.pixelStoreUnpack.dirty = !0, this.pixelStoreUnpackPremultiplyAlpha.dirty = !0, this.pixelStoreUnpackFlipY.dirty = !0;\n      }\n\n      createIndexBuffer(t, e) {\n        return new Fe(this, t, e);\n      }\n\n      createVertexBuffer(t, e, i) {\n        return new Ue(this, t, e, i);\n      }\n\n      createRenderbuffer(t, e, i) {\n        const o = this.gl,\n              a = o.createRenderbuffer();\n        return this.bindRenderbuffer.set(a), o.renderbufferStorage(o.RENDERBUFFER, t, e, i), this.bindRenderbuffer.set(null), a;\n      }\n\n      createFramebuffer(t, e, i) {\n        return new bi(this, t, e, i);\n      }\n\n      clear(_ref68) {\n        let {\n          color: t,\n          depth: e\n        } = _ref68;\n        const i = this.gl;\n        let o = 0;\n        t && (o |= i.COLOR_BUFFER_BIT, this.clearColor.set(t), this.colorMask.set([!0, !0, !0, !0])), void 0 !== e && (o |= i.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(e), this.depthMask.set(!0)), i.clear(o);\n      }\n\n      setCullFace(t) {\n        !1 === t.enable ? this.cullFace.set(!1) : (this.cullFace.set(!0), this.cullFaceSide.set(t.mode), this.frontFace.set(t.frontFace));\n      }\n\n      setDepthMode(t) {\n        t.func !== this.gl.ALWAYS || t.mask ? (this.depthTest.set(!0), this.depthFunc.set(t.func), this.depthMask.set(t.mask), this.depthRange.set(t.range)) : this.depthTest.set(!1);\n      }\n\n      setStencilMode(t) {\n        t.test.func !== this.gl.ALWAYS || t.mask ? (this.stencilTest.set(!0), this.stencilMask.set(t.mask), this.stencilOp.set([t.fail, t.depthFail, t.pass]), this.stencilFunc.set({\n          func: t.test.func,\n          ref: t.ref,\n          mask: t.test.mask\n        })) : this.stencilTest.set(!1);\n      }\n\n      setColorMode(t) {\n        a(t.blendFunction, wi.Replace) ? this.blend.set(!1) : (this.blend.set(!0), this.blendFunc.set(t.blendFunction), this.blendColor.set(t.blendColor)), this.colorMask.set(t.mask);\n      }\n\n      unbindVAO() {\n        this.extVertexArrayObject && this.bindVertexArrayOES.set(null);\n      }\n\n    }\n\n    class Ei {\n      constructor(t, e, i) {\n        this.func = t, this.mask = e, this.range = i;\n      }\n\n    }\n\n    Ei.ReadOnly = !1, Ei.ReadWrite = !0, Ei.disabled = new Ei(519, Ei.ReadOnly, [0, 1]);\n    const Ii = 7680;\n\n    class Si {\n      constructor(t, e, i, o, a, s) {\n        this.test = t, this.ref = e, this.mask = i, this.fail = o, this.depthFail = a, this.pass = s;\n      }\n\n    }\n\n    Si.disabled = new Si({\n      func: 519,\n      mask: 0\n    }, 0, 0, Ii, Ii, Ii);\n\n    class Ci {\n      constructor(t, e, i) {\n        this.enable = t, this.mode = e, this.frontFace = i;\n      }\n\n    }\n\n    let Pi;\n\n    function zi(e, i, o, a, s, r, n) {\n      const l = e.context,\n            c = l.gl,\n            h = e.useProgram(\"collisionBox\"),\n            u = [];\n      let d = 0,\n          m = 0;\n\n      for (let _ = 0; _ < a.length; _++) {\n        const p = a[_],\n              f = i.getTile(p),\n              g = f.getBucket(o);\n        if (!g) continue;\n        let x = p.posMatrix;\n        0 === s[0] && 0 === s[1] || (x = e.translatePosMatrix(p.posMatrix, f, s, r));\n        const v = n ? g.textCollisionBox : g.iconCollisionBox,\n              y = g.collisionCircleArray;\n\n        if (y.length > 0) {\n          const i = t.create(),\n                o = x;\n          t.mul(i, g.placementInvProjMatrix, e.transform.glCoordMatrix), t.mul(i, i, g.placementViewportMatrix), u.push({\n            circleArray: y,\n            circleOffset: m,\n            transform: o,\n            invTransform: i\n          }), d += y.length / 4, m = d;\n        }\n\n        v && h.draw(l, c.LINES, Ei.disabled, Si.disabled, e.colorModeForRenderPass(), Ci.disabled, xe(x, e.transform, f), o.id, v.layoutVertexBuffer, v.indexBuffer, v.segments, null, e.transform.zoom, null, null, v.collisionVertexBuffer);\n      }\n\n      if (!n || !u.length) return;\n\n      const _ = e.useProgram(\"collisionCircle\"),\n            p = new t.CollisionCircleLayoutArray();\n\n      p.resize(4 * d), p._trim();\n      let f = 0;\n\n      for (const t of u) for (let e = 0; e < t.circleArray.length / 4; e++) {\n        const i = 4 * e,\n              o = t.circleArray[i + 0],\n              a = t.circleArray[i + 1],\n              s = t.circleArray[i + 2],\n              r = t.circleArray[i + 3];\n        p.emplace(f++, o, a, s, r, 0), p.emplace(f++, o, a, s, r, 1), p.emplace(f++, o, a, s, r, 2), p.emplace(f++, o, a, s, r, 3);\n      }\n\n      (!Pi || Pi.length < 2 * d) && (Pi = function (e) {\n        const i = 2 * e,\n              o = new t.QuadTriangleArray();\n        o.resize(i), o._trim();\n\n        for (let t = 0; t < i; t++) {\n          const e = 6 * t;\n          o.uint16[e + 0] = 4 * t + 0, o.uint16[e + 1] = 4 * t + 1, o.uint16[e + 2] = 4 * t + 2, o.uint16[e + 3] = 4 * t + 2, o.uint16[e + 4] = 4 * t + 3, o.uint16[e + 5] = 4 * t + 0;\n        }\n\n        return o;\n      }(d));\n      const g = l.createIndexBuffer(Pi, !0),\n            x = l.createVertexBuffer(p, t.collisionCircleLayout.members, !0);\n\n      for (const i of u) {\n        const a = {\n          u_matrix: i.transform,\n          u_inv_matrix: i.invTransform,\n          u_camera_to_center_distance: (v = e.transform).cameraToCenterDistance,\n          u_viewport_size: [v.width, v.height]\n        };\n\n        _.draw(l, c.TRIANGLES, Ei.disabled, Si.disabled, e.colorModeForRenderPass(), Ci.disabled, a, o.id, x, g, t.SegmentVector.simpleSegment(0, 2 * i.circleOffset, i.circleArray.length, i.circleArray.length / 2), null, e.transform.zoom, null, null, null);\n      }\n\n      var v;\n      x.destroy(), g.destroy();\n    }\n\n    Ci.disabled = new Ci(!1, 1029, 2305), Ci.backCCW = new Ci(!0, 1029, 2305);\n    const Di = t.identity(new Float32Array(16));\n\n    function Ai(e, i, o, a, s, r) {\n      const {\n        horizontalAlign: n,\n        verticalAlign: l\n      } = t.getAnchorAlignment(e),\n            c = -(n - .5) * i,\n            h = -(l - .5) * o,\n            u = t.evaluateVariableOffset(e, a);\n      return new t.pointGeometry((c / s + u[0]) * r, (h / s + u[1]) * r);\n    }\n\n    function Mi(e, i, o, a, s, r, n, l, c, h, u) {\n      const d = e.text.placedSymbolArray,\n            m = e.text.dynamicLayoutVertexArray,\n            _ = e.icon.dynamicLayoutVertexArray,\n            p = {};\n      m.clear();\n\n      for (let _ = 0; _ < d.length; _++) {\n        const f = d.get(_),\n              g = e.allowVerticalPlacement && !f.placedOrientation,\n              x = f.hidden || !f.crossTileID || g ? null : a[f.crossTileID];\n\n        if (x) {\n          const a = new t.pointGeometry(f.anchorX, f.anchorY),\n                d = dt(a, o ? l : n),\n                _ = mt(r.cameraToCenterDistance, d.signedDistanceFromCamera);\n\n          let g = s.evaluateSizeForFeature(e.textSizeData, h, f) * _ / t.ONE_EM;\n          o && (g *= e.tilePixelRatio / c);\n          const {\n            width: v,\n            height: y,\n            anchor: b,\n            textOffset: w,\n            textBoxScale: T\n          } = x,\n                E = Ai(b, v, y, w, T, g),\n                I = o ? dt(a.add(E), n).point : d.point.add(i ? E.rotate(-r.angle) : E),\n                S = e.allowVerticalPlacement && f.placedOrientation === t.WritingMode.vertical ? Math.PI / 2 : 0;\n\n          for (let e = 0; e < f.numGlyphs; e++) t.addDynamicAttributes(m, I, S);\n\n          u && f.associatedIconIndex >= 0 && (p[f.associatedIconIndex] = {\n            shiftedAnchor: I,\n            angle: S\n          });\n        } else wt(f.numGlyphs, m);\n      }\n\n      if (u) {\n        _.clear();\n\n        const i = e.icon.placedSymbolArray;\n\n        for (let e = 0; e < i.length; e++) {\n          const o = i.get(e);\n          if (o.hidden) wt(o.numGlyphs, _);else {\n            const i = p[e];\n            if (i) for (let e = 0; e < o.numGlyphs; e++) t.addDynamicAttributes(_, i.shiftedAnchor, i.angle);else wt(o.numGlyphs, _);\n          }\n        }\n\n        e.icon.dynamicLayoutVertexBuffer.updateData(_);\n      }\n\n      e.text.dynamicLayoutVertexBuffer.updateData(m);\n    }\n\n    function Li(t, e, i) {\n      return i.iconsInText && e ? \"symbolTextAndIcon\" : t ? \"symbolSDF\" : \"symbolIcon\";\n    }\n\n    function Ri(e, i, o, a, s, r, n, l, c, h, u, d) {\n      const m = e.context,\n            _ = m.gl,\n            p = e.transform,\n            f = \"map\" === l,\n            g = \"map\" === c,\n            x = f && \"point\" !== o.layout.get(\"symbol-placement\"),\n            v = f && !g && !x,\n            y = !o.layout.get(\"symbol-sort-key\").isConstant();\n      let b = !1;\n      const w = e.depthModeForSublayer(0, Ei.ReadOnly),\n            T = o.layout.get(\"text-variable-anchor\"),\n            E = [];\n\n      for (const l of a) {\n        const a = i.getTile(l),\n              c = a.getBucket(o);\n        if (!c) continue;\n        const u = s ? c.text : c.icon;\n        if (!u || !u.segments.get().length) continue;\n        const d = u.programConfigurations.get(o.id),\n              m = s || c.sdfIcons,\n              w = s ? c.textSizeData : c.iconSizeData,\n              I = g || 0 !== p.pitch,\n              S = e.useProgram(Li(m, s, c), d),\n              C = t.evaluateSizeForZoom(w, p.zoom);\n        let P,\n            z,\n            D,\n            A,\n            M = [0, 0],\n            L = null;\n\n        if (s) {\n          if (z = a.glyphAtlasTexture, D = _.LINEAR, P = a.glyphAtlasTexture.size, c.iconsInText) {\n            M = a.imageAtlasTexture.size, L = a.imageAtlasTexture;\n            const t = \"composite\" === w.kind || \"camera\" === w.kind;\n            A = I || e.options.rotating || e.options.zooming || t ? _.LINEAR : _.NEAREST;\n          }\n        } else {\n          const t = 1 !== o.layout.get(\"icon-size\").constantOr(0) || c.iconsNeedLinear;\n          z = a.imageAtlasTexture, D = m || e.options.rotating || e.options.zooming || t || I ? _.LINEAR : _.NEAREST, P = a.imageAtlasTexture.size;\n        }\n\n        const R = St(a, 1, e.transform.zoom),\n              k = ht(l.posMatrix, g, f, e.transform, R),\n              B = ut(l.posMatrix, g, f, e.transform, R),\n              F = T && c.hasTextData(),\n              O = \"none\" !== o.layout.get(\"icon-text-fit\") && F && c.hasIconData();\n        x && pt(c, l.posMatrix, e, s, k, B, g, h);\n        const U = e.translatePosMatrix(l.posMatrix, a, r, n),\n              N = x || s && T || O ? Di : k,\n              G = e.translatePosMatrix(B, a, r, n, !0),\n              Z = m && 0 !== o.paint.get(s ? \"text-halo-width\" : \"icon-halo-width\").constantOr(1);\n        let q;\n        q = m ? c.iconsInText ? Le(w.kind, C, v, g, e, U, N, G, P, M) : Me(w.kind, C, v, g, e, U, N, G, s, P, !0) : Ae(w.kind, C, v, g, e, U, N, G, s, P);\n        const V = {\n          program: S,\n          buffers: u,\n          uniformValues: q,\n          atlasTexture: z,\n          atlasTextureIcon: L,\n          atlasInterpolation: D,\n          atlasInterpolationIcon: A,\n          isSDF: m,\n          hasHalo: Z\n        };\n\n        if (y && c.canOverlap) {\n          b = !0;\n          const e = u.segments.get();\n\n          for (const i of e) E.push({\n            segments: new t.SegmentVector([i]),\n            sortKey: i.sortKey,\n            state: V\n          });\n        } else E.push({\n          segments: u.segments,\n          sortKey: 0,\n          state: V\n        });\n      }\n\n      b && E.sort((t, e) => t.sortKey - e.sortKey);\n\n      for (const t of E) {\n        const i = t.state;\n\n        if (m.activeTexture.set(_.TEXTURE0), i.atlasTexture.bind(i.atlasInterpolation, _.CLAMP_TO_EDGE), i.atlasTextureIcon && (m.activeTexture.set(_.TEXTURE1), i.atlasTextureIcon && i.atlasTextureIcon.bind(i.atlasInterpolationIcon, _.CLAMP_TO_EDGE)), i.isSDF) {\n          const a = i.uniformValues;\n          i.hasHalo && (a.u_is_halo = 1, ki(i.buffers, t.segments, o, e, i.program, w, u, d, a)), a.u_is_halo = 0;\n        }\n\n        ki(i.buffers, t.segments, o, e, i.program, w, u, d, i.uniformValues);\n      }\n    }\n\n    function ki(t, e, i, o, a, s, r, n, l) {\n      const c = o.context;\n      a.draw(c, c.gl.TRIANGLES, s, r, n, Ci.disabled, l, i.id, t.layoutVertexBuffer, t.indexBuffer, e, i.paint, o.transform.zoom, t.programConfigurations.get(i.id), t.dynamicLayoutVertexBuffer, t.opacityVertexBuffer);\n    }\n\n    function Bi(t, e, i, o, a, s, r) {\n      const n = t.context.gl,\n            l = i.paint.get(\"fill-pattern\"),\n            c = l && l.constantOr(1),\n            h = i.getCrossfadeParameters();\n\n      let u, d, m, _, p;\n\n      r ? (d = c && !i.getPaintProperty(\"fill-outline-color\") ? \"fillOutlinePattern\" : \"fillOutline\", u = n.LINES) : (d = c ? \"fillPattern\" : \"fill\", u = n.TRIANGLES);\n\n      for (const f of o) {\n        const o = e.getTile(f);\n        if (c && !o.patternsLoaded()) continue;\n        const g = o.getBucket(i);\n        if (!g) continue;\n        const x = g.programConfigurations.get(i.id),\n              v = t.useProgram(d, x);\n        c && (t.context.activeTexture.set(n.TEXTURE0), o.imageAtlasTexture.bind(n.LINEAR, n.CLAMP_TO_EDGE), x.updatePaintBuffers(h));\n        const y = l.constantOr(null);\n\n        if (y && o.imageAtlas) {\n          const t = o.imageAtlas,\n                e = t.patternPositions[y.to.toString()],\n                i = t.patternPositions[y.from.toString()];\n          e && i && x.setConstantPatternPositions(e, i);\n        }\n\n        const b = t.translatePosMatrix(f.posMatrix, o, i.paint.get(\"fill-translate\"), i.paint.get(\"fill-translate-anchor\"));\n\n        if (r) {\n          _ = g.indexBuffer2, p = g.segments2;\n          const e = [n.drawingBufferWidth, n.drawingBufferHeight];\n          m = \"fillOutlinePattern\" === d && c ? fe(b, t, h, o, e) : pe(b, e);\n        } else _ = g.indexBuffer, p = g.segments, m = c ? _e(b, t, h, o) : me(b);\n\n        v.draw(t.context, u, a, t.stencilModeForClipping(f), s, Ci.disabled, m, i.id, g.layoutVertexBuffer, _, p, i.paint, t.transform.zoom, x);\n      }\n    }\n\n    function Fi(t, e, i, o, a, s, r) {\n      const n = t.context,\n            l = n.gl,\n            c = i.paint.get(\"fill-extrusion-pattern\"),\n            h = c.constantOr(1),\n            u = i.getCrossfadeParameters(),\n            d = i.paint.get(\"fill-extrusion-opacity\");\n\n      for (const m of o) {\n        const o = e.getTile(m),\n              _ = o.getBucket(i);\n\n        if (!_) continue;\n\n        const p = _.programConfigurations.get(i.id),\n              f = t.useProgram(h ? \"fillExtrusionPattern\" : \"fillExtrusion\", p);\n\n        h && (t.context.activeTexture.set(l.TEXTURE0), o.imageAtlasTexture.bind(l.LINEAR, l.CLAMP_TO_EDGE), p.updatePaintBuffers(u));\n        const g = c.constantOr(null);\n\n        if (g && o.imageAtlas) {\n          const t = o.imageAtlas,\n                e = t.patternPositions[g.to.toString()],\n                i = t.patternPositions[g.from.toString()];\n          e && i && p.setConstantPatternPositions(e, i);\n        }\n\n        const x = t.translatePosMatrix(m.posMatrix, o, i.paint.get(\"fill-extrusion-translate\"), i.paint.get(\"fill-extrusion-translate-anchor\")),\n              v = i.paint.get(\"fill-extrusion-vertical-gradient\"),\n              y = h ? de(x, t, v, d, m, u, o) : ue(x, t, v, d);\n        f.draw(n, n.gl.TRIANGLES, a, s, r, Ci.backCCW, y, i.id, _.layoutVertexBuffer, _.indexBuffer, _.segments, i.paint, t.transform.zoom, p);\n      }\n    }\n\n    function Oi(t, e, i, o, a, s) {\n      const r = t.context,\n            n = r.gl,\n            l = e.fbo;\n      if (!l) return;\n      const c = t.useProgram(\"hillshade\");\n      r.activeTexture.set(n.TEXTURE0), n.bindTexture(n.TEXTURE_2D, l.colorAttachment.get());\n\n      const h = ((t, e, i) => {\n        const o = i.paint.get(\"hillshade-shadow-color\"),\n              a = i.paint.get(\"hillshade-highlight-color\"),\n              s = i.paint.get(\"hillshade-accent-color\");\n        let r = i.paint.get(\"hillshade-illumination-direction\") * (Math.PI / 180);\n        \"viewport\" === i.paint.get(\"hillshade-illumination-anchor\") && (r -= t.transform.angle);\n        const n = !t.options.moving;\n        return {\n          u_matrix: t.transform.calculatePosMatrix(e.tileID.toUnwrapped(), n),\n          u_image: 0,\n          u_latrange: we(0, e.tileID),\n          u_light: [i.paint.get(\"hillshade-exaggeration\"), r],\n          u_shadow: o,\n          u_highlight: a,\n          u_accent: s\n        };\n      })(t, e, i);\n\n      c.draw(r, n.TRIANGLES, o, a, s, Ci.disabled, h, i.id, t.rasterBoundsBuffer, t.quadTriangleIndexBuffer, t.rasterBoundsSegments);\n    }\n\n    function Ui(e, i, o, a, s, r) {\n      const n = e.context,\n            l = n.gl,\n            c = i.dem;\n\n      if (c && c.data) {\n        const h = c.dim,\n              u = c.stride,\n              d = c.getPixels();\n\n        if (n.activeTexture.set(l.TEXTURE1), n.pixelStoreUnpackPremultiplyAlpha.set(!1), i.demTexture = i.demTexture || e.getTileTexture(u), i.demTexture) {\n          const t = i.demTexture;\n          t.update(d, {\n            premultiply: !1\n          }), t.bind(l.NEAREST, l.CLAMP_TO_EDGE);\n        } else i.demTexture = new m(n, d, l.RGBA, {\n          premultiply: !1\n        }), i.demTexture.bind(l.NEAREST, l.CLAMP_TO_EDGE);\n\n        n.activeTexture.set(l.TEXTURE0);\n        let _ = i.fbo;\n\n        if (!_) {\n          const t = new m(n, {\n            width: h,\n            height: h,\n            data: null\n          }, l.RGBA);\n          t.bind(l.LINEAR, l.CLAMP_TO_EDGE), _ = i.fbo = n.createFramebuffer(h, h, !0), _.colorAttachment.set(t.texture);\n        }\n\n        n.bindFramebuffer.set(_.framebuffer), n.viewport.set([0, 0, h, h]), e.useProgram(\"hillshadePrepare\").draw(n, l.TRIANGLES, a, s, r, Ci.disabled, ((e, i) => {\n          const o = i.stride,\n                a = t.create();\n          return t.ortho(a, 0, t.EXTENT, -t.EXTENT, 0, 0, 1), t.translate(a, a, [0, -t.EXTENT, 0]), {\n            u_matrix: a,\n            u_image: 1,\n            u_dimension: [o, o],\n            u_zoom: e.overscaledZ,\n            u_unpack: i.getUnpackVector()\n          };\n        })(i.tileID, c), o.id, e.rasterBoundsBuffer, e.quadTriangleIndexBuffer, e.rasterBoundsSegments), i.needsHillshadePrepare = !1;\n      }\n    }\n\n    function Ni(e, i, o, a, s) {\n      const r = a.paint.get(\"raster-fade-duration\");\n\n      if (r > 0) {\n        const a = t.exported.now(),\n              n = (a - e.timeAdded) / r,\n              l = i ? (a - i.timeAdded) / r : -1,\n              c = o.getSource(),\n              h = s.coveringZoomLevel({\n          tileSize: c.tileSize,\n          roundZoom: c.roundZoom\n        }),\n              u = !i || Math.abs(i.tileID.overscaledZ - h) > Math.abs(e.tileID.overscaledZ - h),\n              d = u && e.refreshedUponExpiration ? 1 : t.clamp(u ? n : 1 - l, 0, 1);\n        return e.refreshedUponExpiration && n >= 1 && (e.refreshedUponExpiration = !1), i ? {\n          opacity: 1,\n          mix: 1 - d\n        } : {\n          opacity: d,\n          mix: 0\n        };\n      }\n\n      return {\n        opacity: 1,\n        mix: 0\n      };\n    }\n\n    const Gi = new t.Color(1, 0, 0, 1),\n          Zi = new t.Color(0, 1, 0, 1),\n          qi = new t.Color(0, 0, 1, 1),\n          Vi = new t.Color(1, 0, 1, 1),\n          ji = new t.Color(0, 1, 1, 1);\n\n    function $i(t, e, i, o) {\n      Xi(t, 0, e + i / 2, t.transform.width, i, o);\n    }\n\n    function Wi(t, e, i, o) {\n      Xi(t, e - i / 2, 0, i, t.transform.height, o);\n    }\n\n    function Xi(t, e, i, o, a, s) {\n      const r = t.context,\n            n = r.gl;\n      n.enable(n.SCISSOR_TEST), n.scissor(e * t.pixelRatio, i * t.pixelRatio, o * t.pixelRatio, a * t.pixelRatio), r.clear({\n        color: s\n      }), n.disable(n.SCISSOR_TEST);\n    }\n\n    function Hi(e, i, o) {\n      const a = e.context,\n            s = a.gl,\n            r = o.posMatrix,\n            n = e.useProgram(\"debug\"),\n            l = Ei.disabled,\n            c = Si.disabled,\n            h = e.colorModeForRenderPass(),\n            u = \"$debug\";\n      a.activeTexture.set(s.TEXTURE0), e.emptyTexture.bind(s.LINEAR, s.CLAMP_TO_EDGE), n.draw(a, s.LINE_STRIP, l, c, h, Ci.disabled, ve(r, t.Color.red), u, e.debugBuffer, e.tileBorderIndexBuffer, e.debugSegments);\n      const d = i.getTileByID(o.key).latestRawTileData,\n            m = Math.floor((d && d.byteLength || 0) / 1024),\n            _ = i.getTile(o).tileSize,\n            p = 512 / Math.min(_, 512) * (o.overscaledZ / e.transform.zoom) * .5;\n      let f = o.canonical.toString();\n      o.overscaledZ !== o.canonical.z && (f += ` => ${o.overscaledZ}`), function (t, e) {\n        t.initDebugOverlayCanvas();\n        const i = t.debugOverlayCanvas,\n              o = t.context.gl,\n              a = t.debugOverlayCanvas.getContext(\"2d\");\n        a.clearRect(0, 0, i.width, i.height), a.shadowColor = \"white\", a.shadowBlur = 2, a.lineWidth = 1.5, a.strokeStyle = \"white\", a.textBaseline = \"top\", a.font = \"bold 36px Open Sans, sans-serif\", a.fillText(e, 5, 5), a.strokeText(e, 5, 5), t.debugOverlayTexture.update(i), t.debugOverlayTexture.bind(o.LINEAR, o.CLAMP_TO_EDGE);\n      }(e, `${f} ${m}kb`), n.draw(a, s.TRIANGLES, l, c, wi.alphaBlended, Ci.disabled, ve(r, t.Color.transparent, p), u, e.debugBuffer, e.quadTriangleIndexBuffer, e.debugSegments);\n    }\n\n    const Ki = {\n      symbol: function (e, i, o, a, s) {\n        if (\"translucent\" !== e.renderPass) return;\n        const r = Si.disabled,\n              n = e.colorModeForRenderPass();\n        o.layout.get(\"text-variable-anchor\") && function (e, i, o, a, s, r, n) {\n          const l = i.transform,\n                c = \"map\" === s,\n                h = \"map\" === r;\n\n          for (const s of e) {\n            const e = a.getTile(s),\n                  r = e.getBucket(o);\n            if (!r || !r.text || !r.text.segments.get().length) continue;\n\n            const u = t.evaluateSizeForZoom(r.textSizeData, l.zoom),\n                  d = St(e, 1, i.transform.zoom),\n                  m = ht(s.posMatrix, h, c, i.transform, d),\n                  _ = \"none\" !== o.layout.get(\"icon-text-fit\") && r.hasIconData();\n\n            if (u) {\n              const i = Math.pow(2, l.zoom - e.tileID.overscaledZ);\n              Mi(r, c, h, n, t.symbolSize, l, m, s.posMatrix, i, u, _);\n            }\n          }\n        }(a, e, o, i, o.layout.get(\"text-rotation-alignment\"), o.layout.get(\"text-pitch-alignment\"), s), 0 !== o.paint.get(\"icon-opacity\").constantOr(1) && Ri(e, i, o, a, !1, o.paint.get(\"icon-translate\"), o.paint.get(\"icon-translate-anchor\"), o.layout.get(\"icon-rotation-alignment\"), o.layout.get(\"icon-pitch-alignment\"), o.layout.get(\"icon-keep-upright\"), r, n), 0 !== o.paint.get(\"text-opacity\").constantOr(1) && Ri(e, i, o, a, !0, o.paint.get(\"text-translate\"), o.paint.get(\"text-translate-anchor\"), o.layout.get(\"text-rotation-alignment\"), o.layout.get(\"text-pitch-alignment\"), o.layout.get(\"text-keep-upright\"), r, n), i.map.showCollisionBoxes && (zi(e, i, o, a, o.paint.get(\"text-translate\"), o.paint.get(\"text-translate-anchor\"), !0), zi(e, i, o, a, o.paint.get(\"icon-translate\"), o.paint.get(\"icon-translate-anchor\"), !1));\n      },\n      circle: function (e, i, o, a) {\n        if (\"translucent\" !== e.renderPass) return;\n        const s = o.paint.get(\"circle-opacity\"),\n              r = o.paint.get(\"circle-stroke-width\"),\n              n = o.paint.get(\"circle-stroke-opacity\"),\n              l = !o.layout.get(\"circle-sort-key\").isConstant();\n        if (0 === s.constantOr(1) && (0 === r.constantOr(1) || 0 === n.constantOr(1))) return;\n        const c = e.context,\n              h = c.gl,\n              u = e.depthModeForSublayer(0, Ei.ReadOnly),\n              d = Si.disabled,\n              m = e.colorModeForRenderPass(),\n              _ = [];\n\n        for (let s = 0; s < a.length; s++) {\n          const r = a[s],\n                n = i.getTile(r),\n                c = n.getBucket(o);\n          if (!c) continue;\n          const h = c.programConfigurations.get(o.id),\n                u = {\n            programConfiguration: h,\n            program: e.useProgram(\"circle\", h),\n            layoutVertexBuffer: c.layoutVertexBuffer,\n            indexBuffer: c.indexBuffer,\n            uniformValues: ge(e, r, n, o)\n          };\n\n          if (l) {\n            const e = c.segments.get();\n\n            for (const i of e) _.push({\n              segments: new t.SegmentVector([i]),\n              sortKey: i.sortKey,\n              state: u\n            });\n          } else _.push({\n            segments: c.segments,\n            sortKey: 0,\n            state: u\n          });\n        }\n\n        l && _.sort((t, e) => t.sortKey - e.sortKey);\n\n        for (const t of _) {\n          const {\n            programConfiguration: i,\n            program: a,\n            layoutVertexBuffer: s,\n            indexBuffer: r,\n            uniformValues: n\n          } = t.state;\n          a.draw(c, h.TRIANGLES, u, d, m, Ci.disabled, n, o.id, s, r, t.segments, o.paint, e.transform.zoom, i);\n        }\n      },\n      heatmap: function (e, i, o, a) {\n        if (0 !== o.paint.get(\"heatmap-opacity\")) if (\"offscreen\" === e.renderPass) {\n          const s = e.context,\n                r = s.gl,\n                n = Si.disabled,\n                l = new wi([r.ONE, r.ONE], t.Color.transparent, [!0, !0, !0, !0]);\n          !function (t, e, i) {\n            const o = t.gl;\n            t.activeTexture.set(o.TEXTURE1), t.viewport.set([0, 0, e.width / 4, e.height / 4]);\n            let a = i.heatmapFbo;\n            if (a) o.bindTexture(o.TEXTURE_2D, a.colorAttachment.get()), t.bindFramebuffer.set(a.framebuffer);else {\n              const s = o.createTexture();\n              o.bindTexture(o.TEXTURE_2D, s), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_WRAP_S, o.CLAMP_TO_EDGE), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_WRAP_T, o.CLAMP_TO_EDGE), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_MIN_FILTER, o.LINEAR), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_MAG_FILTER, o.LINEAR), a = i.heatmapFbo = t.createFramebuffer(e.width / 4, e.height / 4, !1), function (t, e, i, o) {\n                const a = t.gl;\n                a.texImage2D(a.TEXTURE_2D, 0, a.RGBA, e.width / 4, e.height / 4, 0, a.RGBA, t.extRenderToTextureHalfFloat ? t.extTextureHalfFloat.HALF_FLOAT_OES : a.UNSIGNED_BYTE, null), o.colorAttachment.set(i);\n              }(t, e, s, a);\n            }\n          }(s, e, o), s.clear({\n            color: t.Color.transparent\n          });\n\n          for (let t = 0; t < a.length; t++) {\n            const c = a[t];\n            if (i.hasRenderableParent(c)) continue;\n            const h = i.getTile(c),\n                  u = h.getBucket(o);\n            if (!u) continue;\n            const d = u.programConfigurations.get(o.id),\n                  m = e.useProgram(\"heatmap\", d),\n                  {\n              zoom: _\n            } = e.transform;\n            m.draw(s, r.TRIANGLES, Ei.disabled, n, l, Ci.disabled, be(c.posMatrix, h, _, o.paint.get(\"heatmap-intensity\")), o.id, u.layoutVertexBuffer, u.indexBuffer, u.segments, o.paint, e.transform.zoom, d);\n          }\n\n          s.viewport.set([0, 0, e.width, e.height]);\n        } else \"translucent\" === e.renderPass && (e.context.setColorMode(e.colorModeForRenderPass()), function (e, i) {\n          const o = e.context,\n                a = o.gl,\n                s = i.heatmapFbo;\n          if (!s) return;\n          o.activeTexture.set(a.TEXTURE0), a.bindTexture(a.TEXTURE_2D, s.colorAttachment.get()), o.activeTexture.set(a.TEXTURE1);\n          let r = i.colorRampTexture;\n          r || (r = i.colorRampTexture = new m(o, i.colorRamp, a.RGBA)), r.bind(a.LINEAR, a.CLAMP_TO_EDGE), e.useProgram(\"heatmapTexture\").draw(o, a.TRIANGLES, Ei.disabled, Si.disabled, e.colorModeForRenderPass(), Ci.disabled, ((e, i, o, a) => {\n            const s = t.create();\n            t.ortho(s, 0, e.width, e.height, 0, 0, 1);\n            const r = e.context.gl;\n            return {\n              u_matrix: s,\n              u_world: [r.drawingBufferWidth, r.drawingBufferHeight],\n              u_image: 0,\n              u_color_ramp: 1,\n              u_opacity: i.paint.get(\"heatmap-opacity\")\n            };\n          })(e, i), i.id, e.viewportBuffer, e.quadTriangleIndexBuffer, e.viewportSegments, i.paint, e.transform.zoom);\n        }(e, o));\n      },\n      line: function (e, i, o, a) {\n        if (\"translucent\" !== e.renderPass) return;\n        const s = o.paint.get(\"line-opacity\"),\n              r = o.paint.get(\"line-width\");\n        if (0 === s.constantOr(1) || 0 === r.constantOr(1)) return;\n\n        const n = e.depthModeForSublayer(0, Ei.ReadOnly),\n              l = e.colorModeForRenderPass(),\n              c = o.paint.get(\"line-dasharray\"),\n              h = o.paint.get(\"line-pattern\"),\n              u = h.constantOr(1),\n              d = o.paint.get(\"line-gradient\"),\n              _ = o.getCrossfadeParameters(),\n              p = u ? \"linePattern\" : c ? \"lineSDF\" : d ? \"lineGradient\" : \"line\",\n              f = e.context,\n              g = f.gl;\n\n        let x = !0;\n\n        for (const s of a) {\n          const a = i.getTile(s);\n          if (u && !a.patternsLoaded()) continue;\n          const r = a.getBucket(o);\n          if (!r) continue;\n          const v = r.programConfigurations.get(o.id),\n                y = e.context.program.get(),\n                b = e.useProgram(p, v),\n                w = x || b.program !== y,\n                T = h.constantOr(null);\n\n          if (T && a.imageAtlas) {\n            const t = a.imageAtlas,\n                  e = t.patternPositions[T.to.toString()],\n                  i = t.patternPositions[T.from.toString()];\n            e && i && v.setConstantPatternPositions(e, i);\n          }\n\n          const E = u ? Ie(e, a, o, _) : c ? Se(e, a, o, c, _) : d ? Ee(e, a, o, r.lineClipsArray.length) : Te(e, a, o);\n          if (u) f.activeTexture.set(g.TEXTURE0), a.imageAtlasTexture.bind(g.LINEAR, g.CLAMP_TO_EDGE), v.updatePaintBuffers(_);else if (c && (w || e.lineAtlas.dirty)) f.activeTexture.set(g.TEXTURE0), e.lineAtlas.bind(f);else if (d) {\n            const a = r.gradients[o.id];\n            let n = a.texture;\n\n            if (o.gradientVersion !== a.version) {\n              let l = 256;\n\n              if (o.stepInterpolant) {\n                const o = i.getSource().maxzoom,\n                      a = s.canonical.z === o ? Math.ceil(1 << e.transform.maxZoom - s.canonical.z) : 1;\n                l = t.clamp(t.nextPowerOfTwo(r.maxLineLength / t.EXTENT * 1024 * a), 256, f.maxTextureSize);\n              }\n\n              a.gradient = t.renderColorRamp({\n                expression: o.gradientExpression(),\n                evaluationKey: \"lineProgress\",\n                resolution: l,\n                image: a.gradient || void 0,\n                clips: r.lineClipsArray\n              }), a.texture ? a.texture.update(a.gradient) : a.texture = new m(f, a.gradient, g.RGBA), a.version = o.gradientVersion, n = a.texture;\n            }\n\n            f.activeTexture.set(g.TEXTURE0), n.bind(o.stepInterpolant ? g.NEAREST : g.LINEAR, g.CLAMP_TO_EDGE);\n          }\n          b.draw(f, g.TRIANGLES, n, e.stencilModeForClipping(s), l, Ci.disabled, E, o.id, r.layoutVertexBuffer, r.indexBuffer, r.segments, o.paint, e.transform.zoom, v, r.layoutVertexBuffer2), x = !1;\n        }\n      },\n      fill: function (e, i, o, a) {\n        const s = o.paint.get(\"fill-color\"),\n              r = o.paint.get(\"fill-opacity\");\n        if (0 === r.constantOr(1)) return;\n        const n = e.colorModeForRenderPass(),\n              l = o.paint.get(\"fill-pattern\"),\n              c = e.opaquePassEnabledForLayer() && !l.constantOr(1) && 1 === s.constantOr(t.Color.transparent).a && 1 === r.constantOr(0) ? \"opaque\" : \"translucent\";\n\n        if (e.renderPass === c) {\n          const t = e.depthModeForSublayer(1, \"opaque\" === e.renderPass ? Ei.ReadWrite : Ei.ReadOnly);\n          Bi(e, i, o, a, t, n, !1);\n        }\n\n        if (\"translucent\" === e.renderPass && o.paint.get(\"fill-antialias\")) {\n          const t = e.depthModeForSublayer(o.getPaintProperty(\"fill-outline-color\") ? 2 : 0, Ei.ReadOnly);\n          Bi(e, i, o, a, t, n, !0);\n        }\n      },\n      \"fill-extrusion\": function (t, e, i, o) {\n        const a = i.paint.get(\"fill-extrusion-opacity\");\n\n        if (0 !== a && \"translucent\" === t.renderPass) {\n          const s = new Ei(t.context.gl.LEQUAL, Ei.ReadWrite, t.depthRangeFor3D);\n          if (1 !== a || i.paint.get(\"fill-extrusion-pattern\").constantOr(1)) Fi(t, e, i, o, s, Si.disabled, wi.disabled), Fi(t, e, i, o, s, t.stencilModeFor3D(), t.colorModeForRenderPass());else {\n            const a = t.colorModeForRenderPass();\n            Fi(t, e, i, o, s, Si.disabled, a);\n          }\n        }\n      },\n      hillshade: function (t, e, i, o) {\n        if (\"offscreen\" !== t.renderPass && \"translucent\" !== t.renderPass) return;\n        const a = t.context,\n              s = t.depthModeForSublayer(0, Ei.ReadOnly),\n              r = t.colorModeForRenderPass(),\n              [n, l] = \"translucent\" === t.renderPass ? t.stencilConfigForOverlap(o) : [{}, o];\n\n        for (const o of l) {\n          const a = e.getTile(o);\n          a.needsHillshadePrepare && \"offscreen\" === t.renderPass ? Ui(t, a, i, s, Si.disabled, r) : \"translucent\" === t.renderPass && Oi(t, a, i, s, n[o.overscaledZ], r);\n        }\n\n        a.viewport.set([0, 0, t.width, t.height]);\n      },\n      raster: function (t, e, i, o) {\n        if (\"translucent\" !== t.renderPass) return;\n        if (0 === i.paint.get(\"raster-opacity\")) return;\n        if (!o.length) return;\n        const a = t.context,\n              s = a.gl,\n              r = e.getSource(),\n              n = t.useProgram(\"raster\"),\n              l = t.colorModeForRenderPass(),\n              [c, h] = r instanceof L ? [{}, o] : t.stencilConfigForOverlap(o),\n              u = h[h.length - 1].overscaledZ,\n              d = !t.options.moving;\n\n        for (const o of h) {\n          const h = t.depthModeForSublayer(o.overscaledZ - u, 1 === i.paint.get(\"raster-opacity\") ? Ei.ReadWrite : Ei.ReadOnly, s.LESS),\n                m = e.getTile(o),\n                _ = t.transform.calculatePosMatrix(o.toUnwrapped(), d);\n\n          m.registerFadeDuration(i.paint.get(\"raster-fade-duration\"));\n          const p = e.findLoadedParent(o, 0),\n                f = Ni(m, p, e, i, t.transform);\n          let g, x;\n          const v = \"nearest\" === i.paint.get(\"raster-resampling\") ? s.NEAREST : s.LINEAR;\n          a.activeTexture.set(s.TEXTURE0), m.texture.bind(v, s.CLAMP_TO_EDGE, s.LINEAR_MIPMAP_NEAREST), a.activeTexture.set(s.TEXTURE1), p ? (p.texture.bind(v, s.CLAMP_TO_EDGE, s.LINEAR_MIPMAP_NEAREST), g = Math.pow(2, p.tileID.overscaledZ - m.tileID.overscaledZ), x = [m.tileID.canonical.x * g % 1, m.tileID.canonical.y * g % 1]) : m.texture.bind(v, s.CLAMP_TO_EDGE, s.LINEAR_MIPMAP_NEAREST);\n          const y = ze(_, x || [0, 0], g || 1, f, i);\n          r instanceof L ? n.draw(a, s.TRIANGLES, h, Si.disabled, l, Ci.disabled, y, i.id, r.boundsBuffer, t.quadTriangleIndexBuffer, r.boundsSegments) : n.draw(a, s.TRIANGLES, h, c[o.overscaledZ], l, Ci.disabled, y, i.id, t.rasterBoundsBuffer, t.quadTriangleIndexBuffer, t.rasterBoundsSegments);\n        }\n      },\n      background: function (t, e, i) {\n        const o = i.paint.get(\"background-color\"),\n              a = i.paint.get(\"background-opacity\");\n        if (0 === a) return;\n        const s = t.context,\n              r = s.gl,\n              n = t.transform,\n              l = n.tileSize,\n              c = i.paint.get(\"background-pattern\");\n        if (t.isPatternMissing(c)) return;\n        const h = !c && 1 === o.a && 1 === a && t.opaquePassEnabledForLayer() ? \"opaque\" : \"translucent\";\n        if (t.renderPass !== h) return;\n\n        const u = Si.disabled,\n              d = t.depthModeForSublayer(0, \"opaque\" === h ? Ei.ReadWrite : Ei.ReadOnly),\n              m = t.colorModeForRenderPass(),\n              _ = t.useProgram(c ? \"backgroundPattern\" : \"background\"),\n              p = n.coveringTiles({\n          tileSize: l\n        });\n\n        c && (s.activeTexture.set(r.TEXTURE0), t.imageManager.bind(t.context));\n        const f = i.getCrossfadeParameters();\n\n        for (const e of p) {\n          const n = t.transform.calculatePosMatrix(e.toUnwrapped()),\n                h = c ? ke(n, a, t, c, {\n            tileID: e,\n            tileSize: l\n          }, f) : Re(n, a, o);\n\n          _.draw(s, r.TRIANGLES, d, u, m, Ci.disabled, h, i.id, t.tileExtentBuffer, t.quadTriangleIndexBuffer, t.tileExtentSegments);\n        }\n      },\n      debug: function (t, e, i) {\n        for (let o = 0; o < i.length; o++) Hi(t, e, i[o]);\n      },\n      custom: function (t, e, i) {\n        const o = t.context,\n              a = i.implementation;\n\n        if (\"offscreen\" === t.renderPass) {\n          const e = a.prerender;\n          e && (t.setCustomLayerDefaults(), o.setColorMode(t.colorModeForRenderPass()), e.call(a, o.gl, t.transform.customLayerMatrix()), o.setDirty(), t.setBaseState());\n        } else if (\"translucent\" === t.renderPass) {\n          t.setCustomLayerDefaults(), o.setColorMode(t.colorModeForRenderPass()), o.setStencilMode(Si.disabled);\n          const e = \"3d\" === a.renderingMode ? new Ei(t.context.gl.LEQUAL, Ei.ReadWrite, t.depthRangeFor3D) : t.depthModeForSublayer(0, Ei.ReadOnly);\n          o.setDepthMode(e), a.render(o.gl, t.transform.customLayerMatrix()), o.setDirty(), t.setBaseState(), o.bindFramebuffer.set(null);\n        }\n      }\n    };\n\n    class Yi {\n      constructor(t, e) {\n        this.context = new Ti(t), this.transform = e, this._tileTextures = {}, this.setup(), this.numSublayers = q.maxUnderzooming + q.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new Jt(), this.gpuTimers = {};\n      }\n\n      resize(t, e, i) {\n        if (this.width = t * i, this.height = e * i, this.pixelRatio = i, this.context.viewport.set([0, 0, this.width, this.height]), this.style) for (const t of this.style._order) this.style._layers[t].resize();\n      }\n\n      setup() {\n        const e = this.context,\n              i = new t.PosArray();\n        i.emplaceBack(0, 0), i.emplaceBack(t.EXTENT, 0), i.emplaceBack(0, t.EXTENT), i.emplaceBack(t.EXTENT, t.EXTENT), this.tileExtentBuffer = e.createVertexBuffer(i, ae.members), this.tileExtentSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2);\n        const o = new t.PosArray();\n        o.emplaceBack(0, 0), o.emplaceBack(t.EXTENT, 0), o.emplaceBack(0, t.EXTENT), o.emplaceBack(t.EXTENT, t.EXTENT), this.debugBuffer = e.createVertexBuffer(o, ae.members), this.debugSegments = t.SegmentVector.simpleSegment(0, 0, 4, 5);\n        const a = new t.RasterBoundsArray();\n        a.emplaceBack(0, 0, 0, 0), a.emplaceBack(t.EXTENT, 0, t.EXTENT, 0), a.emplaceBack(0, t.EXTENT, 0, t.EXTENT), a.emplaceBack(t.EXTENT, t.EXTENT, t.EXTENT, t.EXTENT), this.rasterBoundsBuffer = e.createVertexBuffer(a, M.members), this.rasterBoundsSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2);\n        const s = new t.PosArray();\n        s.emplaceBack(0, 0), s.emplaceBack(1, 0), s.emplaceBack(0, 1), s.emplaceBack(1, 1), this.viewportBuffer = e.createVertexBuffer(s, ae.members), this.viewportSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2);\n        const r = new t.LineStripIndexArray();\n        r.emplaceBack(0), r.emplaceBack(1), r.emplaceBack(3), r.emplaceBack(2), r.emplaceBack(0), this.tileBorderIndexBuffer = e.createIndexBuffer(r);\n        const n = new t.TriangleIndexArray();\n        n.emplaceBack(0, 1, 2), n.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = e.createIndexBuffer(n), this.emptyTexture = new m(e, {\n          width: 1,\n          height: 1,\n          data: new Uint8Array([0, 0, 0, 0])\n        }, e.gl.RGBA);\n        const l = this.context.gl;\n        this.stencilClearMode = new Si({\n          func: l.ALWAYS,\n          mask: 0\n        }, 0, 255, l.ZERO, l.ZERO, l.ZERO);\n      }\n\n      clearStencil() {\n        const e = this.context,\n              i = e.gl;\n        this.nextStencilID = 1, this.currentStencilSource = void 0;\n        const o = t.create();\n        t.ortho(o, 0, this.width, this.height, 0, 0, 1), t.scale(o, o, [i.drawingBufferWidth, i.drawingBufferHeight, 0]), this.useProgram(\"clippingMask\").draw(e, i.TRIANGLES, Ei.disabled, this.stencilClearMode, wi.disabled, Ci.disabled, ye(o), \"$clipping\", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);\n      }\n\n      _renderTileClippingMasks(t, e) {\n        if (this.currentStencilSource === t.source || !t.isTileClipped() || !e || !e.length) return;\n        this.currentStencilSource = t.source;\n        const i = this.context,\n              o = i.gl;\n        this.nextStencilID + e.length > 256 && this.clearStencil(), i.setColorMode(wi.disabled), i.setDepthMode(Ei.disabled);\n        const a = this.useProgram(\"clippingMask\");\n        this._tileClippingMaskIDs = {};\n\n        for (const t of e) {\n          const e = this._tileClippingMaskIDs[t.key] = this.nextStencilID++;\n          a.draw(i, o.TRIANGLES, Ei.disabled, new Si({\n            func: o.ALWAYS,\n            mask: 0\n          }, e, 255, o.KEEP, o.KEEP, o.REPLACE), wi.disabled, Ci.disabled, ye(t.posMatrix), \"$clipping\", this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments);\n        }\n      }\n\n      stencilModeFor3D() {\n        this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();\n        const t = this.nextStencilID++,\n              e = this.context.gl;\n        return new Si({\n          func: e.NOTEQUAL,\n          mask: 255\n        }, t, 255, e.KEEP, e.KEEP, e.REPLACE);\n      }\n\n      stencilModeForClipping(t) {\n        const e = this.context.gl;\n        return new Si({\n          func: e.EQUAL,\n          mask: 255\n        }, this._tileClippingMaskIDs[t.key], 0, e.KEEP, e.KEEP, e.REPLACE);\n      }\n\n      stencilConfigForOverlap(t) {\n        const e = this.context.gl,\n              i = t.sort((t, e) => e.overscaledZ - t.overscaledZ),\n              o = i[i.length - 1].overscaledZ,\n              a = i[0].overscaledZ - o + 1;\n\n        if (a > 1) {\n          this.currentStencilSource = void 0, this.nextStencilID + a > 256 && this.clearStencil();\n          const t = {};\n\n          for (let i = 0; i < a; i++) t[i + o] = new Si({\n            func: e.GEQUAL,\n            mask: 255\n          }, i + this.nextStencilID, 255, e.KEEP, e.KEEP, e.REPLACE);\n\n          return this.nextStencilID += a, [t, i];\n        }\n\n        return [{\n          [o]: Si.disabled\n        }, i];\n      }\n\n      colorModeForRenderPass() {\n        const e = this.context.gl;\n\n        if (this._showOverdrawInspector) {\n          const i = 1 / 8;\n          return new wi([e.CONSTANT_COLOR, e.ONE], new t.Color(i, i, i, 0), [!0, !0, !0, !0]);\n        }\n\n        return \"opaque\" === this.renderPass ? wi.unblended : wi.alphaBlended;\n      }\n\n      depthModeForSublayer(t, e, i) {\n        if (!this.opaquePassEnabledForLayer()) return Ei.disabled;\n        const o = 1 - ((1 + this.currentLayer) * this.numSublayers + t) * this.depthEpsilon;\n        return new Ei(i || this.context.gl.LEQUAL, e, [o, o]);\n      }\n\n      opaquePassEnabledForLayer() {\n        return this.currentLayer < this.opaquePassCutoff;\n      }\n\n      render(e, i) {\n        this.style = e, this.options = i, this.lineAtlas = e.lineAtlas, this.imageManager = e.imageManager, this.glyphManager = e.glyphManager, this.symbolFadeChange = e.placement.symbolFadeChange(t.exported.now()), this.imageManager.beginFrame();\n        const o = this.style._order,\n              a = this.style.sourceCaches;\n\n        for (const t in a) {\n          const e = a[t];\n          e.used && e.prepare(this.context);\n        }\n\n        const s = {},\n              r = {},\n              n = {};\n\n        for (const t in a) {\n          const e = a[t];\n          s[t] = e.getVisibleCoordinates(), r[t] = s[t].slice().reverse(), n[t] = e.getVisibleCoordinates(!0).reverse();\n        }\n\n        this.opaquePassCutoff = 1 / 0;\n\n        for (let t = 0; t < o.length; t++) if (this.style._layers[o[t]].is3D()) {\n          this.opaquePassCutoff = t;\n          break;\n        }\n\n        this.renderPass = \"offscreen\";\n\n        for (const t of o) {\n          const e = this.style._layers[t];\n          if (!e.hasOffscreenPass() || e.isHidden(this.transform.zoom)) continue;\n          const i = r[e.source];\n          (\"custom\" === e.type || i.length) && this.renderLayer(this, a[e.source], e, i);\n        }\n\n        for (this.context.bindFramebuffer.set(null), this.context.clear({\n          color: i.showOverdrawInspector ? t.Color.black : t.Color.transparent,\n          depth: 1\n        }), this.clearStencil(), this._showOverdrawInspector = i.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (e._order.length + 2) * this.numSublayers * this.depthEpsilon], this.renderPass = \"opaque\", this.currentLayer = o.length - 1; this.currentLayer >= 0; this.currentLayer--) {\n          const t = this.style._layers[o[this.currentLayer]],\n                e = a[t.source],\n                i = s[t.source];\n          this._renderTileClippingMasks(t, i), this.renderLayer(this, e, t, i);\n        }\n\n        for (this.renderPass = \"translucent\", this.currentLayer = 0; this.currentLayer < o.length; this.currentLayer++) {\n          const t = this.style._layers[o[this.currentLayer]],\n                e = a[t.source],\n                i = (\"symbol\" === t.type ? n : r)[t.source];\n          this._renderTileClippingMasks(t, s[t.source]), this.renderLayer(this, e, t, i);\n        }\n\n        if (this.options.showTileBoundaries) {\n          let t, e;\n          Object.values(this.style._layers).forEach(i => {\n            i.source && !i.isHidden(this.transform.zoom) && (i.source !== (e && e.id) && (e = this.style.sourceCaches[i.source]), (!t || t.getSource().maxzoom < e.getSource().maxzoom) && (t = e));\n          }), t && Ki.debug(this, t, t.getVisibleCoordinates());\n        }\n\n        this.options.showPadding && function (t) {\n          const e = t.transform.padding;\n          $i(t, t.transform.height - (e.top || 0), 3, Gi), $i(t, e.bottom || 0, 3, Zi), Wi(t, e.left || 0, 3, qi), Wi(t, t.transform.width - (e.right || 0), 3, Vi);\n          const i = t.transform.centerPoint;\n          !function (t, e, i, o) {\n            Xi(t, e - 1, i - 10, 2, 20, o), Xi(t, e - 10, i - 1, 20, 2, o);\n          }(t, i.x, t.transform.height - i.y, ji);\n        }(this), this.context.setDefault();\n      }\n\n      renderLayer(t, e, i, o) {\n        i.isHidden(this.transform.zoom) || (\"background\" === i.type || \"custom\" === i.type || o.length) && (this.id = i.id, this.gpuTimingStart(i), Ki[i.type](t, e, i, o, this.style.placement.variableOffsets), this.gpuTimingEnd());\n      }\n\n      gpuTimingStart(t) {\n        if (!this.options.gpuTiming) return;\n        const e = this.context.extTimerQuery;\n        let i = this.gpuTimers[t.id];\n        i || (i = this.gpuTimers[t.id] = {\n          calls: 0,\n          cpuTime: 0,\n          query: e.createQueryEXT()\n        }), i.calls++, e.beginQueryEXT(e.TIME_ELAPSED_EXT, i.query);\n      }\n\n      gpuTimingEnd() {\n        if (!this.options.gpuTiming) return;\n        const t = this.context.extTimerQuery;\n        t.endQueryEXT(t.TIME_ELAPSED_EXT);\n      }\n\n      collectGpuTimers() {\n        const t = this.gpuTimers;\n        return this.gpuTimers = {}, t;\n      }\n\n      queryGpuTimers(t) {\n        const e = {};\n\n        for (const i in t) {\n          const o = t[i],\n                a = this.context.extTimerQuery,\n                s = a.getQueryObjectEXT(o.query, a.QUERY_RESULT_EXT) / 1e6;\n          a.deleteQueryEXT(o.query), e[i] = s;\n        }\n\n        return e;\n      }\n\n      translatePosMatrix(e, i, o, a, s) {\n        if (!o[0] && !o[1]) return e;\n        const r = s ? \"map\" === a ? this.transform.angle : 0 : \"viewport\" === a ? -this.transform.angle : 0;\n\n        if (r) {\n          const t = Math.sin(r),\n                e = Math.cos(r);\n          o = [o[0] * e - o[1] * t, o[0] * t + o[1] * e];\n        }\n\n        const n = c(s ? o[0] : St(i, o[0], this.transform.zoom), s ? o[1] : St(i, o[1], this.transform.zoom), 0),\n              l = new Float32Array(16);\n        return t.translate(l, e, n), l;\n      }\n\n      saveTileTexture(t) {\n        const e = this._tileTextures[t.size[0]];\n        e ? e.push(t) : this._tileTextures[t.size[0]] = [t];\n      }\n\n      getTileTexture(t) {\n        const e = this._tileTextures[t];\n        return e && e.length > 0 ? e.pop() : null;\n      }\n\n      isPatternMissing(t) {\n        if (!t) return !1;\n        if (!t.from || !t.to) return !0;\n        const e = this.imageManager.getPattern(t.from.toString()),\n              i = this.imageManager.getPattern(t.to.toString());\n        return !e || !i;\n      }\n\n      useProgram(t, e) {\n        this.cache = this.cache || {};\n        const i = `${t}${e ? e.cacheKey : \"\"}${this._showOverdrawInspector ? \"/overdraw\" : \"\"}`;\n        return this.cache[i] || (this.cache[i] = new ce(this.context, t, se[t], e, Be[t], this._showOverdrawInspector)), this.cache[i];\n      }\n\n      setCustomLayerDefaults() {\n        this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();\n      }\n\n      setBaseState() {\n        const t = this.context.gl;\n        this.context.cullFace.set(!1), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(t.FUNC_ADD);\n      }\n\n      initDebugOverlayCanvas() {\n        null == this.debugOverlayCanvas && (this.debugOverlayCanvas = document.createElement(\"canvas\"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new m(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));\n      }\n\n      destroy() {\n        this.emptyTexture.destroy(), this.debugOverlayTexture && this.debugOverlayTexture.destroy();\n      }\n\n    }\n\n    class Ji {\n      constructor(t, e) {\n        this.points = t, this.planes = e;\n      }\n\n      static fromInvProjectionMatrix(e, i, o) {\n        const a = Math.pow(2, o),\n              s = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map(i => t.transformMat4([], i, e)).map(e => t.scale$1([], e, 1 / e[3] / i * a)),\n              r = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map(t => {\n          const e = function (t, e) {\n            var i = e[0],\n                o = e[1],\n                a = e[2],\n                s = i * i + o * o + a * a;\n            return s > 0 && (s = 1 / Math.sqrt(s)), t[0] = e[0] * s, t[1] = e[1] * s, t[2] = e[2] * s, t;\n          }([], function (t, e, i) {\n            var o = e[0],\n                a = e[1],\n                s = e[2],\n                r = i[0],\n                n = i[1],\n                l = i[2];\n            return t[0] = a * l - s * n, t[1] = s * r - o * l, t[2] = o * n - a * r, t;\n          }([], u([], s[t[0]], s[t[1]]), u([], s[t[2]], s[t[1]]))),\n                i = -((o = e)[0] * (a = s[t[1]])[0] + o[1] * a[1] + o[2] * a[2]);\n\n          var o, a;\n          return e.concat(i);\n        });\n        return new Ji(s, r);\n      }\n\n    }\n\n    class Qi {\n      constructor(t, e) {\n        this.min = t, this.max = e, this.center = function (t, e, i) {\n          return t[0] = .5 * e[0], t[1] = .5 * e[1], t[2] = .5 * e[2], t;\n        }([], function (t, e, i) {\n          return t[0] = e[0] + i[0], t[1] = e[1] + i[1], t[2] = e[2] + i[2], t;\n        }([], this.min, this.max));\n      }\n\n      quadrant(t) {\n        const e = [t % 2 == 0, t < 2],\n              i = l(this.min),\n              o = l(this.max);\n\n        for (let t = 0; t < e.length; t++) i[t] = e[t] ? this.min[t] : this.center[t], o[t] = e[t] ? this.center[t] : this.max[t];\n\n        return o[2] = this.max[2], new Qi(i, o);\n      }\n\n      distanceX(t) {\n        return Math.max(Math.min(this.max[0], t[0]), this.min[0]) - t[0];\n      }\n\n      distanceY(t) {\n        return Math.max(Math.min(this.max[1], t[1]), this.min[1]) - t[1];\n      }\n\n      intersects(e) {\n        const i = [[this.min[0], this.min[1], 0, 1], [this.max[0], this.min[1], 0, 1], [this.max[0], this.max[1], 0, 1], [this.min[0], this.max[1], 0, 1]];\n        let o = !0;\n\n        for (let a = 0; a < e.planes.length; a++) {\n          const s = e.planes[a];\n          let r = 0;\n\n          for (let e = 0; e < i.length; e++) t.dot(s, i[e]) >= 0 && r++;\n\n          if (0 === r) return 0;\n          r !== i.length && (o = !1);\n        }\n\n        if (o) return 2;\n\n        for (let t = 0; t < 3; t++) {\n          let i = Number.MAX_VALUE,\n              o = -Number.MAX_VALUE;\n\n          for (let a = 0; a < e.points.length; a++) {\n            const s = e.points[a][t] - this.min[t];\n            i = Math.min(i, s), o = Math.max(o, s);\n          }\n\n          if (o < 0 || i > this.max[t] - this.min[t]) return 0;\n        }\n\n        return 1;\n      }\n\n    }\n\n    class to {\n      constructor() {\n        let t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n        let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n        let i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n        let o = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n        if (isNaN(t) || t < 0 || isNaN(e) || e < 0 || isNaN(i) || i < 0 || isNaN(o) || o < 0) throw new Error(\"Invalid value for edge-insets, top, bottom, left and right must all be numbers\");\n        this.top = t, this.bottom = e, this.left = i, this.right = o;\n      }\n\n      interpolate(e, i, o) {\n        return null != i.top && null != e.top && (this.top = t.number(e.top, i.top, o)), null != i.bottom && null != e.bottom && (this.bottom = t.number(e.bottom, i.bottom, o)), null != i.left && null != e.left && (this.left = t.number(e.left, i.left, o)), null != i.right && null != e.right && (this.right = t.number(e.right, i.right, o)), this;\n      }\n\n      getCenter(e, i) {\n        const o = t.clamp((this.left + e - this.right) / 2, 0, e),\n              a = t.clamp((this.top + i - this.bottom) / 2, 0, i);\n        return new t.pointGeometry(o, a);\n      }\n\n      equals(t) {\n        return this.top === t.top && this.bottom === t.bottom && this.left === t.left && this.right === t.right;\n      }\n\n      clone() {\n        return new to(this.top, this.bottom, this.left, this.right);\n      }\n\n      toJSON() {\n        return {\n          top: this.top,\n          bottom: this.bottom,\n          left: this.left,\n          right: this.right\n        };\n      }\n\n    }\n\n    class eo {\n      constructor(e, i, o, a, s) {\n        this.tileSize = 512, this.maxValidLatitude = 85.051129, this._renderWorldCopies = void 0 === s || !!s, this._minZoom = e || 0, this._maxZoom = i || 22, this._minPitch = null == o ? 0 : o, this._maxPitch = null == a ? 60 : a, this.setMaxBounds(), this.width = 0, this.height = 0, this._center = new t.LngLat(0, 0), this.zoom = 0, this.angle = 0, this._fov = .6435011087932844, this._pitch = 0, this._unmodified = !0, this._edgeInsets = new to(), this._posMatrixCache = {}, this._alignedPosMatrixCache = {};\n      }\n\n      clone() {\n        const t = new eo(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies);\n        return t.tileSize = this.tileSize, t.latRange = this.latRange, t.width = this.width, t.height = this.height, t._center = this._center, t.zoom = this.zoom, t.angle = this.angle, t._fov = this._fov, t._pitch = this._pitch, t._unmodified = this._unmodified, t._edgeInsets = this._edgeInsets.clone(), t._calcMatrices(), t;\n      }\n\n      get minZoom() {\n        return this._minZoom;\n      }\n\n      set minZoom(t) {\n        this._minZoom !== t && (this._minZoom = t, this.zoom = Math.max(this.zoom, t));\n      }\n\n      get maxZoom() {\n        return this._maxZoom;\n      }\n\n      set maxZoom(t) {\n        this._maxZoom !== t && (this._maxZoom = t, this.zoom = Math.min(this.zoom, t));\n      }\n\n      get minPitch() {\n        return this._minPitch;\n      }\n\n      set minPitch(t) {\n        this._minPitch !== t && (this._minPitch = t, this.pitch = Math.max(this.pitch, t));\n      }\n\n      get maxPitch() {\n        return this._maxPitch;\n      }\n\n      set maxPitch(t) {\n        this._maxPitch !== t && (this._maxPitch = t, this.pitch = Math.min(this.pitch, t));\n      }\n\n      get renderWorldCopies() {\n        return this._renderWorldCopies;\n      }\n\n      set renderWorldCopies(t) {\n        void 0 === t ? t = !0 : null === t && (t = !1), this._renderWorldCopies = t;\n      }\n\n      get worldSize() {\n        return this.tileSize * this.scale;\n      }\n\n      get centerOffset() {\n        return this.centerPoint._sub(this.size._div(2));\n      }\n\n      get size() {\n        return new t.pointGeometry(this.width, this.height);\n      }\n\n      get bearing() {\n        return -this.angle / Math.PI * 180;\n      }\n\n      set bearing(e) {\n        const i = -t.wrap(e, -180, 180) * Math.PI / 180;\n        this.angle !== i && (this._unmodified = !1, this.angle = i, this._calcMatrices(), this.rotationMatrix = function () {\n          var e = new t.ARRAY_TYPE(4);\n          return t.ARRAY_TYPE != Float32Array && (e[1] = 0, e[2] = 0), e[0] = 1, e[3] = 1, e;\n        }(), function (t, e, i) {\n          var o = e[0],\n              a = e[1],\n              s = e[2],\n              r = e[3],\n              n = Math.sin(i),\n              l = Math.cos(i);\n          t[0] = o * l + s * n, t[1] = a * l + r * n, t[2] = o * -n + s * l, t[3] = a * -n + r * l;\n        }(this.rotationMatrix, this.rotationMatrix, this.angle));\n      }\n\n      get pitch() {\n        return this._pitch / Math.PI * 180;\n      }\n\n      set pitch(e) {\n        const i = t.clamp(e, this.minPitch, this.maxPitch) / 180 * Math.PI;\n        this._pitch !== i && (this._unmodified = !1, this._pitch = i, this._calcMatrices());\n      }\n\n      get fov() {\n        return this._fov / Math.PI * 180;\n      }\n\n      set fov(t) {\n        t = Math.max(.01, Math.min(60, t)), this._fov !== t && (this._unmodified = !1, this._fov = t / 180 * Math.PI, this._calcMatrices());\n      }\n\n      get zoom() {\n        return this._zoom;\n      }\n\n      set zoom(t) {\n        const e = Math.min(Math.max(t, this.minZoom), this.maxZoom);\n        this._zoom !== e && (this._unmodified = !1, this._zoom = e, this.scale = this.zoomScale(e), this.tileZoom = Math.floor(e), this.zoomFraction = e - this.tileZoom, this._constrain(), this._calcMatrices());\n      }\n\n      get center() {\n        return this._center;\n      }\n\n      set center(t) {\n        t.lat === this._center.lat && t.lng === this._center.lng || (this._unmodified = !1, this._center = t, this._constrain(), this._calcMatrices());\n      }\n\n      get padding() {\n        return this._edgeInsets.toJSON();\n      }\n\n      set padding(t) {\n        this._edgeInsets.equals(t) || (this._unmodified = !1, this._edgeInsets.interpolate(this._edgeInsets, t, 1), this._calcMatrices());\n      }\n\n      get centerPoint() {\n        return this._edgeInsets.getCenter(this.width, this.height);\n      }\n\n      isPaddingEqual(t) {\n        return this._edgeInsets.equals(t);\n      }\n\n      interpolatePadding(t, e, i) {\n        this._unmodified = !1, this._edgeInsets.interpolate(t, e, i), this._constrain(), this._calcMatrices();\n      }\n\n      coveringZoomLevel(t) {\n        const e = (t.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / t.tileSize));\n        return Math.max(0, e);\n      }\n\n      getVisibleUnwrappedCoordinates(e) {\n        const i = [new t.UnwrappedTileID(0, e)];\n\n        if (this._renderWorldCopies) {\n          const o = this.pointCoordinate(new t.pointGeometry(0, 0)),\n                a = this.pointCoordinate(new t.pointGeometry(this.width, 0)),\n                s = this.pointCoordinate(new t.pointGeometry(this.width, this.height)),\n                r = this.pointCoordinate(new t.pointGeometry(0, this.height)),\n                n = Math.floor(Math.min(o.x, a.x, s.x, r.x)),\n                l = Math.floor(Math.max(o.x, a.x, s.x, r.x)),\n                c = 1;\n\n          for (let o = n - c; o <= l + c; o++) 0 !== o && i.push(new t.UnwrappedTileID(o, e));\n        }\n\n        return i;\n      }\n\n      coveringTiles(e) {\n        let i = this.coveringZoomLevel(e);\n        const o = i;\n        if (void 0 !== e.minzoom && i < e.minzoom) return [];\n        void 0 !== e.maxzoom && i > e.maxzoom && (i = e.maxzoom);\n        const a = t.MercatorCoordinate.fromLngLat(this.center),\n              s = Math.pow(2, i),\n              r = [s * a.x, s * a.y, 0],\n              n = Ji.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, i);\n        let l = e.minzoom || 0;\n        this.pitch <= 60 && this._edgeInsets.top < .1 && (l = i);\n\n        const c = t => ({\n          aabb: new Qi([t * s, 0, 0], [(t + 1) * s, s, 0]),\n          zoom: 0,\n          x: 0,\n          y: 0,\n          wrap: t,\n          fullyVisible: !1\n        }),\n              h = [],\n              u = [],\n              m = i,\n              _ = e.reparseOverscaled ? o : i;\n\n        if (this._renderWorldCopies) for (let t = 1; t <= 3; t++) h.push(c(-t)), h.push(c(t));\n\n        for (h.push(c(0)); h.length > 0;) {\n          const e = h.pop(),\n                i = e.x,\n                o = e.y;\n          let a = e.fullyVisible;\n\n          if (!a) {\n            const t = e.aabb.intersects(n);\n            if (0 === t) continue;\n            a = 2 === t;\n          }\n\n          const s = e.aabb.distanceX(r),\n                c = e.aabb.distanceY(r),\n                p = Math.max(Math.abs(s), Math.abs(c)),\n                f = 3 + (1 << m - e.zoom) - 2;\n          if (e.zoom === m || p > f && e.zoom >= l) u.push({\n            tileID: new t.OverscaledTileID(e.zoom === m ? _ : e.zoom, e.wrap, e.zoom, i, o),\n            distanceSq: d([r[0] - .5 - i, r[1] - .5 - o])\n          });else for (let t = 0; t < 4; t++) {\n            const s = (i << 1) + t % 2,\n                  r = (o << 1) + (t >> 1);\n            h.push({\n              aabb: e.aabb.quadrant(t),\n              zoom: e.zoom + 1,\n              x: s,\n              y: r,\n              wrap: e.wrap,\n              fullyVisible: a\n            });\n          }\n        }\n\n        return u.sort((t, e) => t.distanceSq - e.distanceSq).map(t => t.tileID);\n      }\n\n      resize(t, e) {\n        this.width = t, this.height = e, this.pixelsToGLUnits = [2 / t, -2 / e], this._constrain(), this._calcMatrices();\n      }\n\n      get unmodified() {\n        return this._unmodified;\n      }\n\n      zoomScale(t) {\n        return Math.pow(2, t);\n      }\n\n      scaleZoom(t) {\n        return Math.log(t) / Math.LN2;\n      }\n\n      project(e) {\n        const i = t.clamp(e.lat, -this.maxValidLatitude, this.maxValidLatitude);\n        return new t.pointGeometry(t.mercatorXfromLng(e.lng) * this.worldSize, t.mercatorYfromLat(i) * this.worldSize);\n      }\n\n      unproject(e) {\n        return new t.MercatorCoordinate(e.x / this.worldSize, e.y / this.worldSize).toLngLat();\n      }\n\n      get point() {\n        return this.project(this.center);\n      }\n\n      setLocationAtPoint(e, i) {\n        const o = this.pointCoordinate(i),\n              a = this.pointCoordinate(this.centerPoint),\n              s = this.locationCoordinate(e),\n              r = new t.MercatorCoordinate(s.x - (o.x - a.x), s.y - (o.y - a.y));\n        this.center = this.coordinateLocation(r), this._renderWorldCopies && (this.center = this.center.wrap());\n      }\n\n      locationPoint(t) {\n        return this.coordinatePoint(this.locationCoordinate(t));\n      }\n\n      pointLocation(t) {\n        return this.coordinateLocation(this.pointCoordinate(t));\n      }\n\n      locationCoordinate(e) {\n        return t.MercatorCoordinate.fromLngLat(e);\n      }\n\n      coordinateLocation(t) {\n        return t.toLngLat();\n      }\n\n      pointCoordinate(e) {\n        const i = [e.x, e.y, 0, 1],\n              o = [e.x, e.y, 1, 1];\n        t.transformMat4(i, i, this.pixelMatrixInverse), t.transformMat4(o, o, this.pixelMatrixInverse);\n        const a = i[3],\n              s = o[3],\n              r = i[1] / a,\n              n = o[1] / s,\n              l = i[2] / a,\n              c = o[2] / s,\n              h = l === c ? 0 : (0 - l) / (c - l);\n        return new t.MercatorCoordinate(t.number(i[0] / a, o[0] / s, h) / this.worldSize, t.number(r, n, h) / this.worldSize);\n      }\n\n      coordinatePoint(e) {\n        const i = [e.x * this.worldSize, e.y * this.worldSize, 0, 1];\n        return t.transformMat4(i, i, this.pixelMatrix), new t.pointGeometry(i[0] / i[3], i[1] / i[3]);\n      }\n\n      getBounds() {\n        return new t.LngLatBounds().extend(this.pointLocation(new t.pointGeometry(0, 0))).extend(this.pointLocation(new t.pointGeometry(this.width, 0))).extend(this.pointLocation(new t.pointGeometry(this.width, this.height))).extend(this.pointLocation(new t.pointGeometry(0, this.height)));\n      }\n\n      getMaxBounds() {\n        return this.latRange && 2 === this.latRange.length && this.lngRange && 2 === this.lngRange.length ? new t.LngLatBounds([this.lngRange[0], this.latRange[0]], [this.lngRange[1], this.latRange[1]]) : null;\n      }\n\n      setMaxBounds(t) {\n        t ? (this.lngRange = [t.getWest(), t.getEast()], this.latRange = [t.getSouth(), t.getNorth()], this._constrain()) : (this.lngRange = null, this.latRange = [-this.maxValidLatitude, this.maxValidLatitude]);\n      }\n\n      calculatePosMatrix(e) {\n        let i = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;\n        const o = e.key,\n              a = i ? this._alignedPosMatrixCache : this._posMatrixCache;\n        if (a[o]) return a[o];\n        const s = e.canonical,\n              r = this.worldSize / this.zoomScale(s.z),\n              n = s.x + Math.pow(2, s.z) * e.wrap,\n              l = t.identity(new Float64Array(16));\n        return t.translate(l, l, [n * r, s.y * r, 0]), t.scale(l, l, [r / t.EXTENT, r / t.EXTENT, 1]), t.multiply(l, i ? this.alignedProjMatrix : this.projMatrix, l), a[o] = new Float32Array(l), a[o];\n      }\n\n      customLayerMatrix() {\n        return this.mercatorMatrix.slice();\n      }\n\n      _constrain() {\n        if (!this.center || !this.width || !this.height || this._constraining) return;\n        this._constraining = !0;\n        let e,\n            i,\n            o,\n            a,\n            s = -90,\n            r = 90,\n            n = -180,\n            l = 180;\n        const c = this.size,\n              h = this._unmodified;\n\n        if (this.latRange) {\n          const i = this.latRange;\n          s = t.mercatorYfromLat(i[1]) * this.worldSize, r = t.mercatorYfromLat(i[0]) * this.worldSize, e = r - s < c.y ? c.y / (r - s) : 0;\n        }\n\n        if (this.lngRange) {\n          const e = this.lngRange;\n          n = t.mercatorXfromLng(e[0]) * this.worldSize, l = t.mercatorXfromLng(e[1]) * this.worldSize, i = l - n < c.x ? c.x / (l - n) : 0;\n        }\n\n        const u = this.point,\n              d = Math.max(i || 0, e || 0);\n        if (d) return this.center = this.unproject(new t.pointGeometry(i ? (l + n) / 2 : u.x, e ? (r + s) / 2 : u.y)), this.zoom += this.scaleZoom(d), this._unmodified = h, void (this._constraining = !1);\n\n        if (this.latRange) {\n          const t = u.y,\n                e = c.y / 2;\n          t - e < s && (a = s + e), t + e > r && (a = r - e);\n        }\n\n        if (this.lngRange) {\n          const t = u.x,\n                e = c.x / 2;\n          t - e < n && (o = n + e), t + e > l && (o = l - e);\n        }\n\n        void 0 === o && void 0 === a || (this.center = this.unproject(new t.pointGeometry(void 0 !== o ? o : u.x, void 0 !== a ? a : u.y))), this._unmodified = h, this._constraining = !1;\n      }\n\n      _calcMatrices() {\n        if (!this.height) return;\n        const e = this.centerOffset;\n        this.cameraToCenterDistance = .5 / Math.tan(this._fov / 2) * this.height;\n        const i = Math.PI / 2 + this._pitch,\n              o = this._fov * (.5 + e.y / this.height),\n              a = Math.sin(o) * this.cameraToCenterDistance / Math.sin(t.clamp(Math.PI - i - o, .01, Math.PI - .01)),\n              s = this.point,\n              r = s.x,\n              n = s.y,\n              l = 1.01 * (Math.cos(Math.PI / 2 - this._pitch) * a + this.cameraToCenterDistance),\n              h = this.height / 50;\n        let u = new Float64Array(16);\n        t.perspective(u, this._fov, this.width / this.height, h, l), u[8] = 2 * -e.x / this.width, u[9] = 2 * e.y / this.height, t.scale(u, u, [1, -1, 1]), t.translate(u, u, [0, 0, -this.cameraToCenterDistance]), t.rotateX(u, u, this._pitch), t.rotateZ(u, u, this.angle), t.translate(u, u, [-r, -n, 0]), this.mercatorMatrix = t.scale([], u, c(this.worldSize, this.worldSize, this.worldSize)), t.scale(u, u, c(1, 1, t.mercatorZfromAltitude(1, this.center.lat) * this.worldSize)), this.projMatrix = u, this.invProjMatrix = t.invert([], this.projMatrix);\n\n        const d = this.width % 2 / 2,\n              m = this.height % 2 / 2,\n              _ = Math.cos(this.angle),\n              p = Math.sin(this.angle),\n              f = r - Math.round(r) + _ * d + p * m,\n              g = n - Math.round(n) + _ * m + p * d,\n              x = new Float64Array(u);\n\n        if (t.translate(x, x, [f > .5 ? f - 1 : f, g > .5 ? g - 1 : g, 0]), this.alignedProjMatrix = x, u = t.create(), t.scale(u, u, [this.width / 2, -this.height / 2, 1]), t.translate(u, u, [1, -1, 0]), this.labelPlaneMatrix = u, u = t.create(), t.scale(u, u, [1, -1, 1]), t.translate(u, u, [-1, -1, 0]), t.scale(u, u, [2 / this.width, 2 / this.height, 1]), this.glCoordMatrix = u, this.pixelMatrix = t.multiply(new Float64Array(16), this.labelPlaneMatrix, this.projMatrix), u = t.invert(new Float64Array(16), this.pixelMatrix), !u) throw new Error(\"failed to invert matrix\");\n        this.pixelMatrixInverse = u, this._posMatrixCache = {}, this._alignedPosMatrixCache = {};\n      }\n\n      maxPitchScaleFactor() {\n        if (!this.pixelMatrixInverse) return 1;\n        const e = this.pointCoordinate(new t.pointGeometry(0, 0)),\n              i = t.fromValues(e.x * this.worldSize, e.y * this.worldSize, 0, 1);\n        return t.transformMat4(i, i, this.pixelMatrix)[3] / this.cameraToCenterDistance;\n      }\n\n      getCameraPoint() {\n        const e = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);\n        return this.centerPoint.add(new t.pointGeometry(0, e));\n      }\n\n      getCameraQueryGeometry(e) {\n        const i = this.getCameraPoint();\n        if (1 === e.length) return [e[0], i];\n        {\n          let o = i.x,\n              a = i.y,\n              s = i.x,\n              r = i.y;\n\n          for (const t of e) o = Math.min(o, t.x), a = Math.min(a, t.y), s = Math.max(s, t.x), r = Math.max(r, t.y);\n\n          return [new t.pointGeometry(o, a), new t.pointGeometry(s, a), new t.pointGeometry(s, r), new t.pointGeometry(o, r), new t.pointGeometry(o, a)];\n        }\n      }\n\n    }\n\n    class io {\n      constructor(e) {\n        this._hashName = e && encodeURIComponent(e), t.bindAll([\"_getCurrentHash\", \"_onHashChange\", \"_updateHash\"], this), this._updateHash = function (t, e) {\n          let i = !1,\n              o = null;\n\n          const a = () => {\n            o = null, i && (t(), o = setTimeout(a, 300), i = !1);\n          };\n\n          return () => (i = !0, o || a(), o);\n        }(this._updateHashUnthrottled.bind(this));\n      }\n\n      addTo(t) {\n        return this._map = t, addEventListener(\"hashchange\", this._onHashChange, !1), this._map.on(\"moveend\", this._updateHash), this;\n      }\n\n      remove() {\n        return removeEventListener(\"hashchange\", this._onHashChange, !1), this._map.off(\"moveend\", this._updateHash), clearTimeout(this._updateHash()), delete this._map, this;\n      }\n\n      getHashString(t) {\n        const e = this._map.getCenter(),\n              i = Math.round(100 * this._map.getZoom()) / 100,\n              o = Math.ceil((i * Math.LN2 + Math.log(512 / 360 / .5)) / Math.LN10),\n              a = Math.pow(10, o),\n              s = Math.round(e.lng * a) / a,\n              r = Math.round(e.lat * a) / a,\n              n = this._map.getBearing(),\n              l = this._map.getPitch();\n\n        let c = \"\";\n\n        if (c += t ? `/${s}/${r}/${i}` : `${i}/${r}/${s}`, (n || l) && (c += \"/\" + Math.round(10 * n) / 10), l && (c += `/${Math.round(l)}`), this._hashName) {\n          const t = this._hashName;\n          let e = !1;\n          const i = window.location.hash.slice(1).split(\"&\").map(i => {\n            const o = i.split(\"=\")[0];\n            return o === t ? (e = !0, `${o}=${c}`) : i;\n          }).filter(t => t);\n          return e || i.push(`${t}=${c}`), `#${i.join(\"&\")}`;\n        }\n\n        return `#${c}`;\n      }\n\n      _getCurrentHash() {\n        const t = window.location.hash.replace(\"#\", \"\");\n\n        if (this._hashName) {\n          let e;\n          return t.split(\"&\").map(t => t.split(\"=\")).forEach(t => {\n            t[0] === this._hashName && (e = t);\n          }), (e && e[1] || \"\").split(\"/\");\n        }\n\n        return t.split(\"/\");\n      }\n\n      _onHashChange() {\n        const t = this._getCurrentHash();\n\n        if (t.length >= 3 && !t.some(t => isNaN(t))) {\n          const e = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(t[3] || 0) : this._map.getBearing();\n          return this._map.jumpTo({\n            center: [+t[2], +t[1]],\n            zoom: +t[0],\n            bearing: e,\n            pitch: +(t[4] || 0)\n          }), !0;\n        }\n\n        return !1;\n      }\n\n      _updateHashUnthrottled() {\n        const t = window.location.href.replace(/(#.+)?$/, this.getHashString());\n\n        try {\n          window.history.replaceState(window.history.state, null, t);\n        } catch (t) {}\n      }\n\n    }\n\n    const oo = {\n      linearity: .3,\n      easing: t.bezier(0, 0, .3, 1)\n    },\n          ao = t.extend({\n      deceleration: 2500,\n      maxSpeed: 1400\n    }, oo),\n          so = t.extend({\n      deceleration: 20,\n      maxSpeed: 1400\n    }, oo),\n          ro = t.extend({\n      deceleration: 1e3,\n      maxSpeed: 360\n    }, oo),\n          no = t.extend({\n      deceleration: 1e3,\n      maxSpeed: 90\n    }, oo);\n\n    class lo {\n      constructor(t) {\n        this._map = t, this.clear();\n      }\n\n      clear() {\n        this._inertiaBuffer = [];\n      }\n\n      record(e) {\n        this._drainInertiaBuffer(), this._inertiaBuffer.push({\n          time: t.exported.now(),\n          settings: e\n        });\n      }\n\n      _drainInertiaBuffer() {\n        const e = this._inertiaBuffer,\n              i = t.exported.now();\n\n        for (; e.length > 0 && i - e[0].time > 160;) e.shift();\n      }\n\n      _onMoveEnd(e) {\n        if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2) return;\n        const i = {\n          zoom: 0,\n          bearing: 0,\n          pitch: 0,\n          pan: new t.pointGeometry(0, 0),\n          pinchAround: void 0,\n          around: void 0\n        };\n\n        for (const {\n          settings: t\n        } of this._inertiaBuffer) i.zoom += t.zoomDelta || 0, i.bearing += t.bearingDelta || 0, i.pitch += t.pitchDelta || 0, t.panDelta && i.pan._add(t.panDelta), t.around && (i.around = t.around), t.pinchAround && (i.pinchAround = t.pinchAround);\n\n        const o = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time,\n              a = {};\n\n        if (i.pan.mag()) {\n          const s = ho(i.pan.mag(), o, t.extend({}, ao, e || {}));\n          a.offset = i.pan.mult(s.amount / i.pan.mag()), a.center = this._map.transform.center, co(a, s);\n        }\n\n        if (i.zoom) {\n          const t = ho(i.zoom, o, so);\n          a.zoom = this._map.transform.zoom + t.amount, co(a, t);\n        }\n\n        if (i.bearing) {\n          const e = ho(i.bearing, o, ro);\n          a.bearing = this._map.transform.bearing + t.clamp(e.amount, -179, 179), co(a, e);\n        }\n\n        if (i.pitch) {\n          const t = ho(i.pitch, o, no);\n          a.pitch = this._map.transform.pitch + t.amount, co(a, t);\n        }\n\n        if (a.zoom || a.bearing) {\n          const t = void 0 === i.pinchAround ? i.around : i.pinchAround;\n          a.around = t ? this._map.unproject(t) : this._map.getCenter();\n        }\n\n        return this.clear(), t.extend(a, {\n          noMoveStart: !0\n        });\n      }\n\n    }\n\n    function co(t, e) {\n      (!t.duration || t.duration < e.duration) && (t.duration = e.duration, t.easing = e.easing);\n    }\n\n    function ho(e, i, o) {\n      const {\n        maxSpeed: a,\n        linearity: s,\n        deceleration: r\n      } = o,\n            n = t.clamp(e * s / (i / 1e3), -a, a),\n            l = Math.abs(n) / (r * s);\n      return {\n        easing: o.easing,\n        duration: 1e3 * l,\n        amount: n * (l / 2)\n      };\n    }\n\n    class uo extends t.Event {\n      constructor(e, i, o) {\n        let a = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n        const r = s.mousePos(i.getCanvasContainer(), o),\n              n = i.unproject(r);\n        super(e, t.extend({\n          point: r,\n          lngLat: n,\n          originalEvent: o\n        }, a)), this._defaultPrevented = !1, this.target = i;\n      }\n\n      preventDefault() {\n        this._defaultPrevented = !0;\n      }\n\n      get defaultPrevented() {\n        return this._defaultPrevented;\n      }\n\n    }\n\n    class mo extends t.Event {\n      constructor(e, i, o) {\n        const a = \"touchend\" === e ? o.changedTouches : o.touches,\n              r = s.touchPos(i.getCanvasContainer(), a),\n              n = r.map(t => i.unproject(t)),\n              l = r.reduce((t, e, i, o) => t.add(e.div(o.length)), new t.pointGeometry(0, 0));\n        super(e, {\n          points: r,\n          point: l,\n          lngLats: n,\n          lngLat: i.unproject(l),\n          originalEvent: o\n        }), this._defaultPrevented = !1;\n      }\n\n      preventDefault() {\n        this._defaultPrevented = !0;\n      }\n\n      get defaultPrevented() {\n        return this._defaultPrevented;\n      }\n\n    }\n\n    class _o extends t.Event {\n      constructor(t, e, i) {\n        super(t, {\n          originalEvent: i\n        }), this._defaultPrevented = !1;\n      }\n\n      preventDefault() {\n        this._defaultPrevented = !0;\n      }\n\n      get defaultPrevented() {\n        return this._defaultPrevented;\n      }\n\n    }\n\n    class po {\n      constructor(t, e) {\n        this._map = t, this._clickTolerance = e.clickTolerance;\n      }\n\n      reset() {\n        delete this._mousedownPos;\n      }\n\n      wheel(t) {\n        return this._firePreventable(new _o(t.type, this._map, t));\n      }\n\n      mousedown(t, e) {\n        return this._mousedownPos = e, this._firePreventable(new uo(t.type, this._map, t));\n      }\n\n      mouseup(t) {\n        this._map.fire(new uo(t.type, this._map, t));\n      }\n\n      click(t, e) {\n        this._mousedownPos && this._mousedownPos.dist(e) >= this._clickTolerance || this._map.fire(new uo(t.type, this._map, t));\n      }\n\n      dblclick(t) {\n        return this._firePreventable(new uo(t.type, this._map, t));\n      }\n\n      mouseover(t) {\n        this._map.fire(new uo(t.type, this._map, t));\n      }\n\n      mouseout(t) {\n        this._map.fire(new uo(t.type, this._map, t));\n      }\n\n      touchstart(t) {\n        return this._firePreventable(new mo(t.type, this._map, t));\n      }\n\n      touchmove(t) {\n        this._map.fire(new mo(t.type, this._map, t));\n      }\n\n      touchend(t) {\n        this._map.fire(new mo(t.type, this._map, t));\n      }\n\n      touchcancel(t) {\n        this._map.fire(new mo(t.type, this._map, t));\n      }\n\n      _firePreventable(t) {\n        if (this._map.fire(t), t.defaultPrevented) return {};\n      }\n\n      isEnabled() {\n        return !0;\n      }\n\n      isActive() {\n        return !1;\n      }\n\n      enable() {}\n\n      disable() {}\n\n    }\n\n    class fo {\n      constructor(t) {\n        this._map = t;\n      }\n\n      reset() {\n        this._delayContextMenu = !1, delete this._contextMenuEvent;\n      }\n\n      mousemove(t) {\n        this._map.fire(new uo(t.type, this._map, t));\n      }\n\n      mousedown() {\n        this._delayContextMenu = !0;\n      }\n\n      mouseup() {\n        this._delayContextMenu = !1, this._contextMenuEvent && (this._map.fire(new uo(\"contextmenu\", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);\n      }\n\n      contextmenu(t) {\n        this._delayContextMenu ? this._contextMenuEvent = t : this._map.fire(new uo(t.type, this._map, t)), this._map.listens(\"contextmenu\") && t.preventDefault();\n      }\n\n      isEnabled() {\n        return !0;\n      }\n\n      isActive() {\n        return !1;\n      }\n\n      enable() {}\n\n      disable() {}\n\n    }\n\n    class go {\n      constructor(t, e) {\n        this._map = t, this._el = t.getCanvasContainer(), this._container = t.getContainer(), this._clickTolerance = e.clickTolerance || 1;\n      }\n\n      isEnabled() {\n        return !!this._enabled;\n      }\n\n      isActive() {\n        return !!this._active;\n      }\n\n      enable() {\n        this.isEnabled() || (this._enabled = !0);\n      }\n\n      disable() {\n        this.isEnabled() && (this._enabled = !1);\n      }\n\n      mousedown(t, e) {\n        this.isEnabled() && t.shiftKey && 0 === t.button && (s.disableDrag(), this._startPos = this._lastPos = e, this._active = !0);\n      }\n\n      mousemoveWindow(t, e) {\n        if (!this._active) return;\n        const i = e;\n        if (this._lastPos.equals(i) || !this._box && i.dist(this._startPos) < this._clickTolerance) return;\n        const o = this._startPos;\n        this._lastPos = i, this._box || (this._box = s.create(\"div\", \"maplibregl-boxzoom mapboxgl-boxzoom\", this._container), this._container.classList.add(\"maplibregl-crosshair\", \"mapboxgl-crosshair\"), this._fireEvent(\"boxzoomstart\", t));\n        const a = Math.min(o.x, i.x),\n              r = Math.max(o.x, i.x),\n              n = Math.min(o.y, i.y),\n              l = Math.max(o.y, i.y);\n        s.setTransform(this._box, `translate(${a}px,${n}px)`), this._box.style.width = r - a + \"px\", this._box.style.height = l - n + \"px\";\n      }\n\n      mouseupWindow(e, i) {\n        if (!this._active) return;\n        if (0 !== e.button) return;\n        const o = this._startPos,\n              a = i;\n        if (this.reset(), s.suppressClick(), o.x !== a.x || o.y !== a.y) return this._map.fire(new t.Event(\"boxzoomend\", {\n          originalEvent: e\n        })), {\n          cameraAnimation: t => t.fitScreenCoordinates(o, a, this._map.getBearing(), {\n            linear: !0\n          })\n        };\n\n        this._fireEvent(\"boxzoomcancel\", e);\n      }\n\n      keydown(t) {\n        this._active && 27 === t.keyCode && (this.reset(), this._fireEvent(\"boxzoomcancel\", t));\n      }\n\n      reset() {\n        this._active = !1, this._container.classList.remove(\"maplibregl-crosshair\", \"mapboxgl-crosshair\"), this._box && (s.remove(this._box), this._box = null), s.enableDrag(), delete this._startPos, delete this._lastPos;\n      }\n\n      _fireEvent(e, i) {\n        return this._map.fire(new t.Event(e, {\n          originalEvent: i\n        }));\n      }\n\n    }\n\n    function xo(t, e) {\n      const i = {};\n\n      for (let o = 0; o < t.length; o++) i[t[o].identifier] = e[o];\n\n      return i;\n    }\n\n    class vo {\n      constructor(t) {\n        this.reset(), this.numTouches = t.numTouches;\n      }\n\n      reset() {\n        delete this.centroid, delete this.startTime, delete this.touches, this.aborted = !1;\n      }\n\n      touchstart(e, i, o) {\n        (this.centroid || o.length > this.numTouches) && (this.aborted = !0), this.aborted || (void 0 === this.startTime && (this.startTime = e.timeStamp), o.length === this.numTouches && (this.centroid = function (e) {\n          const i = new t.pointGeometry(0, 0);\n\n          for (const t of e) i._add(t);\n\n          return i.div(e.length);\n        }(i), this.touches = xo(o, i)));\n      }\n\n      touchmove(t, e, i) {\n        if (this.aborted || !this.centroid) return;\n        const o = xo(i, e);\n\n        for (const t in this.touches) {\n          const e = this.touches[t],\n                i = o[t];\n          (!i || i.dist(e) > 30) && (this.aborted = !0);\n        }\n      }\n\n      touchend(t, e, i) {\n        if ((!this.centroid || t.timeStamp - this.startTime > 500) && (this.aborted = !0), 0 === i.length) {\n          const t = !this.aborted && this.centroid;\n          if (this.reset(), t) return t;\n        }\n      }\n\n    }\n\n    class yo {\n      constructor(t) {\n        this.singleTap = new vo(t), this.numTaps = t.numTaps, this.reset();\n      }\n\n      reset() {\n        this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset();\n      }\n\n      touchstart(t, e, i) {\n        this.singleTap.touchstart(t, e, i);\n      }\n\n      touchmove(t, e, i) {\n        this.singleTap.touchmove(t, e, i);\n      }\n\n      touchend(t, e, i) {\n        const o = this.singleTap.touchend(t, e, i);\n\n        if (o) {\n          const e = t.timeStamp - this.lastTime < 500,\n                i = !this.lastTap || this.lastTap.dist(o) < 30;\n          if (e && i || this.reset(), this.count++, this.lastTime = t.timeStamp, this.lastTap = o, this.count === this.numTaps) return this.reset(), o;\n        }\n      }\n\n    }\n\n    class bo {\n      constructor() {\n        this._zoomIn = new yo({\n          numTouches: 1,\n          numTaps: 2\n        }), this._zoomOut = new yo({\n          numTouches: 2,\n          numTaps: 1\n        }), this.reset();\n      }\n\n      reset() {\n        this._active = !1, this._zoomIn.reset(), this._zoomOut.reset();\n      }\n\n      touchstart(t, e, i) {\n        this._zoomIn.touchstart(t, e, i), this._zoomOut.touchstart(t, e, i);\n      }\n\n      touchmove(t, e, i) {\n        this._zoomIn.touchmove(t, e, i), this._zoomOut.touchmove(t, e, i);\n      }\n\n      touchend(t, e, i) {\n        const o = this._zoomIn.touchend(t, e, i),\n              a = this._zoomOut.touchend(t, e, i);\n\n        return o ? (this._active = !0, t.preventDefault(), setTimeout(() => this.reset(), 0), {\n          cameraAnimation: e => e.easeTo({\n            duration: 300,\n            zoom: e.getZoom() + 1,\n            around: e.unproject(o)\n          }, {\n            originalEvent: t\n          })\n        }) : a ? (this._active = !0, t.preventDefault(), setTimeout(() => this.reset(), 0), {\n          cameraAnimation: e => e.easeTo({\n            duration: 300,\n            zoom: e.getZoom() - 1,\n            around: e.unproject(a)\n          }, {\n            originalEvent: t\n          })\n        }) : void 0;\n      }\n\n      touchcancel() {\n        this.reset();\n      }\n\n      enable() {\n        this._enabled = !0;\n      }\n\n      disable() {\n        this._enabled = !1, this.reset();\n      }\n\n      isEnabled() {\n        return this._enabled;\n      }\n\n      isActive() {\n        return this._active;\n      }\n\n    }\n\n    const wo = {\n      0: 1,\n      2: 2\n    };\n\n    class To {\n      constructor(t) {\n        this.reset(), this._clickTolerance = t.clickTolerance || 1;\n      }\n\n      reset() {\n        this._active = !1, this._moved = !1, delete this._lastPoint, delete this._eventButton;\n      }\n\n      _correctButton(t, e) {\n        return !1;\n      }\n\n      _move(t, e) {\n        return {};\n      }\n\n      mousedown(t, e) {\n        if (this._lastPoint) return;\n        const i = s.mouseButton(t);\n        this._correctButton(t, i) && (this._lastPoint = e, this._eventButton = i);\n      }\n\n      mousemoveWindow(t, e) {\n        const i = this._lastPoint;\n        if (i) if (t.preventDefault(), function (t, e) {\n          const i = wo[e];\n          return void 0 === t.buttons || (t.buttons & i) !== i;\n        }(t, this._eventButton)) this.reset();else if (this._moved || !(e.dist(i) < this._clickTolerance)) return this._moved = !0, this._lastPoint = e, this._move(i, e);\n      }\n\n      mouseupWindow(t) {\n        this._lastPoint && s.mouseButton(t) === this._eventButton && (this._moved && s.suppressClick(), this.reset());\n      }\n\n      enable() {\n        this._enabled = !0;\n      }\n\n      disable() {\n        this._enabled = !1, this.reset();\n      }\n\n      isEnabled() {\n        return this._enabled;\n      }\n\n      isActive() {\n        return this._active;\n      }\n\n    }\n\n    class Eo extends To {\n      mousedown(t, e) {\n        super.mousedown(t, e), this._lastPoint && (this._active = !0);\n      }\n\n      _correctButton(t, e) {\n        return 0 === e && !t.ctrlKey;\n      }\n\n      _move(t, e) {\n        return {\n          around: e,\n          panDelta: e.sub(t)\n        };\n      }\n\n    }\n\n    class Io extends To {\n      _correctButton(t, e) {\n        return 0 === e && t.ctrlKey || 2 === e;\n      }\n\n      _move(t, e) {\n        const i = .8 * (e.x - t.x);\n        if (i) return this._active = !0, {\n          bearingDelta: i\n        };\n      }\n\n      contextmenu(t) {\n        t.preventDefault();\n      }\n\n    }\n\n    class So extends To {\n      _correctButton(t, e) {\n        return 0 === e && t.ctrlKey || 2 === e;\n      }\n\n      _move(t, e) {\n        const i = -.5 * (e.y - t.y);\n        if (i) return this._active = !0, {\n          pitchDelta: i\n        };\n      }\n\n      contextmenu(t) {\n        t.preventDefault();\n      }\n\n    }\n\n    class Co {\n      constructor(t) {\n        this._minTouches = 1, this._clickTolerance = t.clickTolerance || 1, this.reset();\n      }\n\n      reset() {\n        this._active = !1, this._touches = {}, this._sum = new t.pointGeometry(0, 0);\n      }\n\n      touchstart(t, e, i) {\n        return this._calculateTransform(t, e, i);\n      }\n\n      touchmove(t, e, i) {\n        if (this._active && !(i.length < this._minTouches)) return t.preventDefault(), this._calculateTransform(t, e, i);\n      }\n\n      touchend(t, e, i) {\n        this._calculateTransform(t, e, i), this._active && i.length < this._minTouches && this.reset();\n      }\n\n      touchcancel() {\n        this.reset();\n      }\n\n      _calculateTransform(e, i, o) {\n        o.length > 0 && (this._active = !0);\n        const a = xo(o, i),\n              s = new t.pointGeometry(0, 0),\n              r = new t.pointGeometry(0, 0);\n        let n = 0;\n\n        for (const t in a) {\n          const e = a[t],\n                i = this._touches[t];\n          i && (s._add(e), r._add(e.sub(i)), n++, a[t] = e);\n        }\n\n        if (this._touches = a, n < this._minTouches || !r.mag()) return;\n        const l = r.div(n);\n        return this._sum._add(l), this._sum.mag() < this._clickTolerance ? void 0 : {\n          around: s.div(n),\n          panDelta: l\n        };\n      }\n\n      enable() {\n        this._enabled = !0;\n      }\n\n      disable() {\n        this._enabled = !1, this.reset();\n      }\n\n      isEnabled() {\n        return this._enabled;\n      }\n\n      isActive() {\n        return this._active;\n      }\n\n    }\n\n    class Po {\n      constructor() {\n        this.reset();\n      }\n\n      reset() {\n        this._active = !1, delete this._firstTwoTouches;\n      }\n\n      _start(t) {}\n\n      _move(t, e, i) {\n        return {};\n      }\n\n      touchstart(t, e, i) {\n        this._firstTwoTouches || i.length < 2 || (this._firstTwoTouches = [i[0].identifier, i[1].identifier], this._start([e[0], e[1]]));\n      }\n\n      touchmove(t, e, i) {\n        if (!this._firstTwoTouches) return;\n        t.preventDefault();\n        const [o, a] = this._firstTwoTouches,\n              s = zo(i, e, o),\n              r = zo(i, e, a);\n        if (!s || !r) return;\n        const n = this._aroundCenter ? null : s.add(r).div(2);\n        return this._move([s, r], n, t);\n      }\n\n      touchend(t, e, i) {\n        if (!this._firstTwoTouches) return;\n        const [o, a] = this._firstTwoTouches,\n              r = zo(i, e, o),\n              n = zo(i, e, a);\n        r && n || (this._active && s.suppressClick(), this.reset());\n      }\n\n      touchcancel() {\n        this.reset();\n      }\n\n      enable(t) {\n        this._enabled = !0, this._aroundCenter = !!t && \"center\" === t.around;\n      }\n\n      disable() {\n        this._enabled = !1, this.reset();\n      }\n\n      isEnabled() {\n        return this._enabled;\n      }\n\n      isActive() {\n        return this._active;\n      }\n\n    }\n\n    function zo(t, e, i) {\n      for (let o = 0; o < t.length; o++) if (t[o].identifier === i) return e[o];\n    }\n\n    function Do(t, e) {\n      return Math.log(t / e) / Math.LN2;\n    }\n\n    class Ao extends Po {\n      reset() {\n        super.reset(), delete this._distance, delete this._startDistance;\n      }\n\n      _start(t) {\n        this._startDistance = this._distance = t[0].dist(t[1]);\n      }\n\n      _move(t, e) {\n        const i = this._distance;\n        if (this._distance = t[0].dist(t[1]), this._active || !(Math.abs(Do(this._distance, this._startDistance)) < .1)) return this._active = !0, {\n          zoomDelta: Do(this._distance, i),\n          pinchAround: e\n        };\n      }\n\n    }\n\n    function Mo(t, e) {\n      return 180 * t.angleWith(e) / Math.PI;\n    }\n\n    class Lo extends Po {\n      reset() {\n        super.reset(), delete this._minDiameter, delete this._startVector, delete this._vector;\n      }\n\n      _start(t) {\n        this._startVector = this._vector = t[0].sub(t[1]), this._minDiameter = t[0].dist(t[1]);\n      }\n\n      _move(t, e) {\n        const i = this._vector;\n        if (this._vector = t[0].sub(t[1]), this._active || !this._isBelowThreshold(this._vector)) return this._active = !0, {\n          bearingDelta: Mo(this._vector, i),\n          pinchAround: e\n        };\n      }\n\n      _isBelowThreshold(t) {\n        this._minDiameter = Math.min(this._minDiameter, t.mag());\n        const e = 25 / (Math.PI * this._minDiameter) * 360,\n              i = Mo(t, this._startVector);\n        return Math.abs(i) < e;\n      }\n\n    }\n\n    function Ro(t) {\n      return Math.abs(t.y) > Math.abs(t.x);\n    }\n\n    class ko extends Po {\n      reset() {\n        super.reset(), this._valid = void 0, delete this._firstMove, delete this._lastPoints;\n      }\n\n      _start(t) {\n        this._lastPoints = t, Ro(t[0].sub(t[1])) && (this._valid = !1);\n      }\n\n      _move(t, e, i) {\n        const o = t[0].sub(this._lastPoints[0]),\n              a = t[1].sub(this._lastPoints[1]);\n        if (this._valid = this.gestureBeginsVertically(o, a, i.timeStamp), this._valid) return this._lastPoints = t, this._active = !0, {\n          pitchDelta: (o.y + a.y) / 2 * -.5\n        };\n      }\n\n      gestureBeginsVertically(t, e, i) {\n        if (void 0 !== this._valid) return this._valid;\n        const o = t.mag() >= 2,\n              a = e.mag() >= 2;\n        if (!o && !a) return;\n        if (!o || !a) return void 0 === this._firstMove && (this._firstMove = i), i - this._firstMove < 100 && void 0;\n        const s = t.y > 0 == e.y > 0;\n        return Ro(t) && Ro(e) && s;\n      }\n\n    }\n\n    const Bo = {\n      panStep: 100,\n      bearingStep: 15,\n      pitchStep: 10\n    };\n\n    class Fo {\n      constructor() {\n        const t = Bo;\n        this._panStep = t.panStep, this._bearingStep = t.bearingStep, this._pitchStep = t.pitchStep, this._rotationDisabled = !1;\n      }\n\n      reset() {\n        this._active = !1;\n      }\n\n      keydown(t) {\n        if (t.altKey || t.ctrlKey || t.metaKey) return;\n        let e = 0,\n            i = 0,\n            o = 0,\n            a = 0,\n            s = 0;\n\n        switch (t.keyCode) {\n          case 61:\n          case 107:\n          case 171:\n          case 187:\n            e = 1;\n            break;\n\n          case 189:\n          case 109:\n          case 173:\n            e = -1;\n            break;\n\n          case 37:\n            t.shiftKey ? i = -1 : (t.preventDefault(), a = -1);\n            break;\n\n          case 39:\n            t.shiftKey ? i = 1 : (t.preventDefault(), a = 1);\n            break;\n\n          case 38:\n            t.shiftKey ? o = 1 : (t.preventDefault(), s = -1);\n            break;\n\n          case 40:\n            t.shiftKey ? o = -1 : (t.preventDefault(), s = 1);\n            break;\n\n          default:\n            return;\n        }\n\n        return this._rotationDisabled && (i = 0, o = 0), {\n          cameraAnimation: r => {\n            const n = r.getZoom();\n            r.easeTo({\n              duration: 300,\n              easeId: \"keyboardHandler\",\n              easing: Oo,\n              zoom: e ? Math.round(n) + e * (t.shiftKey ? 2 : 1) : n,\n              bearing: r.getBearing() + i * this._bearingStep,\n              pitch: r.getPitch() + o * this._pitchStep,\n              offset: [-a * this._panStep, -s * this._panStep],\n              center: r.getCenter()\n            }, {\n              originalEvent: t\n            });\n          }\n        };\n      }\n\n      enable() {\n        this._enabled = !0;\n      }\n\n      disable() {\n        this._enabled = !1, this.reset();\n      }\n\n      isEnabled() {\n        return this._enabled;\n      }\n\n      isActive() {\n        return this._active;\n      }\n\n      disableRotation() {\n        this._rotationDisabled = !0;\n      }\n\n      enableRotation() {\n        this._rotationDisabled = !1;\n      }\n\n    }\n\n    function Oo(t) {\n      return t * (2 - t);\n    }\n\n    const Uo = 4.000244140625;\n\n    class No {\n      constructor(e, i) {\n        this._map = e, this._el = e.getCanvasContainer(), this._handler = i, this._delta = 0, this._defaultZoomRate = .01, this._wheelZoomRate = .0022222222222222222, t.bindAll([\"_onTimeout\"], this);\n      }\n\n      setZoomRate(t) {\n        this._defaultZoomRate = t;\n      }\n\n      setWheelZoomRate(t) {\n        this._wheelZoomRate = t;\n      }\n\n      isEnabled() {\n        return !!this._enabled;\n      }\n\n      isActive() {\n        return !!this._active || void 0 !== this._finishTimeout;\n      }\n\n      isZooming() {\n        return !!this._zooming;\n      }\n\n      enable(t) {\n        this.isEnabled() || (this._enabled = !0, this._aroundCenter = t && \"center\" === t.around);\n      }\n\n      disable() {\n        this.isEnabled() && (this._enabled = !1);\n      }\n\n      wheel(e) {\n        if (!this.isEnabled()) return;\n        let i = e.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * e.deltaY : e.deltaY;\n        const o = t.exported.now(),\n              a = o - (this._lastWheelEventTime || 0);\n        this._lastWheelEventTime = o, 0 !== i && i % Uo == 0 ? this._type = \"wheel\" : 0 !== i && Math.abs(i) < 4 ? this._type = \"trackpad\" : a > 400 ? (this._type = null, this._lastValue = i, this._timeout = setTimeout(this._onTimeout, 40, e)) : this._type || (this._type = Math.abs(a * i) < 200 ? \"trackpad\" : \"wheel\", this._timeout && (clearTimeout(this._timeout), this._timeout = null, i += this._lastValue)), e.shiftKey && i && (i /= 4), this._type && (this._lastWheelEvent = e, this._delta -= i, this._active || this._start(e)), e.preventDefault();\n      }\n\n      _onTimeout(t) {\n        this._type = \"wheel\", this._delta -= this._lastValue, this._active || this._start(t);\n      }\n\n      _start(e) {\n        if (!this._delta) return;\n        this._frameId && (this._frameId = null), this._active = !0, this.isZooming() || (this._zooming = !0), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);\n        const i = s.mousePos(this._el, e);\n        this._around = t.LngLat.convert(this._aroundCenter ? this._map.getCenter() : this._map.unproject(i)), this._aroundPoint = this._map.transform.locationPoint(this._around), this._frameId || (this._frameId = !0, this._handler._triggerRenderFrame());\n      }\n\n      renderFrame() {\n        if (!this._frameId) return;\n        if (this._frameId = null, !this.isActive()) return;\n        const e = this._map.transform;\n\n        if (0 !== this._delta) {\n          const t = \"wheel\" === this._type && Math.abs(this._delta) > Uo ? this._wheelZoomRate : this._defaultZoomRate;\n          let i = 2 / (1 + Math.exp(-Math.abs(this._delta * t)));\n          this._delta < 0 && 0 !== i && (i = 1 / i);\n          const o = \"number\" == typeof this._targetZoom ? e.zoomScale(this._targetZoom) : e.scale;\n          this._targetZoom = Math.min(e.maxZoom, Math.max(e.minZoom, e.scaleZoom(o * i))), \"wheel\" === this._type && (this._startZoom = e.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0;\n        }\n\n        const i = \"number\" == typeof this._targetZoom ? this._targetZoom : e.zoom,\n              o = this._startZoom,\n              a = this._easing;\n        let s,\n            r = !1;\n\n        if (\"wheel\" === this._type && o && a) {\n          const e = Math.min((t.exported.now() - this._lastWheelEventTime) / 200, 1),\n                n = a(e);\n          s = t.number(o, i, n), e < 1 ? this._frameId || (this._frameId = !0) : r = !0;\n        } else s = i, r = !0;\n\n        return this._active = !0, r && (this._active = !1, this._finishTimeout = setTimeout(() => {\n          this._zooming = !1, this._handler._triggerRenderFrame(), delete this._targetZoom, delete this._finishTimeout;\n        }, 200)), {\n          noInertia: !0,\n          needsRenderFrame: !r,\n          zoomDelta: s - e.zoom,\n          around: this._aroundPoint,\n          originalEvent: this._lastWheelEvent\n        };\n      }\n\n      _smoothOutEasing(e) {\n        let i = t.ease;\n\n        if (this._prevEase) {\n          const e = this._prevEase,\n                o = (t.exported.now() - e.start) / e.duration,\n                a = e.easing(o + .01) - e.easing(o),\n                s = .27 / Math.sqrt(a * a + 1e-4) * .01,\n                r = Math.sqrt(.0729 - s * s);\n          i = t.bezier(s, r, .25, 1);\n        }\n\n        return this._prevEase = {\n          start: t.exported.now(),\n          duration: e,\n          easing: i\n        }, i;\n      }\n\n      reset() {\n        this._active = !1;\n      }\n\n    }\n\n    class Go {\n      constructor(t, e) {\n        this._clickZoom = t, this._tapZoom = e;\n      }\n\n      enable() {\n        this._clickZoom.enable(), this._tapZoom.enable();\n      }\n\n      disable() {\n        this._clickZoom.disable(), this._tapZoom.disable();\n      }\n\n      isEnabled() {\n        return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();\n      }\n\n      isActive() {\n        return this._clickZoom.isActive() || this._tapZoom.isActive();\n      }\n\n    }\n\n    class Zo {\n      constructor() {\n        this.reset();\n      }\n\n      reset() {\n        this._active = !1;\n      }\n\n      dblclick(t, e) {\n        return t.preventDefault(), {\n          cameraAnimation: i => {\n            i.easeTo({\n              duration: 300,\n              zoom: i.getZoom() + (t.shiftKey ? -1 : 1),\n              around: i.unproject(e)\n            }, {\n              originalEvent: t\n            });\n          }\n        };\n      }\n\n      enable() {\n        this._enabled = !0;\n      }\n\n      disable() {\n        this._enabled = !1, this.reset();\n      }\n\n      isEnabled() {\n        return this._enabled;\n      }\n\n      isActive() {\n        return this._active;\n      }\n\n    }\n\n    class qo {\n      constructor() {\n        this._tap = new yo({\n          numTouches: 1,\n          numTaps: 1\n        }), this.reset();\n      }\n\n      reset() {\n        this._active = !1, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, this._tap.reset();\n      }\n\n      touchstart(t, e, i) {\n        this._swipePoint || (this._tapTime && t.timeStamp - this._tapTime > 500 && this.reset(), this._tapTime ? i.length > 0 && (this._swipePoint = e[0], this._swipeTouch = i[0].identifier) : this._tap.touchstart(t, e, i));\n      }\n\n      touchmove(t, e, i) {\n        if (this._tapTime) {\n          if (this._swipePoint) {\n            if (i[0].identifier !== this._swipeTouch) return;\n            const o = e[0],\n                  a = o.y - this._swipePoint.y;\n            return this._swipePoint = o, t.preventDefault(), this._active = !0, {\n              zoomDelta: a / 128\n            };\n          }\n        } else this._tap.touchmove(t, e, i);\n      }\n\n      touchend(t, e, i) {\n        this._tapTime ? this._swipePoint && 0 === i.length && this.reset() : this._tap.touchend(t, e, i) && (this._tapTime = t.timeStamp);\n      }\n\n      touchcancel() {\n        this.reset();\n      }\n\n      enable() {\n        this._enabled = !0;\n      }\n\n      disable() {\n        this._enabled = !1, this.reset();\n      }\n\n      isEnabled() {\n        return this._enabled;\n      }\n\n      isActive() {\n        return this._active;\n      }\n\n    }\n\n    class Vo {\n      constructor(t, e, i) {\n        this._el = t, this._mousePan = e, this._touchPan = i;\n      }\n\n      enable(t) {\n        this._inertiaOptions = t || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add(\"maplibregl-touch-drag-pan\", \"mapboxgl-touch-drag-pan\");\n      }\n\n      disable() {\n        this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove(\"maplibregl-touch-drag-pan\", \"mapboxgl-touch-drag-pan\");\n      }\n\n      isEnabled() {\n        return this._mousePan.isEnabled() && this._touchPan.isEnabled();\n      }\n\n      isActive() {\n        return this._mousePan.isActive() || this._touchPan.isActive();\n      }\n\n    }\n\n    class jo {\n      constructor(t, e, i) {\n        this._pitchWithRotate = t.pitchWithRotate, this._mouseRotate = e, this._mousePitch = i;\n      }\n\n      enable() {\n        this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable();\n      }\n\n      disable() {\n        this._mouseRotate.disable(), this._mousePitch.disable();\n      }\n\n      isEnabled() {\n        return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled());\n      }\n\n      isActive() {\n        return this._mouseRotate.isActive() || this._mousePitch.isActive();\n      }\n\n    }\n\n    class $o {\n      constructor(t, e, i, o) {\n        this._el = t, this._touchZoom = e, this._touchRotate = i, this._tapDragZoom = o, this._rotationDisabled = !1, this._enabled = !0;\n      }\n\n      enable(t) {\n        this._touchZoom.enable(t), this._rotationDisabled || this._touchRotate.enable(t), this._tapDragZoom.enable(), this._el.classList.add(\"maplibregl-touch-zoom-rotate\", \"mapboxgl-touch-zoom-rotate\");\n      }\n\n      disable() {\n        this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove(\"maplibregl-touch-zoom-rotate\", \"mapboxgl-touch-zoom-rotate\");\n      }\n\n      isEnabled() {\n        return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();\n      }\n\n      isActive() {\n        return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();\n      }\n\n      disableRotation() {\n        this._rotationDisabled = !0, this._touchRotate.disable();\n      }\n\n      enableRotation() {\n        this._rotationDisabled = !1, this._touchZoom.isEnabled() && this._touchRotate.enable();\n      }\n\n    }\n\n    const Wo = t => t.zoom || t.drag || t.pitch || t.rotate;\n\n    class Xo extends t.Event {}\n\n    function Ho(t) {\n      return t.panDelta && t.panDelta.mag() || t.zoomDelta || t.bearingDelta || t.pitchDelta;\n    }\n\n    class Ko {\n      constructor(e, i) {\n        this._map = e, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new lo(e), this._bearingSnap = i.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(i), t.bindAll([\"handleEvent\", \"handleWindowEvent\"], this);\n        const o = this._el;\n        this._listeners = [[o, \"touchstart\", {\n          passive: !0\n        }], [o, \"touchmove\", {\n          passive: !1\n        }], [o, \"touchend\", void 0], [o, \"touchcancel\", void 0], [o, \"mousedown\", void 0], [o, \"mousemove\", void 0], [o, \"mouseup\", void 0], [document, \"mousemove\", {\n          capture: !0\n        }], [document, \"mouseup\", void 0], [o, \"mouseover\", void 0], [o, \"mouseout\", void 0], [o, \"dblclick\", void 0], [o, \"click\", void 0], [o, \"keydown\", {\n          capture: !1\n        }], [o, \"keyup\", void 0], [o, \"wheel\", {\n          passive: !1\n        }], [o, \"contextmenu\", void 0], [window, \"blur\", void 0]];\n\n        for (const [t, e, i] of this._listeners) s.addEventListener(t, e, t === document ? this.handleWindowEvent : this.handleEvent, i);\n      }\n\n      destroy() {\n        for (const [t, e, i] of this._listeners) s.removeEventListener(t, e, t === document ? this.handleWindowEvent : this.handleEvent, i);\n      }\n\n      _addDefaultHandlers(t) {\n        const e = this._map,\n              i = e.getCanvasContainer();\n\n        this._add(\"mapEvent\", new po(e, t));\n\n        const o = e.boxZoom = new go(e, t);\n\n        this._add(\"boxZoom\", o);\n\n        const a = new bo(),\n              s = new Zo();\n        e.doubleClickZoom = new Go(s, a), this._add(\"tapZoom\", a), this._add(\"clickZoom\", s);\n        const r = new qo();\n\n        this._add(\"tapDragZoom\", r);\n\n        const n = e.touchPitch = new ko();\n\n        this._add(\"touchPitch\", n);\n\n        const l = new Io(t),\n              c = new So(t);\n        e.dragRotate = new jo(t, l, c), this._add(\"mouseRotate\", l, [\"mousePitch\"]), this._add(\"mousePitch\", c, [\"mouseRotate\"]);\n        const h = new Eo(t),\n              u = new Co(t);\n        e.dragPan = new Vo(i, h, u), this._add(\"mousePan\", h), this._add(\"touchPan\", u, [\"touchZoom\", \"touchRotate\"]);\n        const d = new Lo(),\n              m = new Ao();\n        e.touchZoomRotate = new $o(i, m, d, r), this._add(\"touchRotate\", d, [\"touchPan\", \"touchZoom\"]), this._add(\"touchZoom\", m, [\"touchPan\", \"touchRotate\"]);\n\n        const _ = e.scrollZoom = new No(e, this);\n\n        this._add(\"scrollZoom\", _, [\"mousePan\"]);\n\n        const p = e.keyboard = new Fo();\n        this._add(\"keyboard\", p), this._add(\"blockableMapEvent\", new fo(e));\n\n        for (const i of [\"boxZoom\", \"doubleClickZoom\", \"tapDragZoom\", \"touchPitch\", \"dragRotate\", \"dragPan\", \"touchZoomRotate\", \"scrollZoom\", \"keyboard\"]) t.interactive && t[i] && e[i].enable(t[i]);\n      }\n\n      _add(t, e, i) {\n        this._handlers.push({\n          handlerName: t,\n          handler: e,\n          allowed: i\n        }), this._handlersById[t] = e;\n      }\n\n      stop(t) {\n        if (!this._updatingCamera) {\n          for (const {\n            handler: t\n          } of this._handlers) t.reset();\n\n          this._inertia.clear(), this._fireEvents({}, {}, t), this._changes = [];\n        }\n      }\n\n      isActive() {\n        for (const {\n          handler: t\n        } of this._handlers) if (t.isActive()) return !0;\n\n        return !1;\n      }\n\n      isZooming() {\n        return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();\n      }\n\n      isRotating() {\n        return !!this._eventsInProgress.rotate;\n      }\n\n      isMoving() {\n        return Boolean(Wo(this._eventsInProgress)) || this.isZooming();\n      }\n\n      _blockedByActive(t, e, i) {\n        for (const o in t) if (o !== i && (!e || e.indexOf(o) < 0)) return !0;\n\n        return !1;\n      }\n\n      handleWindowEvent(t) {\n        this.handleEvent(t, `${t.type}Window`);\n      }\n\n      _getMapTouches(t) {\n        const e = [];\n\n        for (const i of t) this._el.contains(i.target) && e.push(i);\n\n        return e;\n      }\n\n      handleEvent(t, e) {\n        if (\"blur\" === t.type) return void this.stop(!0);\n        this._updatingCamera = !0;\n        const i = \"renderFrame\" === t.type ? void 0 : t,\n              o = {\n          needsRenderFrame: !1\n        },\n              a = {},\n              r = {},\n              n = t.touches,\n              l = n ? this._getMapTouches(n) : void 0,\n              c = l ? s.touchPos(this._el, l) : s.mousePos(this._el, t);\n\n        for (const {\n          handlerName: s,\n          handler: n,\n          allowed: h\n        } of this._handlers) {\n          if (!n.isEnabled()) continue;\n          let u;\n          this._blockedByActive(r, h, s) ? n.reset() : n[e || t.type] && (u = n[e || t.type](t, c, l), this.mergeHandlerResult(o, a, u, s, i), u && u.needsRenderFrame && this._triggerRenderFrame()), (u || n.isActive()) && (r[s] = n);\n        }\n\n        const h = {};\n\n        for (const t in this._previousActiveHandlers) r[t] || (h[t] = i);\n\n        this._previousActiveHandlers = r, (Object.keys(h).length || Ho(o)) && (this._changes.push([o, a, h]), this._triggerRenderFrame()), (Object.keys(r).length || Ho(o)) && this._map._stop(!0), this._updatingCamera = !1;\n        const {\n          cameraAnimation: u\n        } = o;\n        u && (this._inertia.clear(), this._fireEvents({}, {}, !0), this._changes = [], u(this._map));\n      }\n\n      mergeHandlerResult(e, i, o, a, s) {\n        if (!o) return;\n        t.extend(e, o);\n        const r = {\n          handlerName: a,\n          originalEvent: o.originalEvent || s\n        };\n        void 0 !== o.zoomDelta && (i.zoom = r), void 0 !== o.panDelta && (i.drag = r), void 0 !== o.pitchDelta && (i.pitch = r), void 0 !== o.bearingDelta && (i.rotate = r);\n      }\n\n      _applyChanges() {\n        const e = {},\n              i = {},\n              o = {};\n\n        for (const [a, s, r] of this._changes) a.panDelta && (e.panDelta = (e.panDelta || new t.pointGeometry(0, 0))._add(a.panDelta)), a.zoomDelta && (e.zoomDelta = (e.zoomDelta || 0) + a.zoomDelta), a.bearingDelta && (e.bearingDelta = (e.bearingDelta || 0) + a.bearingDelta), a.pitchDelta && (e.pitchDelta = (e.pitchDelta || 0) + a.pitchDelta), void 0 !== a.around && (e.around = a.around), void 0 !== a.pinchAround && (e.pinchAround = a.pinchAround), a.noInertia && (e.noInertia = a.noInertia), t.extend(i, s), t.extend(o, r);\n\n        this._updateMapTransform(e, i, o), this._changes = [];\n      }\n\n      _updateMapTransform(t, e, i) {\n        const o = this._map,\n              a = o.transform;\n        if (!Ho(t)) return this._fireEvents(e, i, !0);\n        let {\n          panDelta: s,\n          zoomDelta: r,\n          bearingDelta: n,\n          pitchDelta: l,\n          around: c,\n          pinchAround: h\n        } = t;\n        void 0 !== h && (c = h), o._stop(!0), c = c || o.transform.centerPoint;\n        const u = a.pointLocation(s ? c.sub(s) : c);\n        n && (a.bearing += n), l && (a.pitch += l), r && (a.zoom += r), a.setLocationAtPoint(u, c), this._map._update(), t.noInertia || this._inertia.record(t), this._fireEvents(e, i, !0);\n      }\n\n      _fireEvents(e, i, o) {\n        const a = Wo(this._eventsInProgress),\n              s = Wo(e),\n              r = {};\n\n        for (const t in e) {\n          const {\n            originalEvent: i\n          } = e[t];\n          this._eventsInProgress[t] || (r[`${t}start`] = i), this._eventsInProgress[t] = e[t];\n        }\n\n        !a && s && this._fireEvent(\"movestart\", s.originalEvent);\n\n        for (const t in r) this._fireEvent(t, r[t]);\n\n        s && this._fireEvent(\"move\", s.originalEvent);\n\n        for (const t in e) {\n          const {\n            originalEvent: i\n          } = e[t];\n\n          this._fireEvent(t, i);\n        }\n\n        const n = {};\n        let l;\n\n        for (const t in this._eventsInProgress) {\n          const {\n            handlerName: e,\n            originalEvent: o\n          } = this._eventsInProgress[t];\n          this._handlersById[e].isActive() || (delete this._eventsInProgress[t], l = i[e] || o, n[`${t}end`] = l);\n        }\n\n        for (const t in n) this._fireEvent(t, n[t]);\n\n        const c = Wo(this._eventsInProgress);\n\n        if (o && (a || s) && !c) {\n          this._updatingCamera = !0;\n\n          const e = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions),\n                i = t => 0 !== t && -this._bearingSnap < t && t < this._bearingSnap;\n\n          e ? (i(e.bearing || this._map.getBearing()) && (e.bearing = 0), this._map.easeTo(e, {\n            originalEvent: l\n          })) : (this._map.fire(new t.Event(\"moveend\", {\n            originalEvent: l\n          })), i(this._map.getBearing()) && this._map.resetNorth()), this._updatingCamera = !1;\n        }\n      }\n\n      _fireEvent(e, i) {\n        this._map.fire(new t.Event(e, i ? {\n          originalEvent: i\n        } : {}));\n      }\n\n      _requestFrame() {\n        return this._map.triggerRepaint(), this._map._renderTaskQueue.add(t => {\n          delete this._frameId, this.handleEvent(new Xo(\"renderFrame\", {\n            timeStamp: t\n          })), this._applyChanges();\n        });\n      }\n\n      _triggerRenderFrame() {\n        void 0 === this._frameId && (this._frameId = this._requestFrame());\n      }\n\n    }\n\n    const Yo = {\n      extend: function (e) {\n        for (var _len6 = arguments.length, i = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {\n          i[_key6 - 1] = arguments[_key6];\n        }\n\n        return t.extend(e, ...i);\n      },\n\n      run(t) {\n        t();\n      },\n\n      logToElement(t) {\n        let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;\n        let i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"log\";\n        const o = window.document.getElementById(i);\n        o && (e && (o.innerHTML = \"\"), o.innerHTML += `<br>${t}`);\n      }\n\n    };\n\n    class Jo extends t.Evented {\n      constructor(e, i) {\n        super(), this._moving = !1, this._zooming = !1, this.transform = e, this._bearingSnap = i.bearingSnap, t.bindAll([\"_renderFrameCallback\"], this);\n      }\n\n      getCenter() {\n        return new t.LngLat(this.transform.center.lng, this.transform.center.lat);\n      }\n\n      setCenter(t, e) {\n        return this.jumpTo({\n          center: t\n        }, e);\n      }\n\n      panBy(e, i, o) {\n        return e = t.pointGeometry.convert(e).mult(-1), this.panTo(this.transform.center, t.extend({\n          offset: e\n        }, i), o);\n      }\n\n      panTo(e, i, o) {\n        return this.easeTo(t.extend({\n          center: e\n        }, i), o);\n      }\n\n      getZoom() {\n        return this.transform.zoom;\n      }\n\n      setZoom(t, e) {\n        return this.jumpTo({\n          zoom: t\n        }, e), this;\n      }\n\n      zoomTo(e, i, o) {\n        return this.easeTo(t.extend({\n          zoom: e\n        }, i), o);\n      }\n\n      zoomIn(t, e) {\n        return this.zoomTo(this.getZoom() + 1, t, e), this;\n      }\n\n      zoomOut(t, e) {\n        return this.zoomTo(this.getZoom() - 1, t, e), this;\n      }\n\n      getBearing() {\n        return this.transform.bearing;\n      }\n\n      setBearing(t, e) {\n        return this.jumpTo({\n          bearing: t\n        }, e), this;\n      }\n\n      getPadding() {\n        return this.transform.padding;\n      }\n\n      setPadding(t, e) {\n        return this.jumpTo({\n          padding: t\n        }, e), this;\n      }\n\n      rotateTo(e, i, o) {\n        return this.easeTo(t.extend({\n          bearing: e\n        }, i), o);\n      }\n\n      resetNorth(e, i) {\n        return this.rotateTo(0, t.extend({\n          duration: 1e3\n        }, e), i), this;\n      }\n\n      resetNorthPitch(e, i) {\n        return this.easeTo(t.extend({\n          bearing: 0,\n          pitch: 0,\n          duration: 1e3\n        }, e), i), this;\n      }\n\n      snapToNorth(t, e) {\n        return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(t, e) : this;\n      }\n\n      getPitch() {\n        return this.transform.pitch;\n      }\n\n      setPitch(t, e) {\n        return this.jumpTo({\n          pitch: t\n        }, e), this;\n      }\n\n      cameraForBounds(e, i) {\n        e = t.LngLatBounds.convert(e);\n        const o = i && i.bearing || 0;\n        return this._cameraForBoxAndBearing(e.getNorthWest(), e.getSouthEast(), o, i);\n      }\n\n      _cameraForBoxAndBearing(e, i, o, a) {\n        const s = {\n          top: 0,\n          bottom: 0,\n          right: 0,\n          left: 0\n        };\n\n        if (\"number\" == typeof (a = t.extend({\n          padding: s,\n          offset: [0, 0],\n          maxZoom: this.transform.maxZoom\n        }, a)).padding) {\n          const t = a.padding;\n          a.padding = {\n            top: t,\n            bottom: t,\n            right: t,\n            left: t\n          };\n        }\n\n        a.padding = t.extend(s, a.padding);\n\n        const r = this.transform,\n              n = r.padding,\n              l = r.project(t.LngLat.convert(e)),\n              c = r.project(t.LngLat.convert(i)),\n              h = l.rotate(-o * Math.PI / 180),\n              u = c.rotate(-o * Math.PI / 180),\n              d = new t.pointGeometry(Math.max(h.x, u.x), Math.max(h.y, u.y)),\n              m = new t.pointGeometry(Math.min(h.x, u.x), Math.min(h.y, u.y)),\n              _ = d.sub(m),\n              p = (r.width - (n.left + n.right + a.padding.left + a.padding.right)) / _.x,\n              f = (r.height - (n.top + n.bottom + a.padding.top + a.padding.bottom)) / _.y;\n\n        if (f < 0 || p < 0) return void t.warnOnce(\"Map cannot fit within canvas with the given bounds, padding, and/or offset.\");\n        const g = Math.min(r.scaleZoom(r.scale * Math.min(p, f)), a.maxZoom),\n              x = t.pointGeometry.convert(a.offset),\n              v = new t.pointGeometry((a.padding.left - a.padding.right) / 2, (a.padding.top - a.padding.bottom) / 2).rotate(o * Math.PI / 180),\n              y = x.add(v).mult(r.scale / r.zoomScale(g));\n        return {\n          center: r.unproject(l.add(c).div(2).sub(y)),\n          zoom: g,\n          bearing: o\n        };\n      }\n\n      fitBounds(t, e, i) {\n        return this._fitInternal(this.cameraForBounds(t, e), e, i);\n      }\n\n      fitScreenCoordinates(e, i, o, a, s) {\n        return this._fitInternal(this._cameraForBoxAndBearing(this.transform.pointLocation(t.pointGeometry.convert(e)), this.transform.pointLocation(t.pointGeometry.convert(i)), o, a), a, s);\n      }\n\n      _fitInternal(e, i, o) {\n        return e ? (delete (i = t.extend(e, i)).padding, i.linear ? this.easeTo(i, o) : this.flyTo(i, o)) : this;\n      }\n\n      jumpTo(e, i) {\n        this.stop();\n        const o = this.transform;\n        let a = !1,\n            s = !1,\n            r = !1;\n        return \"zoom\" in e && o.zoom !== +e.zoom && (a = !0, o.zoom = +e.zoom), void 0 !== e.center && (o.center = t.LngLat.convert(e.center)), \"bearing\" in e && o.bearing !== +e.bearing && (s = !0, o.bearing = +e.bearing), \"pitch\" in e && o.pitch !== +e.pitch && (r = !0, o.pitch = +e.pitch), null == e.padding || o.isPaddingEqual(e.padding) || (o.padding = e.padding), this.fire(new t.Event(\"movestart\", i)).fire(new t.Event(\"move\", i)), a && this.fire(new t.Event(\"zoomstart\", i)).fire(new t.Event(\"zoom\", i)).fire(new t.Event(\"zoomend\", i)), s && this.fire(new t.Event(\"rotatestart\", i)).fire(new t.Event(\"rotate\", i)).fire(new t.Event(\"rotateend\", i)), r && this.fire(new t.Event(\"pitchstart\", i)).fire(new t.Event(\"pitch\", i)).fire(new t.Event(\"pitchend\", i)), this.fire(new t.Event(\"moveend\", i));\n      }\n\n      easeTo(e, i) {\n        this._stop(!1, e.easeId), (!1 === (e = t.extend({\n          offset: [0, 0],\n          duration: 500,\n          easing: t.ease\n        }, e)).animate || !e.essential && t.exported.prefersReducedMotion) && (e.duration = 0);\n        const o = this.transform,\n              a = this.getZoom(),\n              s = this.getBearing(),\n              r = this.getPitch(),\n              n = this.getPadding(),\n              l = \"zoom\" in e ? +e.zoom : a,\n              c = \"bearing\" in e ? this._normalizeBearing(e.bearing, s) : s,\n              h = \"pitch\" in e ? +e.pitch : r,\n              u = \"padding\" in e ? e.padding : o.padding,\n              d = t.pointGeometry.convert(e.offset);\n        let m = o.centerPoint.add(d);\n\n        const _ = o.pointLocation(m),\n              p = t.LngLat.convert(e.center || _);\n\n        this._normalizeCenter(p);\n\n        const f = o.project(_),\n              g = o.project(p).sub(f),\n              x = o.zoomScale(l - a);\n        let v, y;\n        e.around && (v = t.LngLat.convert(e.around), y = o.locationPoint(v));\n        const b = {\n          moving: this._moving,\n          zooming: this._zooming,\n          rotating: this._rotating,\n          pitching: this._pitching\n        };\n        return this._zooming = this._zooming || l !== a, this._rotating = this._rotating || s !== c, this._pitching = this._pitching || h !== r, this._padding = !o.isPaddingEqual(u), this._easeId = e.easeId, this._prepareEase(i, e.noMoveStart, b), this._ease(e => {\n          if (this._zooming && (o.zoom = t.number(a, l, e)), this._rotating && (o.bearing = t.number(s, c, e)), this._pitching && (o.pitch = t.number(r, h, e)), this._padding && (o.interpolatePadding(n, u, e), m = o.centerPoint.add(d)), v) o.setLocationAtPoint(v, y);else {\n            const t = o.zoomScale(o.zoom - a),\n                  i = l > a ? Math.min(2, x) : Math.max(.5, x),\n                  s = Math.pow(i, 1 - e),\n                  r = o.unproject(f.add(g.mult(e * s)).mult(t));\n            o.setLocationAtPoint(o.renderWorldCopies ? r.wrap() : r, m);\n          }\n\n          this._fireMoveEvents(i);\n        }, t => {\n          this._afterEase(i, t);\n        }, e), this;\n      }\n\n      _prepareEase(e, i) {\n        let o = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        this._moving = !0, i || o.moving || this.fire(new t.Event(\"movestart\", e)), this._zooming && !o.zooming && this.fire(new t.Event(\"zoomstart\", e)), this._rotating && !o.rotating && this.fire(new t.Event(\"rotatestart\", e)), this._pitching && !o.pitching && this.fire(new t.Event(\"pitchstart\", e));\n      }\n\n      _fireMoveEvents(e) {\n        this.fire(new t.Event(\"move\", e)), this._zooming && this.fire(new t.Event(\"zoom\", e)), this._rotating && this.fire(new t.Event(\"rotate\", e)), this._pitching && this.fire(new t.Event(\"pitch\", e));\n      }\n\n      _afterEase(e, i) {\n        if (this._easeId && i && this._easeId === i) return;\n        delete this._easeId;\n        const o = this._zooming,\n              a = this._rotating,\n              s = this._pitching;\n        this._moving = !1, this._zooming = !1, this._rotating = !1, this._pitching = !1, this._padding = !1, o && this.fire(new t.Event(\"zoomend\", e)), a && this.fire(new t.Event(\"rotateend\", e)), s && this.fire(new t.Event(\"pitchend\", e)), this.fire(new t.Event(\"moveend\", e));\n      }\n\n      flyTo(e, i) {\n        if (!e.essential && t.exported.prefersReducedMotion) {\n          const o = t.pick(e, [\"center\", \"zoom\", \"bearing\", \"pitch\", \"around\"]);\n          return this.jumpTo(o, i);\n        }\n\n        this.stop(), e = t.extend({\n          offset: [0, 0],\n          speed: 1.2,\n          curve: 1.42,\n          easing: t.ease\n        }, e);\n        const o = this.transform,\n              a = this.getZoom(),\n              s = this.getBearing(),\n              r = this.getPitch(),\n              n = this.getPadding(),\n              l = \"zoom\" in e ? t.clamp(+e.zoom, o.minZoom, o.maxZoom) : a,\n              c = \"bearing\" in e ? this._normalizeBearing(e.bearing, s) : s,\n              h = \"pitch\" in e ? +e.pitch : r,\n              u = \"padding\" in e ? e.padding : o.padding,\n              d = o.zoomScale(l - a),\n              m = t.pointGeometry.convert(e.offset);\n\n        let _ = o.centerPoint.add(m);\n\n        const p = o.pointLocation(_),\n              f = t.LngLat.convert(e.center || p);\n\n        this._normalizeCenter(f);\n\n        const g = o.project(p),\n              x = o.project(f).sub(g);\n        let v = e.curve;\n        const y = Math.max(o.width, o.height),\n              b = y / d,\n              w = x.mag();\n\n        if (\"minZoom\" in e) {\n          const i = t.clamp(Math.min(e.minZoom, a, l), o.minZoom, o.maxZoom),\n                s = y / o.zoomScale(i - a);\n          v = Math.sqrt(s / w * 2);\n        }\n\n        const T = v * v;\n\n        function E(t) {\n          const e = (b * b - y * y + (t ? -1 : 1) * T * T * w * w) / (2 * (t ? b : y) * T * w);\n          return Math.log(Math.sqrt(e * e + 1) - e);\n        }\n\n        function I(t) {\n          return (Math.exp(t) - Math.exp(-t)) / 2;\n        }\n\n        function S(t) {\n          return (Math.exp(t) + Math.exp(-t)) / 2;\n        }\n\n        const C = E(0);\n\n        let P = function (t) {\n          return S(C) / S(C + v * t);\n        },\n            z = function (t) {\n          return y * ((S(C) * (I(e = C + v * t) / S(e)) - I(C)) / T) / w;\n          var e;\n        },\n            D = (E(1) - C) / v;\n\n        if (Math.abs(w) < 1e-6 || !isFinite(D)) {\n          if (Math.abs(y - b) < 1e-6) return this.easeTo(e, i);\n          const t = b < y ? -1 : 1;\n          D = Math.abs(Math.log(b / y)) / v, z = function () {\n            return 0;\n          }, P = function (e) {\n            return Math.exp(t * v * e);\n          };\n        }\n\n        return e.duration = \"duration\" in e ? +e.duration : 1e3 * D / (\"screenSpeed\" in e ? +e.screenSpeed / v : +e.speed), e.maxDuration && e.duration > e.maxDuration && (e.duration = 0), this._zooming = !0, this._rotating = s !== c, this._pitching = h !== r, this._padding = !o.isPaddingEqual(u), this._prepareEase(i, !1), this._ease(e => {\n          const d = e * D,\n                p = 1 / P(d);\n          o.zoom = 1 === e ? l : a + o.scaleZoom(p), this._rotating && (o.bearing = t.number(s, c, e)), this._pitching && (o.pitch = t.number(r, h, e)), this._padding && (o.interpolatePadding(n, u, e), _ = o.centerPoint.add(m));\n          const v = 1 === e ? f : o.unproject(g.add(x.mult(z(d))).mult(p));\n          o.setLocationAtPoint(o.renderWorldCopies ? v.wrap() : v, _), this._fireMoveEvents(i);\n        }, () => this._afterEase(i), e), this;\n      }\n\n      isEasing() {\n        return !!this._easeFrameId;\n      }\n\n      stop() {\n        return this._stop();\n      }\n\n      _stop(t, e) {\n        if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {\n          const t = this._onEaseEnd;\n          delete this._onEaseEnd, t.call(this, e);\n        }\n\n        if (!t) {\n          const t = this.handlers;\n          t && t.stop(!1);\n        }\n\n        return this;\n      }\n\n      _ease(e, i, o) {\n        !1 === o.animate || 0 === o.duration ? (e(1), i()) : (this._easeStart = t.exported.now(), this._easeOptions = o, this._onEaseFrame = e, this._onEaseEnd = i, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));\n      }\n\n      _renderFrameCallback() {\n        const e = Math.min((t.exported.now() - this._easeStart) / this._easeOptions.duration, 1);\n        this._onEaseFrame(this._easeOptions.easing(e)), e < 1 ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();\n      }\n\n      _normalizeBearing(e, i) {\n        e = t.wrap(e, -180, 180);\n        const o = Math.abs(e - i);\n        return Math.abs(e - 360 - i) < o && (e -= 360), Math.abs(e + 360 - i) < o && (e += 360), e;\n      }\n\n      _normalizeCenter(t) {\n        const e = this.transform;\n        if (!e.renderWorldCopies || e.lngRange) return;\n        const i = t.lng - e.center.lng;\n        t.lng += i > 180 ? -360 : i < -180 ? 360 : 0;\n      }\n\n    }\n\n    class Qo {\n      constructor() {\n        let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        this.options = e, t.bindAll([\"_toggleAttribution\", \"_updateData\", \"_updateCompact\", \"_updateCompactMinimize\"], this);\n      }\n\n      getDefaultPosition() {\n        return \"bottom-right\";\n      }\n\n      onAdd(t) {\n        return this._map = t, this._compact = this.options && this.options.compact, this._container = s.create(\"details\", \"maplibregl-ctrl maplibregl-ctrl-attrib mapboxgl-ctrl mapboxgl-ctrl-attrib\"), this._compactButton = s.create(\"summary\", \"maplibregl-ctrl-attrib-button mapboxgl-ctrl-attrib-button\", this._container), this._compactButton.addEventListener(\"click\", this._toggleAttribution), this._setElementTitle(this._compactButton, \"ToggleAttribution\"), this._innerContainer = s.create(\"div\", \"maplibregl-ctrl-attrib-inner mapboxgl-ctrl-attrib-inner\", this._container), this._updateAttributions(), this._updateCompact(), this._map.on(\"styledata\", this._updateData), this._map.on(\"sourcedata\", this._updateData), this._map.on(\"resize\", this._updateCompact), this._map.on(\"drag\", this._updateCompactMinimize), this._container;\n      }\n\n      onRemove() {\n        s.remove(this._container), this._map.off(\"styledata\", this._updateData), this._map.off(\"sourcedata\", this._updateData), this._map.off(\"resize\", this._updateCompact), this._map.off(\"drag\", this._updateCompactMinimize), this._map = void 0, this._compact = void 0, this._attribHTML = void 0;\n      }\n\n      _setElementTitle(t, e) {\n        const i = this._map._getUIString(`AttributionControl.${e}`);\n\n        t.title = i, t.setAttribute(\"aria-label\", i);\n      }\n\n      _toggleAttribution() {\n        this._container.classList.contains(\"maplibregl-compact\") && (this._container.classList.contains(\"maplibregl-compact-show\") ? (this._container.setAttribute(\"open\", \"\"), this._container.classList.remove(\"maplibregl-compact-show\", \"mapboxgl-compact-show\")) : (this._container.classList.add(\"maplibregl-compact-show\", \"mapboxgl-compact-show\"), this._container.removeAttribute(\"open\")));\n      }\n\n      _updateData(t) {\n        !t || \"metadata\" !== t.sourceDataType && \"visibility\" !== t.sourceDataType && \"style\" !== t.dataType || this._updateAttributions();\n      }\n\n      _updateAttributions() {\n        if (!this._map.style) return;\n        let t = [];\n\n        if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? t = t.concat(this.options.customAttribution.map(t => \"string\" != typeof t ? \"\" : t)) : \"string\" == typeof this.options.customAttribution && t.push(this.options.customAttribution)), this._map.style.stylesheet) {\n          const t = this._map.style.stylesheet;\n          this.styleOwner = t.owner, this.styleId = t.id;\n        }\n\n        const e = this._map.style.sourceCaches;\n\n        for (const i in e) {\n          const o = e[i];\n\n          if (o.used) {\n            const e = o.getSource();\n            e.attribution && t.indexOf(e.attribution) < 0 && t.push(e.attribution);\n          }\n        }\n\n        t = t.filter(t => String(t).trim()), t.sort((t, e) => t.length - e.length), t = t.filter((e, i) => {\n          for (let o = i + 1; o < t.length; o++) if (t[o].indexOf(e) >= 0) return !1;\n\n          return !0;\n        });\n        const i = t.join(\" | \");\n        i !== this._attribHTML && (this._attribHTML = i, t.length ? (this._innerContainer.innerHTML = i, this._container.classList.remove(\"maplibregl-attrib-empty\", \"mapboxgl-attrib-empty\")) : this._container.classList.add(\"maplibregl-attrib-empty\", \"mapboxgl-attrib-empty\"), this._updateCompact(), this._editLink = null);\n      }\n\n      _updateCompact() {\n        this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? !1 === this._compact ? this._container.setAttribute(\"open\", \"\") : this._container.classList.contains(\"maplibregl-compact\") || this._container.classList.contains(\"maplibregl-attrib-empty\") || (this._container.setAttribute(\"open\", \"\"), this._container.classList.add(\"maplibregl-compact\", \"mapboxgl-compact\", \"maplibregl-compact-show\", \"mapboxgl-compact-show\")) : (this._container.setAttribute(\"open\", \"\"), this._container.classList.contains(\"maplibregl-compact\") && this._container.classList.remove(\"maplibregl-compact\", \"maplibregl-compact-show\", \"mapboxgl-compact\", \"mapboxgl-compact-show\"));\n      }\n\n      _updateCompactMinimize() {\n        this._container.classList.contains(\"maplibregl-compact\") && this._container.classList.contains(\"maplibregl-compact-show\") && this._container.classList.remove(\"maplibregl-compact-show\", \"mapboxgl-compact-show\");\n      }\n\n    }\n\n    class ta {\n      constructor() {\n        t.bindAll([\"_updateLogo\"], this), t.bindAll([\"_updateCompact\"], this);\n      }\n\n      onAdd(t) {\n        this._map = t, this._container = s.create(\"div\", \"maplibregl-ctrl mapboxgl-ctrl\");\n        const e = s.create(\"a\", \"maplibregl-ctrl-logo mapboxgl-ctrl-logo\");\n        return e.target = \"_blank\", e.rel = \"noopener nofollow\", e.href = \"https://maplibre.org/\", e.setAttribute(\"aria-label\", this._map._getUIString(\"LogoControl.Title\")), e.setAttribute(\"rel\", \"noopener nofollow\"), this._container.appendChild(e), this._container.style.display = \"none\", this._map.on(\"sourcedata\", this._updateLogo), this._updateLogo(void 0), this._map.on(\"resize\", this._updateCompact), this._updateCompact(), this._container;\n      }\n\n      onRemove() {\n        s.remove(this._container), this._map.off(\"sourcedata\", this._updateLogo), this._map.off(\"resize\", this._updateCompact);\n      }\n\n      getDefaultPosition() {\n        return \"bottom-left\";\n      }\n\n      _updateLogo(t) {\n        t && \"metadata\" !== t.sourceDataType || (this._container.style.display = this._logoRequired() ? \"block\" : \"none\");\n      }\n\n      _logoRequired() {\n        if (!this._map.style) return;\n        const t = this._map.style.sourceCaches;\n\n        for (const e in t) if (t[e].getSource().maplibreLogo) return !0;\n\n        return !1;\n      }\n\n      _updateCompact() {\n        const t = this._container.children;\n\n        if (t.length) {\n          const e = t[0];\n          this._map.getCanvasContainer().offsetWidth < 250 ? e.classList.add(\"maplibregl-compact\", \"mapboxgl-compact\") : e.classList.remove(\"maplibregl-compact\", \"mapboxgl-compact\");\n        }\n      }\n\n    }\n\n    class ea {\n      constructor() {\n        this._queue = [], this._id = 0, this._cleared = !1, this._currentlyRunning = !1;\n      }\n\n      add(t) {\n        const e = ++this._id;\n        return this._queue.push({\n          callback: t,\n          id: e,\n          cancelled: !1\n        }), e;\n      }\n\n      remove(t) {\n        const e = this._currentlyRunning,\n              i = e ? this._queue.concat(e) : this._queue;\n\n        for (const e of i) if (e.id === t) return void (e.cancelled = !0);\n      }\n\n      run() {\n        let t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n        const e = this._currentlyRunning = this._queue;\n        this._queue = [];\n\n        for (const i of e) if (!i.cancelled && (i.callback(t), this._cleared)) break;\n\n        this._cleared = !1, this._currentlyRunning = !1;\n      }\n\n      clear() {\n        this._currentlyRunning && (this._cleared = !0), this._queue = [];\n      }\n\n    }\n\n    const ia = {\n      \"AttributionControl.ToggleAttribution\": \"Toggle attribution\",\n      \"AttributionControl.MapFeedback\": \"Map feedback\",\n      \"FullscreenControl.Enter\": \"Enter fullscreen\",\n      \"FullscreenControl.Exit\": \"Exit fullscreen\",\n      \"GeolocateControl.FindMyLocation\": \"Find my location\",\n      \"GeolocateControl.LocationNotAvailable\": \"Location not available\",\n      \"LogoControl.Title\": \"Mapbox logo\",\n      \"NavigationControl.ResetBearing\": \"Reset bearing to north\",\n      \"NavigationControl.ZoomIn\": \"Zoom in\",\n      \"NavigationControl.ZoomOut\": \"Zoom out\",\n      \"ScaleControl.Feet\": \"ft\",\n      \"ScaleControl.Meters\": \"m\",\n      \"ScaleControl.Kilometers\": \"km\",\n      \"ScaleControl.Miles\": \"mi\",\n      \"ScaleControl.NauticalMiles\": \"nm\"\n    },\n          oa = {\n      center: [0, 0],\n      zoom: 0,\n      bearing: 0,\n      pitch: 0,\n      minZoom: -2,\n      maxZoom: 22,\n      minPitch: 0,\n      maxPitch: 60,\n      interactive: !0,\n      scrollZoom: !0,\n      boxZoom: !0,\n      dragRotate: !0,\n      dragPan: !0,\n      keyboard: !0,\n      doubleClickZoom: !0,\n      touchZoomRotate: !0,\n      touchPitch: !0,\n      bearingSnap: 7,\n      clickTolerance: 3,\n      pitchWithRotate: !0,\n      hash: !1,\n      attributionControl: !0,\n      failIfMajorPerformanceCaveat: !1,\n      preserveDrawingBuffer: !1,\n      trackResize: !0,\n      renderWorldCopies: !0,\n      refreshExpiredTiles: !0,\n      maxTileCacheSize: null,\n      localIdeographFontFamily: \"sans-serif\",\n      transformRequest: null,\n      fadeDuration: 300,\n      crossSourceCollisions: !0\n    },\n          aa = {\n      showCompass: !0,\n      showZoom: !0,\n      visualizePitch: !1\n    };\n\n    class sa {\n      constructor(e, i) {\n        let o = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;\n        this._clickTolerance = 10, this.element = i, this.mouseRotate = new Io({\n          clickTolerance: e.dragRotate._mouseRotate._clickTolerance\n        }), this.map = e, o && (this.mousePitch = new So({\n          clickTolerance: e.dragRotate._mousePitch._clickTolerance\n        })), t.bindAll([\"mousedown\", \"mousemove\", \"mouseup\", \"touchstart\", \"touchmove\", \"touchend\", \"reset\"], this), s.addEventListener(i, \"mousedown\", this.mousedown), s.addEventListener(i, \"touchstart\", this.touchstart, {\n          passive: !1\n        }), s.addEventListener(i, \"touchmove\", this.touchmove), s.addEventListener(i, \"touchend\", this.touchend), s.addEventListener(i, \"touchcancel\", this.reset);\n      }\n\n      down(t, e) {\n        this.mouseRotate.mousedown(t, e), this.mousePitch && this.mousePitch.mousedown(t, e), s.disableDrag();\n      }\n\n      move(t, e) {\n        const i = this.map,\n              o = this.mouseRotate.mousemoveWindow(t, e);\n\n        if (o && o.bearingDelta && i.setBearing(i.getBearing() + o.bearingDelta), this.mousePitch) {\n          const o = this.mousePitch.mousemoveWindow(t, e);\n          o && o.pitchDelta && i.setPitch(i.getPitch() + o.pitchDelta);\n        }\n      }\n\n      off() {\n        const t = this.element;\n        s.removeEventListener(t, \"mousedown\", this.mousedown), s.removeEventListener(t, \"touchstart\", this.touchstart, {\n          passive: !1\n        }), s.removeEventListener(t, \"touchmove\", this.touchmove), s.removeEventListener(t, \"touchend\", this.touchend), s.removeEventListener(t, \"touchcancel\", this.reset), this.offTemp();\n      }\n\n      offTemp() {\n        s.enableDrag(), s.removeEventListener(window, \"mousemove\", this.mousemove), s.removeEventListener(window, \"mouseup\", this.mouseup);\n      }\n\n      mousedown(e) {\n        this.down(t.extend({}, e, {\n          ctrlKey: !0,\n          preventDefault: () => e.preventDefault()\n        }), s.mousePos(this.element, e)), s.addEventListener(window, \"mousemove\", this.mousemove), s.addEventListener(window, \"mouseup\", this.mouseup);\n      }\n\n      mousemove(t) {\n        this.move(t, s.mousePos(this.element, t));\n      }\n\n      mouseup(t) {\n        this.mouseRotate.mouseupWindow(t), this.mousePitch && this.mousePitch.mouseupWindow(t), this.offTemp();\n      }\n\n      touchstart(t) {\n        1 !== t.targetTouches.length ? this.reset() : (this._startPos = this._lastPos = s.touchPos(this.element, t.targetTouches)[0], this.down({\n          type: \"mousedown\",\n          button: 0,\n          ctrlKey: !0,\n          preventDefault: () => t.preventDefault()\n        }, this._startPos));\n      }\n\n      touchmove(t) {\n        1 !== t.targetTouches.length ? this.reset() : (this._lastPos = s.touchPos(this.element, t.targetTouches)[0], this.move({\n          preventDefault: () => t.preventDefault()\n        }, this._lastPos));\n      }\n\n      touchend(t) {\n        0 === t.targetTouches.length && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), this.reset();\n      }\n\n      reset() {\n        this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp();\n      }\n\n    }\n\n    function ra(e, i, o) {\n      if (e = new t.LngLat(e.lng, e.lat), i) {\n        const a = new t.LngLat(e.lng - 360, e.lat),\n              s = new t.LngLat(e.lng + 360, e.lat),\n              r = o.locationPoint(e).distSqr(i);\n        o.locationPoint(a).distSqr(i) < r ? e = a : o.locationPoint(s).distSqr(i) < r && (e = s);\n      }\n\n      for (; Math.abs(e.lng - o.center.lng) > 180;) {\n        const t = o.locationPoint(e);\n        if (t.x >= 0 && t.y >= 0 && t.x <= o.width && t.y <= o.height) break;\n        e.lng > o.center.lng ? e.lng -= 360 : e.lng += 360;\n      }\n\n      return e;\n    }\n\n    const na = {\n      center: \"translate(-50%,-50%)\",\n      top: \"translate(-50%,0)\",\n      \"top-left\": \"translate(0,0)\",\n      \"top-right\": \"translate(-100%,0)\",\n      bottom: \"translate(-50%,-100%)\",\n      \"bottom-left\": \"translate(0,-100%)\",\n      \"bottom-right\": \"translate(-100%,-100%)\",\n      left: \"translate(0,-50%)\",\n      right: \"translate(-100%,-50%)\"\n    };\n\n    function la(t, e, i) {\n      const o = t.classList;\n\n      for (const t in na) o.remove(`maplibregl-${i}-anchor-${t}`, `mapboxgl-${i}-anchor-${t}`);\n\n      o.add(`maplibregl-${i}-anchor-${e}`, `mapboxgl-${i}-anchor-${e}`);\n    }\n\n    class ca extends t.Evented {\n      constructor(e, i) {\n        if (super(), (e instanceof HTMLElement || i) && (e = t.extend({\n          element: e\n        }, i)), t.bindAll([\"_update\", \"_onMove\", \"_onUp\", \"_addDragHandler\", \"_onMapClick\", \"_onKeyPress\"], this), this._anchor = e && e.anchor || \"center\", this._color = e && e.color || \"#3FB1CE\", this._scale = e && e.scale || 1, this._draggable = e && e.draggable || !1, this._clickTolerance = e && e.clickTolerance || 0, this._isDragging = !1, this._state = \"inactive\", this._rotation = e && e.rotation || 0, this._rotationAlignment = e && e.rotationAlignment || \"auto\", this._pitchAlignment = e && e.pitchAlignment && \"auto\" !== e.pitchAlignment ? e.pitchAlignment : this._rotationAlignment, e && e.element) this._element = e.element, this._offset = t.pointGeometry.convert(e && e.offset || [0, 0]);else {\n          this._defaultMarker = !0, this._element = s.create(\"div\"), this._element.setAttribute(\"aria-label\", \"Map marker\");\n          const i = s.createNS(\"http://www.w3.org/2000/svg\", \"svg\"),\n                o = 41,\n                a = 27;\n          i.setAttributeNS(null, \"display\", \"block\"), i.setAttributeNS(null, \"height\", `${o}px`), i.setAttributeNS(null, \"width\", `${a}px`), i.setAttributeNS(null, \"viewBox\", `0 0 ${a} ${o}`);\n          const r = s.createNS(\"http://www.w3.org/2000/svg\", \"g\");\n          r.setAttributeNS(null, \"stroke\", \"none\"), r.setAttributeNS(null, \"stroke-width\", \"1\"), r.setAttributeNS(null, \"fill\", \"none\"), r.setAttributeNS(null, \"fill-rule\", \"evenodd\");\n          const n = s.createNS(\"http://www.w3.org/2000/svg\", \"g\");\n          n.setAttributeNS(null, \"fill-rule\", \"nonzero\");\n          const l = s.createNS(\"http://www.w3.org/2000/svg\", \"g\");\n          l.setAttributeNS(null, \"transform\", \"translate(3.0, 29.0)\"), l.setAttributeNS(null, \"fill\", \"#000000\");\n          const c = [{\n            rx: \"10.5\",\n            ry: \"5.25002273\"\n          }, {\n            rx: \"10.5\",\n            ry: \"5.25002273\"\n          }, {\n            rx: \"9.5\",\n            ry: \"4.77275007\"\n          }, {\n            rx: \"8.5\",\n            ry: \"4.29549936\"\n          }, {\n            rx: \"7.5\",\n            ry: \"3.81822308\"\n          }, {\n            rx: \"6.5\",\n            ry: \"3.34094679\"\n          }, {\n            rx: \"5.5\",\n            ry: \"2.86367051\"\n          }, {\n            rx: \"4.5\",\n            ry: \"2.38636864\"\n          }];\n\n          for (const t of c) {\n            const e = s.createNS(\"http://www.w3.org/2000/svg\", \"ellipse\");\n            e.setAttributeNS(null, \"opacity\", \"0.04\"), e.setAttributeNS(null, \"cx\", \"10.5\"), e.setAttributeNS(null, \"cy\", \"5.80029008\"), e.setAttributeNS(null, \"rx\", t.rx), e.setAttributeNS(null, \"ry\", t.ry), l.appendChild(e);\n          }\n\n          const h = s.createNS(\"http://www.w3.org/2000/svg\", \"g\");\n          h.setAttributeNS(null, \"fill\", this._color);\n          const u = s.createNS(\"http://www.w3.org/2000/svg\", \"path\");\n          u.setAttributeNS(null, \"d\", \"M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z\"), h.appendChild(u);\n          const d = s.createNS(\"http://www.w3.org/2000/svg\", \"g\");\n          d.setAttributeNS(null, \"opacity\", \"0.25\"), d.setAttributeNS(null, \"fill\", \"#000000\");\n          const m = s.createNS(\"http://www.w3.org/2000/svg\", \"path\");\n          m.setAttributeNS(null, \"d\", \"M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z\"), d.appendChild(m);\n\n          const _ = s.createNS(\"http://www.w3.org/2000/svg\", \"g\");\n\n          _.setAttributeNS(null, \"transform\", \"translate(6.0, 7.0)\"), _.setAttributeNS(null, \"fill\", \"#FFFFFF\");\n          const p = s.createNS(\"http://www.w3.org/2000/svg\", \"g\");\n          p.setAttributeNS(null, \"transform\", \"translate(8.0, 8.0)\");\n          const f = s.createNS(\"http://www.w3.org/2000/svg\", \"circle\");\n          f.setAttributeNS(null, \"fill\", \"#000000\"), f.setAttributeNS(null, \"opacity\", \"0.25\"), f.setAttributeNS(null, \"cx\", \"5.5\"), f.setAttributeNS(null, \"cy\", \"5.5\"), f.setAttributeNS(null, \"r\", \"5.4999962\");\n          const g = s.createNS(\"http://www.w3.org/2000/svg\", \"circle\");\n          g.setAttributeNS(null, \"fill\", \"#FFFFFF\"), g.setAttributeNS(null, \"cx\", \"5.5\"), g.setAttributeNS(null, \"cy\", \"5.5\"), g.setAttributeNS(null, \"r\", \"5.4999962\"), p.appendChild(f), p.appendChild(g), n.appendChild(l), n.appendChild(h), n.appendChild(d), n.appendChild(_), n.appendChild(p), i.appendChild(n), i.setAttributeNS(null, \"height\", o * this._scale + \"px\"), i.setAttributeNS(null, \"width\", a * this._scale + \"px\"), this._element.appendChild(i), this._offset = t.pointGeometry.convert(e && e.offset || [0, -14]);\n        }\n        this._element.classList.add(\"maplibregl-marker\", \"mapboxgl-marker\"), this._element.addEventListener(\"dragstart\", t => {\n          t.preventDefault();\n        }), this._element.addEventListener(\"mousedown\", t => {\n          t.preventDefault();\n        }), la(this._element, this._anchor, \"marker\"), this._popup = null;\n      }\n\n      addTo(t) {\n        return this.remove(), this._map = t, t.getCanvasContainer().appendChild(this._element), t.on(\"move\", this._update), t.on(\"moveend\", this._update), this.setDraggable(this._draggable), this._update(), this._map.on(\"click\", this._onMapClick), this;\n      }\n\n      remove() {\n        return this._map && (this._map.off(\"click\", this._onMapClick), this._map.off(\"move\", this._update), this._map.off(\"moveend\", this._update), this._map.off(\"mousedown\", this._addDragHandler), this._map.off(\"touchstart\", this._addDragHandler), this._map.off(\"mouseup\", this._onUp), this._map.off(\"touchend\", this._onUp), this._map.off(\"mousemove\", this._onMove), this._map.off(\"touchmove\", this._onMove), delete this._map), s.remove(this._element), this._popup && this._popup.remove(), this;\n      }\n\n      getLngLat() {\n        return this._lngLat;\n      }\n\n      setLngLat(e) {\n        return this._lngLat = t.LngLat.convert(e), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this;\n      }\n\n      getElement() {\n        return this._element;\n      }\n\n      setPopup(t) {\n        if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener(\"keypress\", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute(\"tabindex\")), t) {\n          if (!(\"offset\" in t.options)) {\n            const e = 38.1,\n                  i = 13.5,\n                  o = Math.sqrt(Math.pow(i, 2) / 2);\n            t.options.offset = this._defaultMarker ? {\n              top: [0, 0],\n              \"top-left\": [0, 0],\n              \"top-right\": [0, 0],\n              bottom: [0, -e],\n              \"bottom-left\": [o, -1 * (e - i + o)],\n              \"bottom-right\": [-o, -1 * (e - i + o)],\n              left: [i, -1 * (e - i)],\n              right: [-i, -1 * (e - i)]\n            } : this._offset;\n          }\n\n          this._popup = t, this._lngLat && this._popup.setLngLat(this._lngLat), this._originalTabIndex = this._element.getAttribute(\"tabindex\"), this._originalTabIndex || this._element.setAttribute(\"tabindex\", \"0\"), this._element.addEventListener(\"keypress\", this._onKeyPress);\n        }\n\n        return this;\n      }\n\n      _onKeyPress(t) {\n        const e = t.code,\n              i = t.charCode || t.keyCode;\n        \"Space\" !== e && \"Enter\" !== e && 32 !== i && 13 !== i || this.togglePopup();\n      }\n\n      _onMapClick(t) {\n        const e = t.originalEvent.target,\n              i = this._element;\n        this._popup && (e === i || i.contains(e)) && this.togglePopup();\n      }\n\n      getPopup() {\n        return this._popup;\n      }\n\n      togglePopup() {\n        const t = this._popup;\n        return t ? (t.isOpen() ? t.remove() : t.addTo(this._map), this) : this;\n      }\n\n      _update(t) {\n        if (!this._map) return;\n        this._map.transform.renderWorldCopies && (this._lngLat = ra(this._lngLat, this._pos, this._map.transform)), this._pos = this._map.project(this._lngLat)._add(this._offset);\n        let e = \"\";\n        \"viewport\" === this._rotationAlignment || \"auto\" === this._rotationAlignment ? e = `rotateZ(${this._rotation}deg)` : \"map\" === this._rotationAlignment && (e = `rotateZ(${this._rotation - this._map.getBearing()}deg)`);\n        let i = \"\";\n        \"viewport\" === this._pitchAlignment || \"auto\" === this._pitchAlignment ? i = \"rotateX(0deg)\" : \"map\" === this._pitchAlignment && (i = `rotateX(${this._map.getPitch()}deg)`), t && \"moveend\" !== t.type || (this._pos = this._pos.round()), s.setTransform(this._element, `${na[this._anchor]} translate(${this._pos.x}px, ${this._pos.y}px) ${i} ${e}`);\n      }\n\n      getOffset() {\n        return this._offset;\n      }\n\n      setOffset(e) {\n        return this._offset = t.pointGeometry.convert(e), this._update(), this;\n      }\n\n      _onMove(e) {\n        if (!this._isDragging) {\n          const t = this._clickTolerance || this._map._clickTolerance;\n          this._isDragging = e.point.dist(this._pointerdownPos) >= t;\n        }\n\n        this._isDragging && (this._pos = e.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = \"none\", \"pending\" === this._state && (this._state = \"active\", this.fire(new t.Event(\"dragstart\"))), this.fire(new t.Event(\"drag\")));\n      }\n\n      _onUp() {\n        this._element.style.pointerEvents = \"auto\", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = !1, this._map.off(\"mousemove\", this._onMove), this._map.off(\"touchmove\", this._onMove), \"active\" === this._state && this.fire(new t.Event(\"dragend\")), this._state = \"inactive\";\n      }\n\n      _addDragHandler(t) {\n        this._element.contains(t.originalEvent.target) && (t.preventDefault(), this._positionDelta = t.point.sub(this._pos).add(this._offset), this._pointerdownPos = t.point, this._state = \"pending\", this._map.on(\"mousemove\", this._onMove), this._map.on(\"touchmove\", this._onMove), this._map.once(\"mouseup\", this._onUp), this._map.once(\"touchend\", this._onUp));\n      }\n\n      setDraggable(t) {\n        return this._draggable = !!t, this._map && (t ? (this._map.on(\"mousedown\", this._addDragHandler), this._map.on(\"touchstart\", this._addDragHandler)) : (this._map.off(\"mousedown\", this._addDragHandler), this._map.off(\"touchstart\", this._addDragHandler))), this;\n      }\n\n      isDraggable() {\n        return this._draggable;\n      }\n\n      setRotation(t) {\n        return this._rotation = t || 0, this._update(), this;\n      }\n\n      getRotation() {\n        return this._rotation;\n      }\n\n      setRotationAlignment(t) {\n        return this._rotationAlignment = t || \"auto\", this._update(), this;\n      }\n\n      getRotationAlignment() {\n        return this._rotationAlignment;\n      }\n\n      setPitchAlignment(t) {\n        return this._pitchAlignment = t && \"auto\" !== t ? t : this._rotationAlignment, this._update(), this;\n      }\n\n      getPitchAlignment() {\n        return this._pitchAlignment;\n      }\n\n    }\n\n    const ha = {\n      positionOptions: {\n        enableHighAccuracy: !1,\n        maximumAge: 0,\n        timeout: 6e3\n      },\n      fitBoundsOptions: {\n        maxZoom: 15\n      },\n      trackUserLocation: !1,\n      showAccuracyCircle: !0,\n      showUserLocation: !0\n    };\n    let ua,\n        da = 0,\n        ma = !1;\n    const _a = {\n      maxWidth: 100,\n      unit: \"metric\"\n    };\n\n    function pa(t, e, i) {\n      const o = i && i.maxWidth || 100,\n            a = t._container.clientHeight / 2,\n            s = t.unproject([0, a]),\n            r = t.unproject([o, a]),\n            n = s.distanceTo(r);\n\n      if (i && \"imperial\" === i.unit) {\n        const i = 3.2808 * n;\n        i > 5280 ? fa(e, o, i / 5280, t._getUIString(\"ScaleControl.Miles\")) : fa(e, o, i, t._getUIString(\"ScaleControl.Feet\"));\n      } else i && \"nautical\" === i.unit ? fa(e, o, n / 1852, t._getUIString(\"ScaleControl.NauticalMiles\")) : n >= 1e3 ? fa(e, o, n / 1e3, t._getUIString(\"ScaleControl.Kilometers\")) : fa(e, o, n, t._getUIString(\"ScaleControl.Meters\"));\n    }\n\n    function fa(t, e, i, o) {\n      const a = function (t) {\n        const e = Math.pow(10, `${Math.floor(t)}`.length - 1);\n        let i = t / e;\n        return i = i >= 10 ? 10 : i >= 5 ? 5 : i >= 3 ? 3 : i >= 2 ? 2 : i >= 1 ? 1 : function (t) {\n          const e = Math.pow(10, Math.ceil(-Math.log(t) / Math.LN10));\n          return Math.round(t * e) / e;\n        }(i), e * i;\n      }(i);\n\n      t.style.width = e * (a / i) + \"px\", t.innerHTML = `${a}&nbsp;${o}`;\n    }\n\n    const ga = {\n      closeButton: !0,\n      closeOnClick: !0,\n      focusAfterOpen: !0,\n      className: \"\",\n      maxWidth: \"240px\"\n    },\n          xa = [\"a[href]\", \"[tabindex]:not([tabindex='-1'])\", \"[contenteditable]:not([contenteditable='false'])\", \"button:not([disabled])\", \"input:not([disabled])\", \"select:not([disabled])\", \"textarea:not([disabled])\"].join(\", \");\n\n    function va(e) {\n      if (e) {\n        if (\"number\" == typeof e) {\n          const i = Math.round(Math.sqrt(.5 * Math.pow(e, 2)));\n          return {\n            center: new t.pointGeometry(0, 0),\n            top: new t.pointGeometry(0, e),\n            \"top-left\": new t.pointGeometry(i, i),\n            \"top-right\": new t.pointGeometry(-i, i),\n            bottom: new t.pointGeometry(0, -e),\n            \"bottom-left\": new t.pointGeometry(i, -i),\n            \"bottom-right\": new t.pointGeometry(-i, -i),\n            left: new t.pointGeometry(e, 0),\n            right: new t.pointGeometry(-e, 0)\n          };\n        }\n\n        if (e instanceof t.pointGeometry || Array.isArray(e)) {\n          const i = t.pointGeometry.convert(e);\n          return {\n            center: i,\n            top: i,\n            \"top-left\": i,\n            \"top-right\": i,\n            bottom: i,\n            \"bottom-left\": i,\n            \"bottom-right\": i,\n            left: i,\n            right: i\n          };\n        }\n\n        return {\n          center: t.pointGeometry.convert(e.center || [0, 0]),\n          top: t.pointGeometry.convert(e.top || [0, 0]),\n          \"top-left\": t.pointGeometry.convert(e[\"top-left\"] || [0, 0]),\n          \"top-right\": t.pointGeometry.convert(e[\"top-right\"] || [0, 0]),\n          bottom: t.pointGeometry.convert(e.bottom || [0, 0]),\n          \"bottom-left\": t.pointGeometry.convert(e[\"bottom-left\"] || [0, 0]),\n          \"bottom-right\": t.pointGeometry.convert(e[\"bottom-right\"] || [0, 0]),\n          left: t.pointGeometry.convert(e.left || [0, 0]),\n          right: t.pointGeometry.convert(e.right || [0, 0])\n        };\n      }\n\n      return va(new t.pointGeometry(0, 0));\n    }\n\n    const ya = {\n      supported: e,\n      setRTLTextPlugin: t.setRTLTextPlugin,\n      getRTLTextPluginStatus: t.getRTLTextPluginStatus,\n      Map: class extends Jo {\n        constructor(e) {\n          var i;\n          if (t.PerformanceUtils.mark(t.PerformanceMarkers.create), null != (e = t.extend({}, oa, e)).minZoom && null != e.maxZoom && e.minZoom > e.maxZoom) throw new Error(\"maxZoom must be greater than or equal to minZoom\");\n          if (null != e.minPitch && null != e.maxPitch && e.minPitch > e.maxPitch) throw new Error(\"maxPitch must be greater than or equal to minPitch\");\n          if (null != e.minPitch && e.minPitch < 0) throw new Error(\"minPitch must be greater than or equal to 0\");\n          if (null != e.maxPitch && e.maxPitch > 85) throw new Error(\"maxPitch must be less than or equal to 85\");\n\n          if (super(new eo(e.minZoom, e.maxZoom, e.minPitch, e.maxPitch, e.renderWorldCopies), {\n            bearingSnap: e.bearingSnap\n          }), this._interactive = e.interactive, this._maxTileCacheSize = e.maxTileCacheSize, this._failIfMajorPerformanceCaveat = e.failIfMajorPerformanceCaveat, this._preserveDrawingBuffer = e.preserveDrawingBuffer, this._antialias = e.antialias, this._trackResize = e.trackResize, this._bearingSnap = e.bearingSnap, this._refreshExpiredTiles = e.refreshExpiredTiles, this._fadeDuration = e.fadeDuration, this._crossSourceCollisions = e.crossSourceCollisions, this._crossFadingFactor = 1, this._collectResourceTiming = e.collectResourceTiming, this._renderTaskQueue = new ea(), this._controls = [], this._mapId = t.uniqueId(), this._locale = t.extend({}, ia, e.locale), this._clickTolerance = e.clickTolerance, this._pixelRatio = null !== (i = e.pixelRatio) && void 0 !== i ? i : devicePixelRatio, this._requestManager = new r(e.transformRequest), \"string\" == typeof e.container) {\n            if (this._container = document.getElementById(e.container), !this._container) throw new Error(`Container '${e.container}' not found.`);\n          } else {\n            if (!(e.container instanceof HTMLElement)) throw new Error(\"Invalid type: 'container' must be a String or HTMLElement.\");\n            this._container = e.container;\n          }\n\n          if (e.maxBounds && this.setMaxBounds(e.maxBounds), t.bindAll([\"_onWindowOnline\", \"_onWindowResize\", \"_onMapScroll\", \"_contextLost\", \"_contextRestored\"], this), this._setupContainer(), this._setupPainter(), void 0 === this.painter) throw new Error(\"Failed to initialize WebGL.\");\n          this.on(\"move\", () => this._update(!1)), this.on(\"moveend\", () => this._update(!1)), this.on(\"zoom\", () => this._update(!0)), \"undefined\" != typeof window && (addEventListener(\"online\", this._onWindowOnline, !1), addEventListener(\"resize\", this._onWindowResize, !1), addEventListener(\"orientationchange\", this._onWindowResize, !1)), this.handlers = new Ko(this, e), this._hash = e.hash && new io(\"string\" == typeof e.hash && e.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({\n            center: e.center,\n            zoom: e.zoom,\n            bearing: e.bearing,\n            pitch: e.pitch\n          }), e.bounds && (this.resize(), this.fitBounds(e.bounds, t.extend({}, e.fitBoundsOptions, {\n            duration: 0\n          })))), this.resize(), this._localIdeographFontFamily = e.localIdeographFontFamily, e.style && this.setStyle(e.style, {\n            localIdeographFontFamily: e.localIdeographFontFamily\n          }), e.attributionControl && this.addControl(new Qo({\n            customAttribution: e.customAttribution\n          })), this.addControl(new ta(), e.logoPosition), this.on(\"style.load\", () => {\n            this.transform.unmodified && this.jumpTo(this.style.stylesheet);\n          }), this.on(\"data\", e => {\n            this._update(\"style\" === e.dataType), this.fire(new t.Event(`${e.dataType}data`, e));\n          }), this.on(\"dataloading\", e => {\n            this.fire(new t.Event(`${e.dataType}dataloading`, e));\n          }), this.on(\"dataabort\", e => {\n            this.fire(new t.Event(\"sourcedataabort\", e));\n          });\n        }\n\n        _getMapId() {\n          return this._mapId;\n        }\n\n        addControl(e, i) {\n          if (void 0 === i && (i = e.getDefaultPosition ? e.getDefaultPosition() : \"top-right\"), !e || !e.onAdd) return this.fire(new t.ErrorEvent(new Error(\"Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.\")));\n          const o = e.onAdd(this);\n\n          this._controls.push(e);\n\n          const a = this._controlPositions[i];\n          return -1 !== i.indexOf(\"bottom\") ? a.insertBefore(o, a.firstChild) : a.appendChild(o), this;\n        }\n\n        removeControl(e) {\n          if (!e || !e.onRemove) return this.fire(new t.ErrorEvent(new Error(\"Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.\")));\n\n          const i = this._controls.indexOf(e);\n\n          return i > -1 && this._controls.splice(i, 1), e.onRemove(this), this;\n        }\n\n        hasControl(t) {\n          return this._controls.indexOf(t) > -1;\n        }\n\n        resize(e) {\n          const i = this._containerDimensions(),\n                o = i[0],\n                a = i[1];\n\n          this._resizeCanvas(o, a, this.getPixelRatio()), this.transform.resize(o, a), this.painter.resize(o, a, this.getPixelRatio());\n          const s = !this._moving;\n          return s && (this.stop(), this.fire(new t.Event(\"movestart\", e)).fire(new t.Event(\"move\", e))), this.fire(new t.Event(\"resize\", e)), s && this.fire(new t.Event(\"moveend\", e)), this;\n        }\n\n        getPixelRatio() {\n          return this._pixelRatio;\n        }\n\n        setPixelRatio(t) {\n          const [e, i] = this._containerDimensions();\n\n          this._pixelRatio = t, this._resizeCanvas(e, i, t), this.painter.resize(e, i, t);\n        }\n\n        getBounds() {\n          return this.transform.getBounds();\n        }\n\n        getMaxBounds() {\n          return this.transform.getMaxBounds();\n        }\n\n        setMaxBounds(e) {\n          return this.transform.setMaxBounds(t.LngLatBounds.convert(e)), this._update();\n        }\n\n        setMinZoom(t) {\n          if ((t = null == t ? -2 : t) >= -2 && t <= this.transform.maxZoom) return this.transform.minZoom = t, this._update(), this.getZoom() < t && this.setZoom(t), this;\n          throw new Error(\"minZoom must be between -2 and the current maxZoom, inclusive\");\n        }\n\n        getMinZoom() {\n          return this.transform.minZoom;\n        }\n\n        setMaxZoom(t) {\n          if ((t = null == t ? 22 : t) >= this.transform.minZoom) return this.transform.maxZoom = t, this._update(), this.getZoom() > t && this.setZoom(t), this;\n          throw new Error(\"maxZoom must be greater than the current minZoom\");\n        }\n\n        getMaxZoom() {\n          return this.transform.maxZoom;\n        }\n\n        setMinPitch(t) {\n          if ((t = null == t ? 0 : t) < 0) throw new Error(\"minPitch must be greater than or equal to 0\");\n          if (t >= 0 && t <= this.transform.maxPitch) return this.transform.minPitch = t, this._update(), this.getPitch() < t && this.setPitch(t), this;\n          throw new Error(\"minPitch must be between 0 and the current maxPitch, inclusive\");\n        }\n\n        getMinPitch() {\n          return this.transform.minPitch;\n        }\n\n        setMaxPitch(t) {\n          if ((t = null == t ? 60 : t) > 85) throw new Error(\"maxPitch must be less than or equal to 85\");\n          if (t >= this.transform.minPitch) return this.transform.maxPitch = t, this._update(), this.getPitch() > t && this.setPitch(t), this;\n          throw new Error(\"maxPitch must be greater than the current minPitch\");\n        }\n\n        getMaxPitch() {\n          return this.transform.maxPitch;\n        }\n\n        getRenderWorldCopies() {\n          return this.transform.renderWorldCopies;\n        }\n\n        setRenderWorldCopies(t) {\n          return this.transform.renderWorldCopies = t, this._update();\n        }\n\n        project(e) {\n          return this.transform.locationPoint(t.LngLat.convert(e));\n        }\n\n        unproject(e) {\n          return this.transform.pointLocation(t.pointGeometry.convert(e));\n        }\n\n        isMoving() {\n          return this._moving || this.handlers.isMoving();\n        }\n\n        isZooming() {\n          return this._zooming || this.handlers.isZooming();\n        }\n\n        isRotating() {\n          return this._rotating || this.handlers.isRotating();\n        }\n\n        _createDelegatedListener(t, e, i) {\n          if (\"mouseenter\" === t || \"mouseover\" === t) {\n            let o = !1;\n\n            const a = a => {\n              const s = this.getLayer(e) ? this.queryRenderedFeatures(a.point, {\n                layers: [e]\n              }) : [];\n              s.length ? o || (o = !0, i.call(this, new uo(t, this, a.originalEvent, {\n                features: s\n              }))) : o = !1;\n            };\n\n            return {\n              layer: e,\n              listener: i,\n              delegates: {\n                mousemove: a,\n                mouseout: () => {\n                  o = !1;\n                }\n              }\n            };\n          }\n\n          if (\"mouseleave\" === t || \"mouseout\" === t) {\n            let o = !1;\n\n            const a = a => {\n              (this.getLayer(e) ? this.queryRenderedFeatures(a.point, {\n                layers: [e]\n              }) : []).length ? o = !0 : o && (o = !1, i.call(this, new uo(t, this, a.originalEvent)));\n            },\n                  s = e => {\n              o && (o = !1, i.call(this, new uo(t, this, e.originalEvent)));\n            };\n\n            return {\n              layer: e,\n              listener: i,\n              delegates: {\n                mousemove: a,\n                mouseout: s\n              }\n            };\n          }\n\n          {\n            const o = t => {\n              const o = this.getLayer(e) ? this.queryRenderedFeatures(t.point, {\n                layers: [e]\n              }) : [];\n              o.length && (t.features = o, i.call(this, t), delete t.features);\n            };\n\n            return {\n              layer: e,\n              listener: i,\n              delegates: {\n                [t]: o\n              }\n            };\n          }\n        }\n\n        on(t, e, i) {\n          if (void 0 === i) return super.on(t, e);\n\n          const o = this._createDelegatedListener(t, e, i);\n\n          this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[t] = this._delegatedListeners[t] || [], this._delegatedListeners[t].push(o);\n\n          for (const t in o.delegates) this.on(t, o.delegates[t]);\n\n          return this;\n        }\n\n        once(t, e, i) {\n          if (void 0 === i) return super.once(t, e);\n\n          const o = this._createDelegatedListener(t, e, i);\n\n          for (const t in o.delegates) this.once(t, o.delegates[t]);\n\n          return this;\n        }\n\n        off(t, e, i) {\n          return void 0 === i ? super.off(t, e) : (this._delegatedListeners && this._delegatedListeners[t] && (o => {\n            const a = this._delegatedListeners[t];\n\n            for (let t = 0; t < a.length; t++) {\n              const o = a[t];\n\n              if (o.layer === e && o.listener === i) {\n                for (const t in o.delegates) this.off(t, o.delegates[t]);\n\n                return a.splice(t, 1), this;\n              }\n            }\n          })(), this);\n        }\n\n        queryRenderedFeatures(e, i) {\n          if (!this.style) return [];\n          let o;\n          if (void 0 !== i || void 0 === e || e instanceof t.pointGeometry || Array.isArray(e) || (i = e, e = void 0), i = i || {}, (e = e || [[0, 0], [this.transform.width, this.transform.height]]) instanceof t.pointGeometry || \"number\" == typeof e[0]) o = [t.pointGeometry.convert(e)];else {\n            const i = t.pointGeometry.convert(e[0]),\n                  a = t.pointGeometry.convert(e[1]);\n            o = [i, new t.pointGeometry(a.x, i.y), a, new t.pointGeometry(i.x, a.y), i];\n          }\n          return this.style.queryRenderedFeatures(o, i, this.transform);\n        }\n\n        querySourceFeatures(t, e) {\n          return this.style.querySourceFeatures(t, e);\n        }\n\n        setStyle(e, i) {\n          return !1 !== (i = t.extend({}, {\n            localIdeographFontFamily: this._localIdeographFontFamily\n          }, i)).diff && i.localIdeographFontFamily === this._localIdeographFontFamily && this.style && e ? (this._diffStyle(e, i), this) : (this._localIdeographFontFamily = i.localIdeographFontFamily, this._updateStyle(e, i));\n        }\n\n        setTransformRequest(t) {\n          return this._requestManager.setTransformRequest(t), this;\n        }\n\n        _getUIString(t) {\n          const e = this._locale[t];\n          if (null == e) throw new Error(`Missing UI string '${t}'`);\n          return e;\n        }\n\n        _updateStyle(t, e) {\n          return this.style && (this.style.setEventedParent(null), this.style._remove()), t ? (this.style = new oe(this, e || {}), this.style.setEventedParent(this, {\n            style: this.style\n          }), \"string\" == typeof t ? this.style.loadURL(t) : this.style.loadJSON(t), this) : (delete this.style, this);\n        }\n\n        _lazyInitEmptyStyle() {\n          this.style || (this.style = new oe(this, {}), this.style.setEventedParent(this, {\n            style: this.style\n          }), this.style.loadEmpty());\n        }\n\n        _diffStyle(e, i) {\n          if (\"string\" == typeof e) {\n            const o = this._requestManager.transformRequest(e, t.ResourceType.Style);\n\n            t.getJSON(o, (e, o) => {\n              e ? this.fire(new t.ErrorEvent(e)) : o && this._updateDiff(o, i);\n            });\n          } else \"object\" == typeof e && this._updateDiff(e, i);\n        }\n\n        _updateDiff(e, i) {\n          try {\n            this.style.setState(e) && this._update(!0);\n          } catch (o) {\n            t.warnOnce(`Unable to perform style diff: ${o.message || o.error || o}.  Rebuilding the style from scratch.`), this._updateStyle(e, i);\n          }\n        }\n\n        getStyle() {\n          if (this.style) return this.style.serialize();\n        }\n\n        isStyleLoaded() {\n          return this.style ? this.style.loaded() : t.warnOnce(\"There is no style added to the map.\");\n        }\n\n        addSource(t, e) {\n          return this._lazyInitEmptyStyle(), this.style.addSource(t, e), this._update(!0);\n        }\n\n        isSourceLoaded(e) {\n          const i = this.style && this.style.sourceCaches[e];\n          if (void 0 !== i) return i.loaded();\n          this.fire(new t.ErrorEvent(new Error(`There is no source with ID '${e}'`)));\n        }\n\n        areTilesLoaded() {\n          const t = this.style && this.style.sourceCaches;\n\n          for (const e in t) {\n            const i = t[e]._tiles;\n\n            for (const t in i) {\n              const e = i[t];\n              if (\"loaded\" !== e.state && \"errored\" !== e.state) return !1;\n            }\n          }\n\n          return !0;\n        }\n\n        addSourceType(t, e, i) {\n          return this._lazyInitEmptyStyle(), this.style.addSourceType(t, e, i);\n        }\n\n        removeSource(t) {\n          return this.style.removeSource(t), this._update(!0);\n        }\n\n        getSource(t) {\n          return this.style.getSource(t);\n        }\n\n        addImage(e, i) {\n          let {\n            pixelRatio: o = 1,\n            sdf: a = !1,\n            stretchX: s,\n            stretchY: r,\n            content: n\n          } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n          if (this._lazyInitEmptyStyle(), i instanceof HTMLImageElement || t.isImageBitmap(i)) {\n            const {\n              width: l,\n              height: c,\n              data: h\n            } = t.exported.getImageData(i);\n            this.style.addImage(e, {\n              data: new t.RGBAImage({\n                width: l,\n                height: c\n              }, h),\n              pixelRatio: o,\n              stretchX: s,\n              stretchY: r,\n              content: n,\n              sdf: a,\n              version: 0\n            });\n          } else {\n            if (void 0 === i.width || void 0 === i.height) return this.fire(new t.ErrorEvent(new Error(\"Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`\")));\n            {\n              const {\n                width: l,\n                height: c,\n                data: h\n              } = i,\n                    u = i;\n              this.style.addImage(e, {\n                data: new t.RGBAImage({\n                  width: l,\n                  height: c\n                }, new Uint8Array(h)),\n                pixelRatio: o,\n                stretchX: s,\n                stretchY: r,\n                content: n,\n                sdf: a,\n                version: 0,\n                userImage: u\n              }), u.onAdd && u.onAdd(this, e);\n            }\n          }\n        }\n\n        updateImage(e, i) {\n          const o = this.style.getImage(e);\n          if (!o) return this.fire(new t.ErrorEvent(new Error(\"The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.\")));\n          const a = i instanceof HTMLImageElement || t.isImageBitmap(i) ? t.exported.getImageData(i) : i,\n                {\n            width: s,\n            height: r,\n            data: n\n          } = a;\n          if (void 0 === s || void 0 === r) return this.fire(new t.ErrorEvent(new Error(\"Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`\")));\n          if (s !== o.data.width || r !== o.data.height) return this.fire(new t.ErrorEvent(new Error(\"The width and height of the updated image must be that same as the previous version of the image\")));\n          const l = !(i instanceof HTMLImageElement || t.isImageBitmap(i));\n          o.data.replace(n, l), this.style.updateImage(e, o);\n        }\n\n        hasImage(e) {\n          return e ? !!this.style.getImage(e) : (this.fire(new t.ErrorEvent(new Error(\"Missing required image id\"))), !1);\n        }\n\n        removeImage(t) {\n          this.style.removeImage(t);\n        }\n\n        loadImage(e, i) {\n          t.getImage(this._requestManager.transformRequest(e, t.ResourceType.Image), i);\n        }\n\n        listImages() {\n          return this.style.listImages();\n        }\n\n        addLayer(t, e) {\n          return this._lazyInitEmptyStyle(), this.style.addLayer(t, e), this._update(!0);\n        }\n\n        moveLayer(t, e) {\n          return this.style.moveLayer(t, e), this._update(!0);\n        }\n\n        removeLayer(t) {\n          return this.style.removeLayer(t), this._update(!0);\n        }\n\n        getLayer(t) {\n          return this.style.getLayer(t);\n        }\n\n        setLayerZoomRange(t, e, i) {\n          return this.style.setLayerZoomRange(t, e, i), this._update(!0);\n        }\n\n        setFilter(t, e) {\n          let i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n          return this.style.setFilter(t, e, i), this._update(!0);\n        }\n\n        getFilter(t) {\n          return this.style.getFilter(t);\n        }\n\n        setPaintProperty(t, e, i) {\n          let o = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n          return this.style.setPaintProperty(t, e, i, o), this._update(!0);\n        }\n\n        getPaintProperty(t, e) {\n          return this.style.getPaintProperty(t, e);\n        }\n\n        setLayoutProperty(t, e, i) {\n          let o = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n          return this.style.setLayoutProperty(t, e, i, o), this._update(!0);\n        }\n\n        getLayoutProperty(t, e) {\n          return this.style.getLayoutProperty(t, e);\n        }\n\n        setLight(t) {\n          let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n          return this._lazyInitEmptyStyle(), this.style.setLight(t, e), this._update(!0);\n        }\n\n        getLight() {\n          return this.style.getLight();\n        }\n\n        setFeatureState(t, e) {\n          return this.style.setFeatureState(t, e), this._update();\n        }\n\n        removeFeatureState(t, e) {\n          return this.style.removeFeatureState(t, e), this._update();\n        }\n\n        getFeatureState(t) {\n          return this.style.getFeatureState(t);\n        }\n\n        getContainer() {\n          return this._container;\n        }\n\n        getCanvasContainer() {\n          return this._canvasContainer;\n        }\n\n        getCanvas() {\n          return this._canvas;\n        }\n\n        _containerDimensions() {\n          let t = 0,\n              e = 0;\n          return this._container && (t = this._container.clientWidth || 400, e = this._container.clientHeight || 300), [t, e];\n        }\n\n        _setupContainer() {\n          const t = this._container;\n          t.classList.add(\"maplibregl-map\", \"mapboxgl-map\");\n          const e = this._canvasContainer = s.create(\"div\", \"maplibregl-canvas-container mapboxgl-canvas-container\", t);\n          this._interactive && e.classList.add(\"maplibregl-interactive\", \"mapboxgl-interactive\"), this._canvas = s.create(\"canvas\", \"maplibregl-canvas mapboxgl-canvas\", e), this._canvas.addEventListener(\"webglcontextlost\", this._contextLost, !1), this._canvas.addEventListener(\"webglcontextrestored\", this._contextRestored, !1), this._canvas.setAttribute(\"tabindex\", \"0\"), this._canvas.setAttribute(\"aria-label\", \"Map\"), this._canvas.setAttribute(\"role\", \"region\");\n\n          const i = this._containerDimensions();\n\n          this._resizeCanvas(i[0], i[1], this.getPixelRatio());\n\n          const o = this._controlContainer = s.create(\"div\", \"maplibregl-control-container mapboxgl-control-container\", t),\n                a = this._controlPositions = {};\n          [\"top-left\", \"top-right\", \"bottom-left\", \"bottom-right\"].forEach(t => {\n            a[t] = s.create(\"div\", `maplibregl-ctrl-${t} mapboxgl-ctrl-${t}`, o);\n          }), this._container.addEventListener(\"scroll\", this._onMapScroll, !1);\n        }\n\n        _resizeCanvas(t, e, i) {\n          this._canvas.width = i * t, this._canvas.height = i * e, this._canvas.style.width = `${t}px`, this._canvas.style.height = `${e}px`;\n        }\n\n        _setupPainter() {\n          const i = t.extend({}, e.webGLContextAttributes, {\n            failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat,\n            preserveDrawingBuffer: this._preserveDrawingBuffer,\n            antialias: this._antialias || !1\n          }),\n                o = this._canvas.getContext(\"webgl\", i) || this._canvas.getContext(\"experimental-webgl\", i);\n\n          o ? (this.painter = new Yi(o, this.transform), t.exported$1.testSupport(o)) : this.fire(new t.ErrorEvent(new Error(\"Failed to initialize WebGL\")));\n        }\n\n        _contextLost(e) {\n          e.preventDefault(), this._frame && (this._frame.cancel(), this._frame = null), this.fire(new t.Event(\"webglcontextlost\", {\n            originalEvent: e\n          }));\n        }\n\n        _contextRestored(e) {\n          this._setupPainter(), this.resize(), this._update(), this.fire(new t.Event(\"webglcontextrestored\", {\n            originalEvent: e\n          }));\n        }\n\n        _onMapScroll(t) {\n          if (t.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, !1;\n        }\n\n        loaded() {\n          return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();\n        }\n\n        _update(t) {\n          return this.style ? (this._styleDirty = this._styleDirty || t, this._sourcesDirty = !0, this.triggerRepaint(), this) : this;\n        }\n\n        _requestRenderFrame(t) {\n          return this._update(), this._renderTaskQueue.add(t);\n        }\n\n        _cancelRenderFrame(t) {\n          this._renderTaskQueue.remove(t);\n        }\n\n        _render(e) {\n          let i,\n              o = 0;\n          const a = this.painter.context.extTimerQuery;\n          if (this.listens(\"gpu-timing-frame\") && (i = a.createQueryEXT(), a.beginQueryEXT(a.TIME_ELAPSED_EXT, i), o = t.exported.now()), this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(e), this._removed) return;\n          let s = !1;\n\n          if (this.style && this._styleDirty) {\n            this._styleDirty = !1;\n            const e = this.transform.zoom,\n                  i = t.exported.now();\n            this.style.zoomHistory.update(e, i);\n            const o = new t.EvaluationParameters(e, {\n              now: i,\n              fadeDuration: this._fadeDuration,\n              zoomHistory: this.style.zoomHistory,\n              transition: this.style.getTransition()\n            }),\n                  a = o.crossFadingFactor();\n            1 === a && a === this._crossFadingFactor || (s = !0, this._crossFadingFactor = a), this.style.update(o);\n          }\n\n          if (this.style && this._sourcesDirty && (this._sourcesDirty = !1, this.style._updateSources(this.transform)), this._placementDirty = this.style && this.style._updatePlacement(this.painter.transform, this.showCollisionBoxes, this._fadeDuration, this._crossSourceCollisions), this.painter.render(this.style, {\n            showTileBoundaries: this.showTileBoundaries,\n            showOverdrawInspector: this._showOverdrawInspector,\n            rotating: this.isRotating(),\n            zooming: this.isZooming(),\n            moving: this.isMoving(),\n            fadeDuration: this._fadeDuration,\n            showPadding: this.showPadding,\n            gpuTiming: !!this.listens(\"gpu-timing-layer\")\n          }), this.fire(new t.Event(\"render\")), this.loaded() && !this._loaded && (this._loaded = !0, t.PerformanceUtils.mark(t.PerformanceMarkers.load), this.fire(new t.Event(\"load\"))), this.style && (this.style.hasTransitions() || s) && (this._styleDirty = !0), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles(), this.listens(\"gpu-timing-frame\")) {\n            const e = t.exported.now() - o;\n            a.endQueryEXT(a.TIME_ELAPSED_EXT, i), setTimeout(() => {\n              const o = a.getQueryObjectEXT(i, a.QUERY_RESULT_EXT) / 1e6;\n              a.deleteQueryEXT(i), this.fire(new t.Event(\"gpu-timing-frame\", {\n                cpuTime: e,\n                gpuTime: o\n              }));\n            }, 50);\n          }\n\n          if (this.listens(\"gpu-timing-layer\")) {\n            const e = this.painter.collectGpuTimers();\n            setTimeout(() => {\n              const i = this.painter.queryGpuTimers(e);\n              this.fire(new t.Event(\"gpu-timing-layer\", {\n                layerTimes: i\n              }));\n            }, 50);\n          }\n\n          const r = this._sourcesDirty || this._styleDirty || this._placementDirty;\n          return r || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new t.Event(\"idle\")), !this._loaded || this._fullyLoaded || r || (this._fullyLoaded = !0, t.PerformanceUtils.mark(t.PerformanceMarkers.fullLoad)), this;\n        }\n\n        redraw() {\n          return this.style && (this._frame && (this._frame.cancel(), this._frame = null), this._render(0)), this;\n        }\n\n        remove() {\n          this._hash && this._hash.remove();\n\n          for (const t of this._controls) t.onRemove(this);\n\n          this._controls = [], this._frame && (this._frame.cancel(), this._frame = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), \"undefined\" != typeof window && (removeEventListener(\"resize\", this._onWindowResize, !1), removeEventListener(\"orientationchange\", this._onWindowResize, !1), removeEventListener(\"online\", this._onWindowOnline, !1));\n          const e = this.painter.context.gl.getExtension(\"WEBGL_lose_context\");\n          e && e.loseContext(), this._canvas.removeEventListener(\"webglcontextrestored\", this._contextRestored, !1), this._canvas.removeEventListener(\"webglcontextlost\", this._contextLost, !1), s.remove(this._canvasContainer), s.remove(this._controlContainer), this._container.classList.remove(\"maplibregl-map\", \"mapboxgl-map\"), t.PerformanceUtils.clearMetrics(), this._removed = !0, this.fire(new t.Event(\"remove\"));\n        }\n\n        triggerRepaint() {\n          this.style && !this._frame && (this._frame = t.exported.frame(e => {\n            t.PerformanceUtils.frame(e), this._frame = null, this._render(e);\n          }));\n        }\n\n        _onWindowOnline() {\n          this._update();\n        }\n\n        _onWindowResize(t) {\n          this._trackResize && this.resize({\n            originalEvent: t\n          })._update();\n        }\n\n        get showTileBoundaries() {\n          return !!this._showTileBoundaries;\n        }\n\n        set showTileBoundaries(t) {\n          this._showTileBoundaries !== t && (this._showTileBoundaries = t, this._update());\n        }\n\n        get showPadding() {\n          return !!this._showPadding;\n        }\n\n        set showPadding(t) {\n          this._showPadding !== t && (this._showPadding = t, this._update());\n        }\n\n        get showCollisionBoxes() {\n          return !!this._showCollisionBoxes;\n        }\n\n        set showCollisionBoxes(t) {\n          this._showCollisionBoxes !== t && (this._showCollisionBoxes = t, t ? this.style._generateCollisionBoxes() : this._update());\n        }\n\n        get showOverdrawInspector() {\n          return !!this._showOverdrawInspector;\n        }\n\n        set showOverdrawInspector(t) {\n          this._showOverdrawInspector !== t && (this._showOverdrawInspector = t, this._update());\n        }\n\n        get repaint() {\n          return !!this._repaint;\n        }\n\n        set repaint(t) {\n          this._repaint !== t && (this._repaint = t, this.triggerRepaint());\n        }\n\n        get vertices() {\n          return !!this._vertices;\n        }\n\n        set vertices(t) {\n          this._vertices = t, this._update();\n        }\n\n        _setCacheLimits(e, i) {\n          t.setCacheLimits(e, i);\n        }\n\n      },\n      NavigationControl: class {\n        constructor(e) {\n          this.options = t.extend({}, aa, e), this._container = s.create(\"div\", \"maplibregl-ctrl maplibregl-ctrl-group mapboxgl-ctrl mapboxgl-ctrl-group\"), this._container.addEventListener(\"contextmenu\", t => t.preventDefault()), this.options.showZoom && (t.bindAll([\"_setButtonTitle\", \"_updateZoomButtons\"], this), this._zoomInButton = this._createButton(\"maplibregl-ctrl-zoom-in mapboxgl-ctrl-zoom-in\", t => this._map.zoomIn({}, {\n            originalEvent: t\n          })), s.create(\"span\", \"maplibregl-ctrl-icon mapboxgl-ctrl-icon\", this._zoomInButton).setAttribute(\"aria-hidden\", \"true\"), this._zoomOutButton = this._createButton(\"maplibregl-ctrl-zoom-out mapboxgl-ctrl-zoom-out\", t => this._map.zoomOut({}, {\n            originalEvent: t\n          })), s.create(\"span\", \"maplibregl-ctrl-icon mapboxgl-ctrl-icon\", this._zoomOutButton).setAttribute(\"aria-hidden\", \"true\")), this.options.showCompass && (t.bindAll([\"_rotateCompassArrow\"], this), this._compass = this._createButton(\"maplibregl-ctrl-compass mapboxgl-ctrl-compass\", t => {\n            this.options.visualizePitch ? this._map.resetNorthPitch({}, {\n              originalEvent: t\n            }) : this._map.resetNorth({}, {\n              originalEvent: t\n            });\n          }), this._compassIcon = s.create(\"span\", \"maplibregl-ctrl-icon mapboxgl-ctrl-icon\", this._compass), this._compassIcon.setAttribute(\"aria-hidden\", \"true\"));\n        }\n\n        _updateZoomButtons() {\n          const t = this._map.getZoom(),\n                e = t === this._map.getMaxZoom(),\n                i = t === this._map.getMinZoom();\n\n          this._zoomInButton.disabled = e, this._zoomOutButton.disabled = i, this._zoomInButton.setAttribute(\"aria-disabled\", e.toString()), this._zoomOutButton.setAttribute(\"aria-disabled\", i.toString());\n        }\n\n        _rotateCompassArrow() {\n          const t = this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitch * (Math.PI / 180)), .5)}) rotateX(${this._map.transform.pitch}deg) rotateZ(${this._map.transform.angle * (180 / Math.PI)}deg)` : `rotate(${this._map.transform.angle * (180 / Math.PI)}deg)`;\n          this._compassIcon.style.transform = t;\n        }\n\n        onAdd(t) {\n          return this._map = t, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, \"ZoomIn\"), this._setButtonTitle(this._zoomOutButton, \"ZoomOut\"), this._map.on(\"zoom\", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, \"ResetBearing\"), this.options.visualizePitch && this._map.on(\"pitch\", this._rotateCompassArrow), this._map.on(\"rotate\", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new sa(this._map, this._compass, this.options.visualizePitch)), this._container;\n        }\n\n        onRemove() {\n          s.remove(this._container), this.options.showZoom && this._map.off(\"zoom\", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off(\"pitch\", this._rotateCompassArrow), this._map.off(\"rotate\", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map;\n        }\n\n        _createButton(t, e) {\n          const i = s.create(\"button\", t, this._container);\n          return i.type = \"button\", i.addEventListener(\"click\", e), i;\n        }\n\n        _setButtonTitle(t, e) {\n          const i = this._map._getUIString(`NavigationControl.${e}`);\n\n          t.title = i, t.setAttribute(\"aria-label\", i);\n        }\n\n      },\n      GeolocateControl: class extends t.Evented {\n        constructor(e) {\n          super(), this.options = t.extend({}, ha, e), t.bindAll([\"_onSuccess\", \"_onError\", \"_onZoom\", \"_finish\", \"_setupUI\", \"_updateCamera\", \"_updateMarker\"], this);\n        }\n\n        onAdd(t) {\n          var e;\n          return this._map = t, this._container = s.create(\"div\", \"maplibregl-ctrl maplibregl-ctrl-group mapboxgl-ctrl mapboxgl-ctrl-group\"), e = this._setupUI, void 0 !== ua ? e(ua) : void 0 !== window.navigator.permissions ? window.navigator.permissions.query({\n            name: \"geolocation\"\n          }).then(t => {\n            ua = \"denied\" !== t.state, e(ua);\n          }) : (ua = !!window.navigator.geolocation, e(ua)), this._container;\n        }\n\n        onRemove() {\n          void 0 !== this._geolocationWatchID && (window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), s.remove(this._container), this._map.off(\"zoom\", this._onZoom), this._map = void 0, da = 0, ma = !1;\n        }\n\n        _isOutOfMapMaxBounds(t) {\n          const e = this._map.getMaxBounds(),\n                i = t.coords;\n\n          return e && (i.longitude < e.getWest() || i.longitude > e.getEast() || i.latitude < e.getSouth() || i.latitude > e.getNorth());\n        }\n\n        _setErrorState() {\n          switch (this._watchState) {\n            case \"WAITING_ACTIVE\":\n              this._watchState = \"ACTIVE_ERROR\", this._geolocateButton.classList.remove(\"maplibregl-ctrl-geolocate-active\", \"mapboxgl-ctrl-geolocate-active\"), this._geolocateButton.classList.add(\"maplibregl-ctrl-geolocate-active-error\", \"mapboxgl-ctrl-geolocate-active-error\");\n              break;\n\n            case \"ACTIVE_LOCK\":\n              this._watchState = \"ACTIVE_ERROR\", this._geolocateButton.classList.remove(\"maplibregl-ctrl-geolocate-active\", \"mapboxgl-ctrl-geolocate-active\"), this._geolocateButton.classList.add(\"maplibregl-ctrl-geolocate-active-error\", \"mapboxgl-ctrl-geolocate-active-error\"), this._geolocateButton.classList.add(\"maplibregl-ctrl-geolocate-waiting\", \"mapboxgl-ctrl-geolocate-waiting\");\n              break;\n\n            case \"BACKGROUND\":\n              this._watchState = \"BACKGROUND_ERROR\", this._geolocateButton.classList.remove(\"maplibregl-ctrl-geolocate-background\", \"mapboxgl-ctrl-geolocate-background\"), this._geolocateButton.classList.add(\"maplibregl-ctrl-geolocate-background-error\", \"mapboxgl-ctrl-geolocate-background-error\"), this._geolocateButton.classList.add(\"maplibregl-ctrl-geolocate-waiting\", \"mapboxgl-ctrl-geolocate-waiting\");\n          }\n        }\n\n        _onSuccess(e) {\n          if (this._map) {\n            if (this._isOutOfMapMaxBounds(e)) return this._setErrorState(), this.fire(new t.Event(\"outofmaxbounds\", e)), this._updateMarker(), void this._finish();\n            if (this.options.trackUserLocation) switch (this._lastKnownPosition = e, this._watchState) {\n              case \"WAITING_ACTIVE\":\n              case \"ACTIVE_LOCK\":\n              case \"ACTIVE_ERROR\":\n                this._watchState = \"ACTIVE_LOCK\", this._geolocateButton.classList.remove(\"maplibregl-ctrl-geolocate-waiting\", \"mapboxgl-ctrl-geolocate-waiting\"), this._geolocateButton.classList.remove(\"maplibregl-ctrl-geolocate-active-error\", \"mapboxgl-ctrl-geolocate-active-error\"), this._geolocateButton.classList.add(\"maplibregl-ctrl-geolocate-active\", \"mapboxgl-ctrl-geolocate-active\");\n                break;\n\n              case \"BACKGROUND\":\n              case \"BACKGROUND_ERROR\":\n                this._watchState = \"BACKGROUND\", this._geolocateButton.classList.remove(\"maplibregl-ctrl-geolocate-waiting\", \"mapboxgl-ctrl-geolocate-waiting\"), this._geolocateButton.classList.remove(\"maplibregl-ctrl-geolocate-background-error\", \"mapboxgl-ctrl-geolocate-background-error\"), this._geolocateButton.classList.add(\"maplibregl-ctrl-geolocate-background\", \"mapboxgl-ctrl-geolocate-background\");\n            }\n            this.options.showUserLocation && \"OFF\" !== this._watchState && this._updateMarker(e), this.options.trackUserLocation && \"ACTIVE_LOCK\" !== this._watchState || this._updateCamera(e), this.options.showUserLocation && this._dotElement.classList.remove(\"maplibregl-user-location-dot-stale\", \"mapboxgl-user-location-dot-stale\"), this.fire(new t.Event(\"geolocate\", e)), this._finish();\n          }\n        }\n\n        _updateCamera(e) {\n          const i = new t.LngLat(e.coords.longitude, e.coords.latitude),\n                o = e.coords.accuracy,\n                a = this._map.getBearing(),\n                s = t.extend({\n            bearing: a\n          }, this.options.fitBoundsOptions);\n\n          this._map.fitBounds(i.toBounds(o), s, {\n            geolocateSource: !0\n          });\n        }\n\n        _updateMarker(e) {\n          if (e) {\n            const i = new t.LngLat(e.coords.longitude, e.coords.latitude);\n            this._accuracyCircleMarker.setLngLat(i).addTo(this._map), this._userLocationDotMarker.setLngLat(i).addTo(this._map), this._accuracy = e.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();\n          } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();\n        }\n\n        _updateCircleRadius() {\n          const t = this._map._container.clientHeight / 2,\n                e = this._map.unproject([0, t]),\n                i = this._map.unproject([1, t]),\n                o = e.distanceTo(i),\n                a = Math.ceil(2 * this._accuracy / o);\n\n          this._circleElement.style.width = `${a}px`, this._circleElement.style.height = `${a}px`;\n        }\n\n        _onZoom() {\n          this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();\n        }\n\n        _onError(e) {\n          if (this._map) {\n            if (this.options.trackUserLocation) if (1 === e.code) {\n              this._watchState = \"OFF\", this._geolocateButton.classList.remove(\"maplibregl-ctrl-geolocate-waiting\", \"mapboxgl-ctrl-geolocate-waiting\"), this._geolocateButton.classList.remove(\"maplibregl-ctrl-geolocate-active\", \"mapboxgl-ctrl-geolocate-active\"), this._geolocateButton.classList.remove(\"maplibregl-ctrl-geolocate-active-error\", \"mapboxgl-ctrl-geolocate-active-error\"), this._geolocateButton.classList.remove(\"maplibregl-ctrl-geolocate-background\", \"mapboxgl-ctrl-geolocate-background\"), this._geolocateButton.classList.remove(\"maplibregl-ctrl-geolocate-background-error\", \"mapboxgl-ctrl-geolocate-background-error\"), this._geolocateButton.disabled = !0;\n\n              const t = this._map._getUIString(\"GeolocateControl.LocationNotAvailable\");\n\n              this._geolocateButton.title = t, this._geolocateButton.setAttribute(\"aria-label\", t), void 0 !== this._geolocationWatchID && this._clearWatch();\n            } else {\n              if (3 === e.code && ma) return;\n\n              this._setErrorState();\n            }\n            \"OFF\" !== this._watchState && this.options.showUserLocation && this._dotElement.classList.add(\"maplibregl-user-location-dot-stale\", \"mapboxgl-user-location-dot-stale\"), this.fire(new t.Event(\"error\", e)), this._finish();\n          }\n        }\n\n        _finish() {\n          this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;\n        }\n\n        _setupUI(e) {\n          if (this._container.addEventListener(\"contextmenu\", t => t.preventDefault()), this._geolocateButton = s.create(\"button\", \"maplibregl-ctrl-geolocate mapboxgl-ctrl-geolocate\", this._container), s.create(\"span\", \"maplibregl-ctrl-icon mapboxgl-ctrl-icon\", this._geolocateButton).setAttribute(\"aria-hidden\", \"true\"), this._geolocateButton.type = \"button\", !1 === e) {\n            t.warnOnce(\"Geolocation support is not available so the GeolocateControl will be disabled.\");\n\n            const e = this._map._getUIString(\"GeolocateControl.LocationNotAvailable\");\n\n            this._geolocateButton.disabled = !0, this._geolocateButton.title = e, this._geolocateButton.setAttribute(\"aria-label\", e);\n          } else {\n            const t = this._map._getUIString(\"GeolocateControl.FindMyLocation\");\n\n            this._geolocateButton.title = t, this._geolocateButton.setAttribute(\"aria-label\", t);\n          }\n\n          this.options.trackUserLocation && (this._geolocateButton.setAttribute(\"aria-pressed\", \"false\"), this._watchState = \"OFF\"), this.options.showUserLocation && (this._dotElement = s.create(\"div\", \"maplibregl-user-location-dot mapboxgl-user-location-dot\"), this._userLocationDotMarker = new ca(this._dotElement), this._circleElement = s.create(\"div\", \"maplibregl-user-location-accuracy-circle mapboxgl-user-location-accuracy-circle\"), this._accuracyCircleMarker = new ca({\n            element: this._circleElement,\n            pitchAlignment: \"map\"\n          }), this.options.trackUserLocation && (this._watchState = \"OFF\"), this._map.on(\"zoom\", this._onZoom)), this._geolocateButton.addEventListener(\"click\", this.trigger.bind(this)), this._setup = !0, this.options.trackUserLocation && this._map.on(\"movestart\", e => {\n            e.geolocateSource || \"ACTIVE_LOCK\" !== this._watchState || e.originalEvent && \"resize\" === e.originalEvent.type || (this._watchState = \"BACKGROUND\", this._geolocateButton.classList.add(\"maplibregl-ctrl-geolocate-background\", \"mapboxgl-ctrl-geolocate-background\"), this._geolocateButton.classList.remove(\"maplibregl-ctrl-geolocate-active\", \"mapboxgl-ctrl-geolocate-active\"), this.fire(new t.Event(\"trackuserlocationend\")));\n          });\n        }\n\n        trigger() {\n          if (!this._setup) return t.warnOnce(\"Geolocate control triggered before added to a map\"), !1;\n\n          if (this.options.trackUserLocation) {\n            switch (this._watchState) {\n              case \"OFF\":\n                this._watchState = \"WAITING_ACTIVE\", this.fire(new t.Event(\"trackuserlocationstart\"));\n                break;\n\n              case \"WAITING_ACTIVE\":\n              case \"ACTIVE_LOCK\":\n              case \"ACTIVE_ERROR\":\n              case \"BACKGROUND_ERROR\":\n                da--, ma = !1, this._watchState = \"OFF\", this._geolocateButton.classList.remove(\"maplibregl-ctrl-geolocate-waiting\", \"mapboxgl-ctrl-geolocate-waiting\"), this._geolocateButton.classList.remove(\"maplibregl-ctrl-geolocate-active\", \"mapboxgl-ctrl-geolocate-active\"), this._geolocateButton.classList.remove(\"maplibregl-ctrl-geolocate-active-error\", \"mapboxgl-ctrl-geolocate-active-error\"), this._geolocateButton.classList.remove(\"maplibregl-ctrl-geolocate-background\", \"mapboxgl-ctrl-geolocate-background\"), this._geolocateButton.classList.remove(\"maplibregl-ctrl-geolocate-background-error\", \"mapboxgl-ctrl-geolocate-background-error\"), this.fire(new t.Event(\"trackuserlocationend\"));\n                break;\n\n              case \"BACKGROUND\":\n                this._watchState = \"ACTIVE_LOCK\", this._geolocateButton.classList.remove(\"maplibregl-ctrl-geolocate-background\", \"mapboxgl-ctrl-geolocate-background\"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new t.Event(\"trackuserlocationstart\"));\n            }\n\n            switch (this._watchState) {\n              case \"WAITING_ACTIVE\":\n                this._geolocateButton.classList.add(\"maplibregl-ctrl-geolocate-waiting\", \"mapboxgl-ctrl-geolocate-waiting\"), this._geolocateButton.classList.add(\"maplibregl-ctrl-geolocate-active\", \"mapboxgl-ctrl-geolocate-active\");\n                break;\n\n              case \"ACTIVE_LOCK\":\n                this._geolocateButton.classList.add(\"maplibregl-ctrl-geolocate-active\", \"mapboxgl-ctrl-geolocate-active\");\n\n            }\n\n            if (\"OFF\" === this._watchState && void 0 !== this._geolocationWatchID) this._clearWatch();else if (void 0 === this._geolocationWatchID) {\n              let t;\n              this._geolocateButton.classList.add(\"maplibregl-ctrl-geolocate-waiting\", \"mapboxgl-ctrl-geolocate-waiting\"), this._geolocateButton.setAttribute(\"aria-pressed\", \"true\"), da++, da > 1 ? (t = {\n                maximumAge: 6e5,\n                timeout: 0\n              }, ma = !0) : (t = this.options.positionOptions, ma = !1), this._geolocationWatchID = window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, t);\n            }\n          } else window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);\n\n          return !0;\n        }\n\n        _clearWatch() {\n          window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove(\"maplibregl-ctrl-geolocate-waiting\", \"mapboxgl-ctrl-geolocate-waiting\"), this._geolocateButton.setAttribute(\"aria-pressed\", \"false\"), this.options.showUserLocation && this._updateMarker(null);\n        }\n\n      },\n      AttributionControl: Qo,\n      ScaleControl: class {\n        constructor(e) {\n          this.options = t.extend({}, _a, e), t.bindAll([\"_onMove\", \"setUnit\"], this);\n        }\n\n        getDefaultPosition() {\n          return \"bottom-left\";\n        }\n\n        _onMove() {\n          pa(this._map, this._container, this.options);\n        }\n\n        onAdd(t) {\n          return this._map = t, this._container = s.create(\"div\", \"maplibregl-ctrl maplibregl-ctrl-scale mapboxgl-ctrl mapboxgl-ctrl-scale\", t.getContainer()), this._map.on(\"move\", this._onMove), this._onMove(), this._container;\n        }\n\n        onRemove() {\n          s.remove(this._container), this._map.off(\"move\", this._onMove), this._map = void 0;\n        }\n\n        setUnit(t) {\n          this.options.unit = t, pa(this._map, this._container, this.options);\n        }\n\n      },\n      FullscreenControl: class {\n        constructor(e) {\n          this._fullscreen = !1, e && e.container && (e.container instanceof HTMLElement ? this._container = e.container : t.warnOnce(\"Full screen control 'container' must be a DOM element.\")), t.bindAll([\"_onClickFullscreen\", \"_changeIcon\"], this), \"onfullscreenchange\" in document ? this._fullscreenchange = \"fullscreenchange\" : \"onmozfullscreenchange\" in document ? this._fullscreenchange = \"mozfullscreenchange\" : \"onwebkitfullscreenchange\" in document ? this._fullscreenchange = \"webkitfullscreenchange\" : \"onmsfullscreenchange\" in document && (this._fullscreenchange = \"MSFullscreenChange\");\n        }\n\n        onAdd(e) {\n          return this._map = e, this._container || (this._container = this._map.getContainer()), this._controlContainer = s.create(\"div\", \"maplibregl-ctrl maplibregl-ctrl-group mapboxgl-ctrl mapboxgl-ctrl-group\"), this._checkFullscreenSupport() ? this._setupUI() : (this._controlContainer.style.display = \"none\", t.warnOnce(\"This device does not support fullscreen mode.\")), this._controlContainer;\n        }\n\n        onRemove() {\n          s.remove(this._controlContainer), this._map = null, window.document.removeEventListener(this._fullscreenchange, this._changeIcon);\n        }\n\n        _checkFullscreenSupport() {\n          return !!(document.fullscreenEnabled || document.mozFullScreenEnabled || document.msFullscreenEnabled || document.webkitFullscreenEnabled);\n        }\n\n        _setupUI() {\n          const t = this._fullscreenButton = s.create(\"button\", \"maplibregl-ctrl-fullscreen mapboxgl-ctrl-fullscreen\", this._controlContainer);\n          s.create(\"span\", \"maplibregl-ctrl-icon mapboxgl-ctrl-icon\", t).setAttribute(\"aria-hidden\", \"true\"), t.type = \"button\", this._updateTitle(), this._fullscreenButton.addEventListener(\"click\", this._onClickFullscreen), window.document.addEventListener(this._fullscreenchange, this._changeIcon);\n        }\n\n        _updateTitle() {\n          const t = this._getTitle();\n\n          this._fullscreenButton.setAttribute(\"aria-label\", t), this._fullscreenButton.title = t;\n        }\n\n        _getTitle() {\n          return this._map._getUIString(this._isFullscreen() ? \"FullscreenControl.Exit\" : \"FullscreenControl.Enter\");\n        }\n\n        _isFullscreen() {\n          return this._fullscreen;\n        }\n\n        _changeIcon() {\n          (window.document.fullscreenElement || window.document.mozFullScreenElement || window.document.webkitFullscreenElement || window.document.msFullscreenElement) === this._container !== this._fullscreen && (this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle(\"maplibregl-ctrl-shrink\"), this._fullscreenButton.classList.toggle(\"mapboxgl-ctrl-shrink\"), this._fullscreenButton.classList.toggle(\"maplibregl-ctrl-fullscreen\"), this._fullscreenButton.classList.toggle(\"mapboxgl-ctrl-fullscreen\"), this._updateTitle());\n        }\n\n        _onClickFullscreen() {\n          this._isFullscreen() ? window.document.exitFullscreen ? window.document.exitFullscreen() : window.document.mozCancelFullScreen ? window.document.mozCancelFullScreen() : window.document.msExitFullscreen ? window.document.msExitFullscreen() : window.document.webkitCancelFullScreen && window.document.webkitCancelFullScreen() : this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen && this._container.webkitRequestFullscreen();\n        }\n\n      },\n      Popup: class extends t.Evented {\n        constructor(e) {\n          super(), this.options = t.extend(Object.create(ga), e), t.bindAll([\"_update\", \"_onClose\", \"remove\", \"_onMouseMove\", \"_onMouseUp\", \"_onDrag\"], this);\n        }\n\n        addTo(e) {\n          return this._map && this.remove(), this._map = e, this.options.closeOnClick && this._map.on(\"click\", this._onClose), this.options.closeOnMove && this._map.on(\"move\", this._onClose), this._map.on(\"remove\", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on(\"mousemove\", this._onMouseMove), this._map.on(\"mouseup\", this._onMouseUp), this._container && this._container.classList.add(\"maplibregl-popup-track-pointer\", \"mapboxgl-popup-track-pointer\"), this._map._canvasContainer.classList.add(\"maplibregl-track-pointer\", \"mapboxgl-track-pointer\")) : this._map.on(\"move\", this._update), this.fire(new t.Event(\"open\")), this;\n        }\n\n        isOpen() {\n          return !!this._map;\n        }\n\n        remove() {\n          return this._content && s.remove(this._content), this._container && (s.remove(this._container), delete this._container), this._map && (this._map.off(\"move\", this._update), this._map.off(\"move\", this._onClose), this._map.off(\"click\", this._onClose), this._map.off(\"remove\", this.remove), this._map.off(\"mousemove\", this._onMouseMove), this._map.off(\"mouseup\", this._onMouseUp), this._map.off(\"drag\", this._onDrag), delete this._map), this.fire(new t.Event(\"close\")), this;\n        }\n\n        getLngLat() {\n          return this._lngLat;\n        }\n\n        setLngLat(e) {\n          return this._lngLat = t.LngLat.convert(e), this._pos = null, this._trackPointer = !1, this._update(), this._map && (this._map.on(\"move\", this._update), this._map.off(\"mousemove\", this._onMouseMove), this._container && this._container.classList.remove(\"maplibregl-popup-track-pointer\", \"mapboxgl-popup-track-pointer\"), this._map._canvasContainer.classList.remove(\"maplibregl-track-pointer\", \"mapboxgl-track-pointer\")), this;\n        }\n\n        trackPointer() {\n          return this._trackPointer = !0, this._pos = null, this._update(), this._map && (this._map.off(\"move\", this._update), this._map.on(\"mousemove\", this._onMouseMove), this._map.on(\"drag\", this._onDrag), this._container && this._container.classList.add(\"maplibregl-popup-track-pointer\", \"mapboxgl-popup-track-pointer\"), this._map._canvasContainer.classList.add(\"maplibregl-track-pointer\", \"mapboxgl-track-pointer\")), this;\n        }\n\n        getElement() {\n          return this._container;\n        }\n\n        setText(t) {\n          return this.setDOMContent(document.createTextNode(t));\n        }\n\n        setHTML(t) {\n          const e = document.createDocumentFragment(),\n                i = document.createElement(\"body\");\n          let o;\n\n          for (i.innerHTML = t; o = i.firstChild, o;) e.appendChild(o);\n\n          return this.setDOMContent(e);\n        }\n\n        getMaxWidth() {\n          return this._container && this._container.style.maxWidth;\n        }\n\n        setMaxWidth(t) {\n          return this.options.maxWidth = t, this._update(), this;\n        }\n\n        setDOMContent(t) {\n          if (this._content) for (; this._content.hasChildNodes();) this._content.firstChild && this._content.removeChild(this._content.firstChild);else this._content = s.create(\"div\", \"maplibregl-popup-content mapboxgl-popup-content\", this._container);\n          return this._content.appendChild(t), this._createCloseButton(), this._update(), this._focusFirstElement(), this;\n        }\n\n        addClassName(t) {\n          this._container && this._container.classList.add(t);\n        }\n\n        removeClassName(t) {\n          this._container && this._container.classList.remove(t);\n        }\n\n        setOffset(t) {\n          return this.options.offset = t, this._update(), this;\n        }\n\n        toggleClassName(t) {\n          if (this._container) return this._container.classList.toggle(t);\n        }\n\n        _createCloseButton() {\n          this.options.closeButton && (this._closeButton = s.create(\"button\", \"maplibregl-popup-close-button mapboxgl-popup-close-button\", this._content), this._closeButton.type = \"button\", this._closeButton.setAttribute(\"aria-label\", \"Close popup\"), this._closeButton.innerHTML = \"&#215;\", this._closeButton.addEventListener(\"click\", this._onClose));\n        }\n\n        _onMouseUp(t) {\n          this._update(t.point);\n        }\n\n        _onMouseMove(t) {\n          this._update(t.point);\n        }\n\n        _onDrag(t) {\n          this._update(t.point);\n        }\n\n        _update(t) {\n          if (!this._map || !this._lngLat && !this._trackPointer || !this._content) return;\n          if (this._container || (this._container = s.create(\"div\", \"maplibregl-popup mapboxgl-popup\", this._map.getContainer()), this._tip = s.create(\"div\", \"maplibregl-popup-tip mapboxgl-popup-tip\", this._container), this._container.appendChild(this._content), this.options.className && this.options.className.split(\" \").forEach(t => this._container.classList.add(t)), this._trackPointer && this._container.classList.add(\"maplibregl-popup-track-pointer\", \"mapboxgl-popup-track-pointer\")), this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._map.transform.renderWorldCopies && !this._trackPointer && (this._lngLat = ra(this._lngLat, this._pos, this._map.transform)), this._trackPointer && !t) return;\n          const e = this._pos = this._trackPointer && t ? t : this._map.project(this._lngLat);\n          let i = this.options.anchor;\n          const o = va(this.options.offset);\n\n          if (!i) {\n            const t = this._container.offsetWidth,\n                  a = this._container.offsetHeight;\n            let s;\n            s = e.y + o.bottom.y < a ? [\"top\"] : e.y > this._map.transform.height - a ? [\"bottom\"] : [], e.x < t / 2 ? s.push(\"left\") : e.x > this._map.transform.width - t / 2 && s.push(\"right\"), i = 0 === s.length ? \"bottom\" : s.join(\"-\");\n          }\n\n          const a = e.add(o[i]).round();\n          s.setTransform(this._container, `${na[i]} translate(${a.x}px,${a.y}px)`), la(this._container, i, \"popup\");\n        }\n\n        _focusFirstElement() {\n          if (!this.options.focusAfterOpen || !this._container) return;\n\n          const t = this._container.querySelector(xa);\n\n          t && t.focus();\n        }\n\n        _onClose() {\n          this.remove();\n        }\n\n      },\n      Marker: ca,\n      Style: oe,\n      LngLat: t.LngLat,\n      LngLatBounds: t.LngLatBounds,\n      Point: t.pointGeometry,\n      MercatorCoordinate: t.MercatorCoordinate,\n      Evented: t.Evented,\n      AJAXError: t.AJAXError,\n      config: t.config,\n      CanvasSource: k,\n      GeoJSONSource: A,\n      ImageSource: L,\n      RasterDEMTileSource: D,\n      RasterTileSource: P,\n      VectorTileSource: C,\n      VideoSource: R,\n      prewarm: function () {\n        K().acquire($);\n      },\n      clearPrewarmedResources: function () {\n        const t = H;\n        t && (t.isPreloaded() && 1 === t.numActive() ? (t.release($), H = null) : console.warn(\"Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()\"));\n      },\n\n      get workerCount() {\n        return W.workerCount;\n      },\n\n      set workerCount(t) {\n        W.workerCount = t;\n      },\n\n      get maxParallelImageRequests() {\n        return t.config.MAX_PARALLEL_IMAGE_REQUESTS;\n      },\n\n      set maxParallelImageRequests(e) {\n        t.config.MAX_PARALLEL_IMAGE_REQUESTS = e;\n      },\n\n      clearStorage(e) {\n        t.clearTileCache(e);\n      },\n\n      workerUrl: \"\",\n\n      addProtocol(e, i) {\n        t.config.REGISTERED_PROTOCOLS[e] = i;\n      },\n\n      removeProtocol(e) {\n        delete t.config.REGISTERED_PROTOCOLS[e];\n      }\n\n    };\n    return Yo.extend(ya, {\n      isSafari: t.isSafari,\n      getPerformanceMetrics: t.PerformanceUtils.getPerformanceMetrics\n    }), ya;\n  }); //\n\n  var maplibregl$1 = maplibregl;\n  return maplibregl$1;\n});","map":null,"metadata":{},"sourceType":"script"}