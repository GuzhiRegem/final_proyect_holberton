{"ast":null,"code":"class IImage {\n  loadFile(file) {\n    return new Promise((resolve, reject) => {\n      const reader = new FileReader();\n      const node = new Image();\n      reader.addEventListener('load', () => {\n        const imageUrl = reader.result;\n\n        node.onload = () => {\n          this.id = file.name;\n          this.url = imageUrl;\n          this.width = node.width;\n          this.height = node.height;\n          resolve(this);\n        };\n\n        node.onerror = reject;\n        node.src = imageUrl;\n      }, false);\n      reader.readAsDataURL(file);\n    });\n  }\n\n  loadUrl(url) {\n    return new Promise((resolve, reject) => {\n      const node = new Image();\n\n      node.onload = () => {\n        this.id = url.split('/').pop();\n        this.url = url;\n        this.width = node.width;\n        this.height = node.height;\n        resolve(this);\n      };\n\n      node.onerror = reject;\n      node.src = url;\n    });\n  }\n\n  setInitialPosition(map) {\n    if (!this.width || !this.height) throw Error('image is not loaded');\n    const padding = 20;\n    const mapCanvas = map.getCanvas();\n    const canvasWidth = mapCanvas.offsetWidth;\n    const canvasHeight = mapCanvas.offsetHeight;\n    const maxWidth = canvasWidth - padding * 2;\n    const maxHeight = canvasHeight - padding * 2;\n    const ratio = Math.min(maxWidth / this.width, maxHeight / this.height);\n    const resizeWidth = this.width * ratio;\n    const resizeHeight = this.height * ratio;\n    const result = [[canvasWidth / 2 - resizeWidth / 2, canvasHeight / 2 - resizeHeight / 2], [canvasWidth / 2 + resizeWidth / 2, canvasHeight / 2 - resizeHeight / 2], [canvasWidth / 2 + resizeWidth / 2, canvasHeight / 2 + resizeHeight / 2], [canvasWidth / 2 - resizeWidth / 2, canvasHeight / 2 + resizeHeight / 2] // left bottom\n    ];\n    map.setPitch(0); // reset pitch for correct projection\n\n    this.position = result.map(point => map.unproject(point));\n  }\n\n  get coordinates() {\n    return this.position.map(p => [p.lng, p.lat]);\n  }\n\n  get asPolygon() {\n    return {\n      type: 'FeatureCollection',\n      features: [{\n        type: 'Feature',\n        properties: {\n          id: this.id\n        },\n        geometry: {\n          type: 'Polygon',\n          coordinates: [[...this.coordinates, this.coordinates[0]]]\n        }\n      }]\n    };\n  }\n\n  get asPoints() {\n    return {\n      type: 'FeatureCollection',\n      features: this.coordinates.map((point, i) => ({\n        type: 'Feature',\n        properties: {\n          index: i\n        },\n        geometry: {\n          type: 'Point',\n          coordinates: point\n        }\n      }))\n    };\n  }\n\n  get imageSource() {\n    return {\n      id: `${this.id}-raster`,\n      source: {\n        type: 'image',\n        url: this.url,\n        coordinates: this.coordinates\n      }\n    };\n  }\n\n  get polygonSource() {\n    return {\n      id: `${this.id}-polygon`,\n      source: {\n        type: 'geojson',\n        data: this.asPolygon\n      }\n    };\n  }\n\n  get cornersSource() {\n    return {\n      id: `${this.id}-corners`,\n      source: {\n        type: 'geojson',\n        data: this.asPoints\n      }\n    };\n  }\n\n  get rasterLayer() {\n    return {\n      id: `${this.id}-raster`,\n      type: 'raster',\n      source: this.imageSource.id,\n      paint: {\n        'raster-fade-duration': 0,\n        'raster-opacity': 0.5\n      }\n    };\n  }\n\n  get fillLayer() {\n    return {\n      id: `${this.id}-fill`,\n      type: 'fill',\n      source: this.polygonSource.id,\n      paint: {\n        'fill-opacity': 0\n      }\n    };\n  }\n\n  get ratio() {\n    return this.width / this.height;\n  }\n\n  getOppositePoint(index) {\n    if (index === 0) return 2;\n    if (index === 1) return 3;\n    if (index === 2) return 0;\n    if (index === 3) return 1;\n    throw Error('invalid corner index');\n  }\n\n}\n\nexport default IImage;","map":null,"metadata":{},"sourceType":"module"}